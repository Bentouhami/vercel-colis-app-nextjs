
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model AgencyClients
 * 
 */
export type AgencyClients = $Result.DefaultSelection<Prisma.$AgencyClientsPayload>
/**
 * Model AgencyStaff
 * 
 */
export type AgencyStaff = $Result.DefaultSelection<Prisma.$AgencyStaffPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model Authenticator
 * 
 */
export type Authenticator = $Result.DefaultSelection<Prisma.$AuthenticatorPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model VatRate
 * 
 */
export type VatRate = $Result.DefaultSelection<Prisma.$VatRatePayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model Timezone
 * 
 */
export type Timezone = $Result.DefaultSelection<Prisma.$TimezonePayload>
/**
 * Model UserAddress
 * 
 */
export type UserAddress = $Result.DefaultSelection<Prisma.$UserAddressPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model ClientDestinataire
 * 
 */
export type ClientDestinataire = $Result.DefaultSelection<Prisma.$ClientDestinatairePayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model UserCoupon
 * 
 */
export type UserCoupon = $Result.DefaultSelection<Prisma.$UserCouponPayload>
/**
 * Model Transport
 * 
 */
export type Transport = $Result.DefaultSelection<Prisma.$TransportPayload>
/**
 * Model Envoi
 * 
 */
export type Envoi = $Result.DefaultSelection<Prisma.$EnvoiPayload>
/**
 * Model TrackingEvent
 * 
 */
export type TrackingEvent = $Result.DefaultSelection<Prisma.$TrackingEventPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model EnvoiCoupon
 * 
 */
export type EnvoiCoupon = $Result.DefaultSelection<Prisma.$EnvoiCouponPayload>
/**
 * Model Parcel
 * 
 */
export type Parcel = $Result.DefaultSelection<Prisma.$ParcelPayload>
/**
 * Model Tarifs
 * 
 */
export type Tarifs = $Result.DefaultSelection<Prisma.$TarifsPayload>
/**
 * Model TransportSchedule
 * 
 */
export type TransportSchedule = $Result.DefaultSelection<Prisma.$TransportSchedulePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PaymentMethod: {
  CARD: 'CARD',
  CASH: 'CASH'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const Role: {
  CLIENT: 'CLIENT',
  SUPER_ADMIN: 'SUPER_ADMIN',
  DESTINATAIRE: 'DESTINATAIRE',
  AGENCY_ADMIN: 'AGENCY_ADMIN',
  ACCOUNTANT: 'ACCOUNTANT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const VatType: {
  REDUCED: 'REDUCED',
  STANDARD: 'STANDARD',
  EXEMPT: 'EXEMPT'
};

export type VatType = (typeof VatType)[keyof typeof VatType]


export const AddressType: {
  HOME: 'HOME',
  OFFICE: 'OFFICE',
  BILLING: 'BILLING',
  SHIPPING: 'SHIPPING',
  OTHER: 'OTHER'
};

export type AddressType = (typeof AddressType)[keyof typeof AddressType]


export const SimulationStatus: {
  DRAFT: 'DRAFT',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type SimulationStatus = (typeof SimulationStatus)[keyof typeof SimulationStatus]


export const EnvoiStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  RETURNED: 'RETURNED'
};

export type EnvoiStatus = (typeof EnvoiStatus)[keyof typeof EnvoiStatus]


export const AppointmentStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  RESCHEDULED: 'RESCHEDULED',
  COMPLETED: 'COMPLETED',
  MISSED: 'MISSED',
  IN_PROGRESS: 'IN_PROGRESS'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const TrackingEventStatus: {
  CREATED: 'CREATED',
  COLLECTED: 'COLLECTED',
  IN_TRANSIT: 'IN_TRANSIT',
  ARRIVED_AT_AGENCY: 'ARRIVED_AT_AGENCY',
  OUT_FOR_DELIVERY: 'OUT_FOR_DELIVERY',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED'
};

export type TrackingEventStatus = (typeof TrackingEventStatus)[keyof typeof TrackingEventStatus]


export const ActivityType: {
  AGENCY_CREATED: 'AGENCY_CREATED',
  AGENCY_UPDATED: 'AGENCY_UPDATED',
  AGENCY_DELETED: 'AGENCY_DELETED',
  CLIENT_LINKED: 'CLIENT_LINKED',
  CLIENT_UNLINKED: 'CLIENT_UNLINKED',
  CLIENT_UPDATED: 'CLIENT_UPDATED',
  CLIENT_DELETED: 'CLIENT_DELETED',
  CLIENT_CREATED: 'CLIENT_CREATED',
  ENVOI_CREATED: 'ENVOI_CREATED',
  ENVOI_UPDATED: 'ENVOI_UPDATED',
  ENVOI_DELETED: 'ENVOI_DELETED',
  PAYMENT_CREATED: 'PAYMENT_CREATED',
  PAYMENT_UPDATED: 'PAYMENT_UPDATED',
  PAYMENT_DELETED: 'PAYMENT_DELETED',
  TRACKING_EVENT_CREATED: 'TRACKING_EVENT_CREATED',
  TRACKING_EVENT_UPDATED: 'TRACKING_EVENT_UPDATED',
  TRACKING_EVENT_DELETED: 'TRACKING_EVENT_DELETED',
  APPOINTMENT_CREATED: 'APPOINTMENT_CREATED',
  APPOINTMENT_UPDATED: 'APPOINTMENT_UPDATED',
  APPOINTMENT_DELETED: 'APPOINTMENT_DELETED',
  NOTIFICATION_CREATED: 'NOTIFICATION_CREATED',
  NOTIFICATION_UPDATED: 'NOTIFICATION_UPDATED',
  NOTIFICATION_DELETED: 'NOTIFICATION_DELETED',
  AGENCY_ADMIN_ADDED: 'AGENCY_ADMIN_ADDED',
  AGENCY_ADMIN_REMOVED: 'AGENCY_ADMIN_REMOVED',
  ACCOUNTANT_ADDED: 'ACCOUNTANT_ADDED',
  ACCOUNTANT_REMOVED: 'ACCOUNTANT_REMOVED',
  SUPER_ADMIN_ADDED: 'SUPER_ADMIN_ADDED',
  SUPER_ADMIN_REMOVED: 'SUPER_ADMIN_REMOVED',
  TRANSPORT_CREATED: 'TRANSPORT_CREATED',
  TRANSPORT_UPDATED: 'TRANSPORT_UPDATED',
  TRANSPORT_DELETED: 'TRANSPORT_DELETED',
  TARIF_CREATED: 'TARIF_CREATED',
  TARIF_UPDATED: 'TARIF_UPDATED',
  TARIF_DELETED: 'TARIF_DELETED',
  PDF_EXPORTED: 'PDF_EXPORTED',
  CSV_EXPORTED: 'CSV_EXPORTED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]

}

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type VatType = $Enums.VatType

export const VatType: typeof $Enums.VatType

export type AddressType = $Enums.AddressType

export const AddressType: typeof $Enums.AddressType

export type SimulationStatus = $Enums.SimulationStatus

export const SimulationStatus: typeof $Enums.SimulationStatus

export type EnvoiStatus = $Enums.EnvoiStatus

export const EnvoiStatus: typeof $Enums.EnvoiStatus

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type TrackingEventStatus = $Enums.TrackingEventStatus

export const TrackingEventStatus: typeof $Enums.TrackingEventStatus

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more PasswordResetTokens
 * const passwordResetTokens = await prisma.passwordResetToken.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more PasswordResetTokens
   * const passwordResetTokens = await prisma.passwordResetToken.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyClients`: Exposes CRUD operations for the **AgencyClients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyClients
    * const agencyClients = await prisma.agencyClients.findMany()
    * ```
    */
  get agencyClients(): Prisma.AgencyClientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyStaff`: Exposes CRUD operations for the **AgencyStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyStaffs
    * const agencyStaffs = await prisma.agencyStaff.findMany()
    * ```
    */
  get agencyStaff(): Prisma.AgencyStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authenticator`: Exposes CRUD operations for the **Authenticator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authenticators
    * const authenticators = await prisma.authenticator.findMany()
    * ```
    */
  get authenticator(): Prisma.AuthenticatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vatRate`: Exposes CRUD operations for the **VatRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VatRates
    * const vatRates = await prisma.vatRate.findMany()
    * ```
    */
  get vatRate(): Prisma.VatRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timezone`: Exposes CRUD operations for the **Timezone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timezones
    * const timezones = await prisma.timezone.findMany()
    * ```
    */
  get timezone(): Prisma.TimezoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAddress`: Exposes CRUD operations for the **UserAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAddresses
    * const userAddresses = await prisma.userAddress.findMany()
    * ```
    */
  get userAddress(): Prisma.UserAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientDestinataire`: Exposes CRUD operations for the **ClientDestinataire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientDestinataires
    * const clientDestinataires = await prisma.clientDestinataire.findMany()
    * ```
    */
  get clientDestinataire(): Prisma.ClientDestinataireDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCoupon`: Exposes CRUD operations for the **UserCoupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCoupons
    * const userCoupons = await prisma.userCoupon.findMany()
    * ```
    */
  get userCoupon(): Prisma.UserCouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transport`: Exposes CRUD operations for the **Transport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transports
    * const transports = await prisma.transport.findMany()
    * ```
    */
  get transport(): Prisma.TransportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.envoi`: Exposes CRUD operations for the **Envoi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Envois
    * const envois = await prisma.envoi.findMany()
    * ```
    */
  get envoi(): Prisma.EnvoiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trackingEvent`: Exposes CRUD operations for the **TrackingEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrackingEvents
    * const trackingEvents = await prisma.trackingEvent.findMany()
    * ```
    */
  get trackingEvent(): Prisma.TrackingEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.envoiCoupon`: Exposes CRUD operations for the **EnvoiCoupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnvoiCoupons
    * const envoiCoupons = await prisma.envoiCoupon.findMany()
    * ```
    */
  get envoiCoupon(): Prisma.EnvoiCouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parcel`: Exposes CRUD operations for the **Parcel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parcels
    * const parcels = await prisma.parcel.findMany()
    * ```
    */
  get parcel(): Prisma.ParcelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tarifs`: Exposes CRUD operations for the **Tarifs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tarifs
    * const tarifs = await prisma.tarifs.findMany()
    * ```
    */
  get tarifs(): Prisma.TarifsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transportSchedule`: Exposes CRUD operations for the **TransportSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransportSchedules
    * const transportSchedules = await prisma.transportSchedule.findMany()
    * ```
    */
  get transportSchedule(): Prisma.TransportScheduleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    PasswordResetToken: 'PasswordResetToken',
    Payment: 'Payment',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    AgencyClients: 'AgencyClients',
    AgencyStaff: 'AgencyStaff',
    ActivityLog: 'ActivityLog',
    Authenticator: 'Authenticator',
    Notification: 'Notification',
    VatRate: 'VatRate',
    City: 'City',
    Country: 'Country',
    Timezone: 'Timezone',
    UserAddress: 'UserAddress',
    Address: 'Address',
    Agency: 'Agency',
    ClientDestinataire: 'ClientDestinataire',
    Coupon: 'Coupon',
    UserCoupon: 'UserCoupon',
    Transport: 'Transport',
    Envoi: 'Envoi',
    TrackingEvent: 'TrackingEvent',
    Appointment: 'Appointment',
    EnvoiCoupon: 'EnvoiCoupon',
    Parcel: 'Parcel',
    Tarifs: 'Tarifs',
    TransportSchedule: 'TransportSchedule'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "passwordResetToken" | "payment" | "user" | "account" | "session" | "agencyClients" | "agencyStaff" | "activityLog" | "authenticator" | "notification" | "vatRate" | "city" | "country" | "timezone" | "userAddress" | "address" | "agency" | "clientDestinataire" | "coupon" | "userCoupon" | "transport" | "envoi" | "trackingEvent" | "appointment" | "envoiCoupon" | "parcel" | "tarifs" | "transportSchedule"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      AgencyClients: {
        payload: Prisma.$AgencyClientsPayload<ExtArgs>
        fields: Prisma.AgencyClientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyClientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyClientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload>
          }
          findFirst: {
            args: Prisma.AgencyClientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyClientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload>
          }
          findMany: {
            args: Prisma.AgencyClientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload>[]
          }
          create: {
            args: Prisma.AgencyClientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload>
          }
          createMany: {
            args: Prisma.AgencyClientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyClientsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload>[]
          }
          delete: {
            args: Prisma.AgencyClientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload>
          }
          update: {
            args: Prisma.AgencyClientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload>
          }
          deleteMany: {
            args: Prisma.AgencyClientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyClientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyClientsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload>[]
          }
          upsert: {
            args: Prisma.AgencyClientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientsPayload>
          }
          aggregate: {
            args: Prisma.AgencyClientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyClients>
          }
          groupBy: {
            args: Prisma.AgencyClientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyClientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyClientsCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyClientsCountAggregateOutputType> | number
          }
        }
      }
      AgencyStaff: {
        payload: Prisma.$AgencyStaffPayload<ExtArgs>
        fields: Prisma.AgencyStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload>
          }
          findFirst: {
            args: Prisma.AgencyStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload>
          }
          findMany: {
            args: Prisma.AgencyStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload>[]
          }
          create: {
            args: Prisma.AgencyStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload>
          }
          createMany: {
            args: Prisma.AgencyStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload>[]
          }
          delete: {
            args: Prisma.AgencyStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload>
          }
          update: {
            args: Prisma.AgencyStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload>
          }
          deleteMany: {
            args: Prisma.AgencyStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload>[]
          }
          upsert: {
            args: Prisma.AgencyStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyStaffPayload>
          }
          aggregate: {
            args: Prisma.AgencyStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyStaff>
          }
          groupBy: {
            args: Prisma.AgencyStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyStaffCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyStaffCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Authenticator: {
        payload: Prisma.$AuthenticatorPayload<ExtArgs>
        fields: Prisma.AuthenticatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthenticatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthenticatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          findFirst: {
            args: Prisma.AuthenticatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthenticatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          findMany: {
            args: Prisma.AuthenticatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
          }
          create: {
            args: Prisma.AuthenticatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          createMany: {
            args: Prisma.AuthenticatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthenticatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
          }
          delete: {
            args: Prisma.AuthenticatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          update: {
            args: Prisma.AuthenticatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          deleteMany: {
            args: Prisma.AuthenticatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthenticatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthenticatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
          }
          upsert: {
            args: Prisma.AuthenticatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          aggregate: {
            args: Prisma.AuthenticatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthenticator>
          }
          groupBy: {
            args: Prisma.AuthenticatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthenticatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthenticatorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthenticatorCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      VatRate: {
        payload: Prisma.$VatRatePayload<ExtArgs>
        fields: Prisma.VatRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VatRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VatRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload>
          }
          findFirst: {
            args: Prisma.VatRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VatRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload>
          }
          findMany: {
            args: Prisma.VatRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload>[]
          }
          create: {
            args: Prisma.VatRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload>
          }
          createMany: {
            args: Prisma.VatRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VatRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload>[]
          }
          delete: {
            args: Prisma.VatRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload>
          }
          update: {
            args: Prisma.VatRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload>
          }
          deleteMany: {
            args: Prisma.VatRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VatRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VatRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload>[]
          }
          upsert: {
            args: Prisma.VatRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VatRatePayload>
          }
          aggregate: {
            args: Prisma.VatRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVatRate>
          }
          groupBy: {
            args: Prisma.VatRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<VatRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.VatRateCountArgs<ExtArgs>
            result: $Utils.Optional<VatRateCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Timezone: {
        payload: Prisma.$TimezonePayload<ExtArgs>
        fields: Prisma.TimezoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimezoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimezoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload>
          }
          findFirst: {
            args: Prisma.TimezoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimezoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload>
          }
          findMany: {
            args: Prisma.TimezoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload>[]
          }
          create: {
            args: Prisma.TimezoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload>
          }
          createMany: {
            args: Prisma.TimezoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimezoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload>[]
          }
          delete: {
            args: Prisma.TimezoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload>
          }
          update: {
            args: Prisma.TimezoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload>
          }
          deleteMany: {
            args: Prisma.TimezoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimezoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimezoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload>[]
          }
          upsert: {
            args: Prisma.TimezoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimezonePayload>
          }
          aggregate: {
            args: Prisma.TimezoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimezone>
          }
          groupBy: {
            args: Prisma.TimezoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimezoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimezoneCountArgs<ExtArgs>
            result: $Utils.Optional<TimezoneCountAggregateOutputType> | number
          }
        }
      }
      UserAddress: {
        payload: Prisma.$UserAddressPayload<ExtArgs>
        fields: Prisma.UserAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findFirst: {
            args: Prisma.UserAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findMany: {
            args: Prisma.UserAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          create: {
            args: Prisma.UserAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          createMany: {
            args: Prisma.UserAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          delete: {
            args: Prisma.UserAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          update: {
            args: Prisma.UserAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          deleteMany: {
            args: Prisma.UserAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          upsert: {
            args: Prisma.UserAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          aggregate: {
            args: Prisma.UserAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAddress>
          }
          groupBy: {
            args: Prisma.UserAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAddressCountArgs<ExtArgs>
            result: $Utils.Optional<UserAddressCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      ClientDestinataire: {
        payload: Prisma.$ClientDestinatairePayload<ExtArgs>
        fields: Prisma.ClientDestinataireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientDestinataireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientDestinataireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload>
          }
          findFirst: {
            args: Prisma.ClientDestinataireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientDestinataireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload>
          }
          findMany: {
            args: Prisma.ClientDestinataireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload>[]
          }
          create: {
            args: Prisma.ClientDestinataireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload>
          }
          createMany: {
            args: Prisma.ClientDestinataireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientDestinataireCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload>[]
          }
          delete: {
            args: Prisma.ClientDestinataireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload>
          }
          update: {
            args: Prisma.ClientDestinataireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload>
          }
          deleteMany: {
            args: Prisma.ClientDestinataireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientDestinataireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientDestinataireUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload>[]
          }
          upsert: {
            args: Prisma.ClientDestinataireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDestinatairePayload>
          }
          aggregate: {
            args: Prisma.ClientDestinataireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientDestinataire>
          }
          groupBy: {
            args: Prisma.ClientDestinataireGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientDestinataireGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientDestinataireCountArgs<ExtArgs>
            result: $Utils.Optional<ClientDestinataireCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      UserCoupon: {
        payload: Prisma.$UserCouponPayload<ExtArgs>
        fields: Prisma.UserCouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          findFirst: {
            args: Prisma.UserCouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          findMany: {
            args: Prisma.UserCouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>[]
          }
          create: {
            args: Prisma.UserCouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          createMany: {
            args: Prisma.UserCouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>[]
          }
          delete: {
            args: Prisma.UserCouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          update: {
            args: Prisma.UserCouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          deleteMany: {
            args: Prisma.UserCouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>[]
          }
          upsert: {
            args: Prisma.UserCouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          aggregate: {
            args: Prisma.UserCouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCoupon>
          }
          groupBy: {
            args: Prisma.UserCouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCouponCountArgs<ExtArgs>
            result: $Utils.Optional<UserCouponCountAggregateOutputType> | number
          }
        }
      }
      Transport: {
        payload: Prisma.$TransportPayload<ExtArgs>
        fields: Prisma.TransportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          findFirst: {
            args: Prisma.TransportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          findMany: {
            args: Prisma.TransportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>[]
          }
          create: {
            args: Prisma.TransportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          createMany: {
            args: Prisma.TransportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>[]
          }
          delete: {
            args: Prisma.TransportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          update: {
            args: Prisma.TransportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          deleteMany: {
            args: Prisma.TransportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>[]
          }
          upsert: {
            args: Prisma.TransportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          aggregate: {
            args: Prisma.TransportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransport>
          }
          groupBy: {
            args: Prisma.TransportGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransportGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransportCountArgs<ExtArgs>
            result: $Utils.Optional<TransportCountAggregateOutputType> | number
          }
        }
      }
      Envoi: {
        payload: Prisma.$EnvoiPayload<ExtArgs>
        fields: Prisma.EnvoiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvoiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvoiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload>
          }
          findFirst: {
            args: Prisma.EnvoiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvoiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload>
          }
          findMany: {
            args: Prisma.EnvoiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload>[]
          }
          create: {
            args: Prisma.EnvoiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload>
          }
          createMany: {
            args: Prisma.EnvoiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnvoiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload>[]
          }
          delete: {
            args: Prisma.EnvoiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload>
          }
          update: {
            args: Prisma.EnvoiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload>
          }
          deleteMany: {
            args: Prisma.EnvoiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnvoiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnvoiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload>[]
          }
          upsert: {
            args: Prisma.EnvoiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiPayload>
          }
          aggregate: {
            args: Prisma.EnvoiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnvoi>
          }
          groupBy: {
            args: Prisma.EnvoiGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnvoiGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvoiCountArgs<ExtArgs>
            result: $Utils.Optional<EnvoiCountAggregateOutputType> | number
          }
        }
      }
      TrackingEvent: {
        payload: Prisma.$TrackingEventPayload<ExtArgs>
        fields: Prisma.TrackingEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrackingEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrackingEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload>
          }
          findFirst: {
            args: Prisma.TrackingEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrackingEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload>
          }
          findMany: {
            args: Prisma.TrackingEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload>[]
          }
          create: {
            args: Prisma.TrackingEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload>
          }
          createMany: {
            args: Prisma.TrackingEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrackingEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload>[]
          }
          delete: {
            args: Prisma.TrackingEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload>
          }
          update: {
            args: Prisma.TrackingEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload>
          }
          deleteMany: {
            args: Prisma.TrackingEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrackingEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrackingEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload>[]
          }
          upsert: {
            args: Prisma.TrackingEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingEventPayload>
          }
          aggregate: {
            args: Prisma.TrackingEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrackingEvent>
          }
          groupBy: {
            args: Prisma.TrackingEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrackingEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrackingEventCountArgs<ExtArgs>
            result: $Utils.Optional<TrackingEventCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      EnvoiCoupon: {
        payload: Prisma.$EnvoiCouponPayload<ExtArgs>
        fields: Prisma.EnvoiCouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvoiCouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvoiCouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload>
          }
          findFirst: {
            args: Prisma.EnvoiCouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvoiCouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload>
          }
          findMany: {
            args: Prisma.EnvoiCouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload>[]
          }
          create: {
            args: Prisma.EnvoiCouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload>
          }
          createMany: {
            args: Prisma.EnvoiCouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnvoiCouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload>[]
          }
          delete: {
            args: Prisma.EnvoiCouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload>
          }
          update: {
            args: Prisma.EnvoiCouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload>
          }
          deleteMany: {
            args: Prisma.EnvoiCouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnvoiCouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnvoiCouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload>[]
          }
          upsert: {
            args: Prisma.EnvoiCouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvoiCouponPayload>
          }
          aggregate: {
            args: Prisma.EnvoiCouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnvoiCoupon>
          }
          groupBy: {
            args: Prisma.EnvoiCouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnvoiCouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvoiCouponCountArgs<ExtArgs>
            result: $Utils.Optional<EnvoiCouponCountAggregateOutputType> | number
          }
        }
      }
      Parcel: {
        payload: Prisma.$ParcelPayload<ExtArgs>
        fields: Prisma.ParcelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParcelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParcelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          findFirst: {
            args: Prisma.ParcelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParcelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          findMany: {
            args: Prisma.ParcelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>[]
          }
          create: {
            args: Prisma.ParcelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          createMany: {
            args: Prisma.ParcelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParcelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>[]
          }
          delete: {
            args: Prisma.ParcelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          update: {
            args: Prisma.ParcelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          deleteMany: {
            args: Prisma.ParcelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParcelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParcelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>[]
          }
          upsert: {
            args: Prisma.ParcelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          aggregate: {
            args: Prisma.ParcelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParcel>
          }
          groupBy: {
            args: Prisma.ParcelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParcelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParcelCountArgs<ExtArgs>
            result: $Utils.Optional<ParcelCountAggregateOutputType> | number
          }
        }
      }
      Tarifs: {
        payload: Prisma.$TarifsPayload<ExtArgs>
        fields: Prisma.TarifsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TarifsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TarifsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload>
          }
          findFirst: {
            args: Prisma.TarifsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TarifsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload>
          }
          findMany: {
            args: Prisma.TarifsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload>[]
          }
          create: {
            args: Prisma.TarifsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload>
          }
          createMany: {
            args: Prisma.TarifsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TarifsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload>[]
          }
          delete: {
            args: Prisma.TarifsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload>
          }
          update: {
            args: Prisma.TarifsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload>
          }
          deleteMany: {
            args: Prisma.TarifsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TarifsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TarifsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload>[]
          }
          upsert: {
            args: Prisma.TarifsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifsPayload>
          }
          aggregate: {
            args: Prisma.TarifsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTarifs>
          }
          groupBy: {
            args: Prisma.TarifsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TarifsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TarifsCountArgs<ExtArgs>
            result: $Utils.Optional<TarifsCountAggregateOutputType> | number
          }
        }
      }
      TransportSchedule: {
        payload: Prisma.$TransportSchedulePayload<ExtArgs>
        fields: Prisma.TransportScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransportScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransportScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload>
          }
          findFirst: {
            args: Prisma.TransportScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransportScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload>
          }
          findMany: {
            args: Prisma.TransportScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload>[]
          }
          create: {
            args: Prisma.TransportScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload>
          }
          createMany: {
            args: Prisma.TransportScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransportScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload>[]
          }
          delete: {
            args: Prisma.TransportScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload>
          }
          update: {
            args: Prisma.TransportScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload>
          }
          deleteMany: {
            args: Prisma.TransportScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransportScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransportScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload>[]
          }
          upsert: {
            args: Prisma.TransportScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSchedulePayload>
          }
          aggregate: {
            args: Prisma.TransportScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransportSchedule>
          }
          groupBy: {
            args: Prisma.TransportScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransportScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransportScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<TransportScheduleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    passwordResetToken?: PasswordResetTokenOmit
    payment?: PaymentOmit
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    agencyClients?: AgencyClientsOmit
    agencyStaff?: AgencyStaffOmit
    activityLog?: ActivityLogOmit
    authenticator?: AuthenticatorOmit
    notification?: NotificationOmit
    vatRate?: VatRateOmit
    city?: CityOmit
    country?: CountryOmit
    timezone?: TimezoneOmit
    userAddress?: UserAddressOmit
    address?: AddressOmit
    agency?: AgencyOmit
    clientDestinataire?: ClientDestinataireOmit
    coupon?: CouponOmit
    userCoupon?: UserCouponOmit
    transport?: TransportOmit
    envoi?: EnvoiOmit
    trackingEvent?: TrackingEventOmit
    appointment?: AppointmentOmit
    envoiCoupon?: EnvoiCouponOmit
    parcel?: ParcelOmit
    tarifs?: TarifsOmit
    transportSchedule?: TransportScheduleOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    authenticator: number
    sentEnvois: number
    receivedEnvois: number
    notificationsAsDestinataire: number
    notificationAsClient: number
    userCoupons: number
    clientLinks: number
    destinataireLinks: number
    clientAgencies: number
    agencyStaffs: number
    userAddresses: number
    createdAgencies: number
    staffsActivityLogs: number
    passwordResetTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    authenticator?: boolean | UserCountOutputTypeCountAuthenticatorArgs
    sentEnvois?: boolean | UserCountOutputTypeCountSentEnvoisArgs
    receivedEnvois?: boolean | UserCountOutputTypeCountReceivedEnvoisArgs
    notificationsAsDestinataire?: boolean | UserCountOutputTypeCountNotificationsAsDestinataireArgs
    notificationAsClient?: boolean | UserCountOutputTypeCountNotificationAsClientArgs
    userCoupons?: boolean | UserCountOutputTypeCountUserCouponsArgs
    clientLinks?: boolean | UserCountOutputTypeCountClientLinksArgs
    destinataireLinks?: boolean | UserCountOutputTypeCountDestinataireLinksArgs
    clientAgencies?: boolean | UserCountOutputTypeCountClientAgenciesArgs
    agencyStaffs?: boolean | UserCountOutputTypeCountAgencyStaffsArgs
    userAddresses?: boolean | UserCountOutputTypeCountUserAddressesArgs
    createdAgencies?: boolean | UserCountOutputTypeCountCreatedAgenciesArgs
    staffsActivityLogs?: boolean | UserCountOutputTypeCountStaffsActivityLogsArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthenticatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthenticatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentEnvoisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvoiWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedEnvoisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvoiWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsAsDestinataireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationAsClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCouponWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientDestinataireWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDestinataireLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientDestinataireWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientAgenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgencyStaffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyStaffWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAgenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffsActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    addresses: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | CityCountOutputTypeCountAddressesArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    cities: number
    timezones: number
    vatRates: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | CountryCountOutputTypeCountCitiesArgs
    timezones?: boolean | CountryCountOutputTypeCountTimezonesArgs
    vatRates?: boolean | CountryCountOutputTypeCountVatRatesArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountTimezonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimezoneWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountVatRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VatRateWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    userAddresses: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAddresses?: boolean | AddressCountOutputTypeCountUserAddressesArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountUserAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
  }


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    arrivalEnvoi: number
    departureEnvoi: number
    notifications: number
    appointments: number
    transports: number
    tarifs: number
    agencyClients: number
    agencyStaff: number
    activityLogs: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrivalEnvoi?: boolean | AgencyCountOutputTypeCountArrivalEnvoiArgs
    departureEnvoi?: boolean | AgencyCountOutputTypeCountDepartureEnvoiArgs
    notifications?: boolean | AgencyCountOutputTypeCountNotificationsArgs
    appointments?: boolean | AgencyCountOutputTypeCountAppointmentsArgs
    transports?: boolean | AgencyCountOutputTypeCountTransportsArgs
    tarifs?: boolean | AgencyCountOutputTypeCountTarifsArgs
    agencyClients?: boolean | AgencyCountOutputTypeCountAgencyClientsArgs
    agencyStaff?: boolean | AgencyCountOutputTypeCountAgencyStaffArgs
    activityLogs?: boolean | AgencyCountOutputTypeCountActivityLogsArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountArrivalEnvoiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvoiWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountDepartureEnvoiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvoiWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountTransportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountTarifsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TarifsWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgencyClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientsWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgencyStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyStaffWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    userCoupon: number
    envoiCoupon: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCoupon?: boolean | CouponCountOutputTypeCountUserCouponArgs
    envoiCoupon?: boolean | CouponCountOutputTypeCountEnvoiCouponArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountUserCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCouponWhereInput
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountEnvoiCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvoiCouponWhereInput
  }


  /**
   * Count Type TransportCountOutputType
   */

  export type TransportCountOutputType = {
    envois: number
    transportSchedules: number
  }

  export type TransportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envois?: boolean | TransportCountOutputTypeCountEnvoisArgs
    transportSchedules?: boolean | TransportCountOutputTypeCountTransportSchedulesArgs
  }

  // Custom InputTypes
  /**
   * TransportCountOutputType without action
   */
  export type TransportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportCountOutputType
     */
    select?: TransportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransportCountOutputType without action
   */
  export type TransportCountOutputTypeCountEnvoisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvoiWhereInput
  }

  /**
   * TransportCountOutputType without action
   */
  export type TransportCountOutputTypeCountTransportSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportScheduleWhereInput
  }


  /**
   * Count Type EnvoiCountOutputType
   */

  export type EnvoiCountOutputType = {
    envoiCoupons: number
    parcels: number
    notifications: number
    trackingEvents: number
  }

  export type EnvoiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoiCoupons?: boolean | EnvoiCountOutputTypeCountEnvoiCouponsArgs
    parcels?: boolean | EnvoiCountOutputTypeCountParcelsArgs
    notifications?: boolean | EnvoiCountOutputTypeCountNotificationsArgs
    trackingEvents?: boolean | EnvoiCountOutputTypeCountTrackingEventsArgs
  }

  // Custom InputTypes
  /**
   * EnvoiCountOutputType without action
   */
  export type EnvoiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCountOutputType
     */
    select?: EnvoiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnvoiCountOutputType without action
   */
  export type EnvoiCountOutputTypeCountEnvoiCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvoiCouponWhereInput
  }

  /**
   * EnvoiCountOutputType without action
   */
  export type EnvoiCountOutputTypeCountParcelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcelWhereInput
  }

  /**
   * EnvoiCountOutputType without action
   */
  export type EnvoiCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * EnvoiCountOutputType without action
   */
  export type EnvoiCountOutputTypeCountTrackingEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackingEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    userId: number | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    userId: number | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    token: number
    expiresAt: number
    userId: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _avg?: PasswordResetTokenAvgAggregateInputType
    _sum?: PasswordResetTokenSumAggregateInputType
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: number
    token: string
    expiresAt: Date
    userId: number
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "expiresAt" | "userId" | "createdAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      expiresAt: Date
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'Int'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly userId: FieldRef<"PasswordResetToken", 'Int'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    envoiId: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    envoiId: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    envoiId: number | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    amount: number | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    envoiId: number | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    amount: number | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    envoiId: number
    method: number
    status: number
    amount: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    envoiId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    envoiId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    envoiId?: true
    method?: true
    status?: true
    amount?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    envoiId?: true
    method?: true
    status?: true
    amount?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    envoiId?: true
    method?: true
    status?: true
    amount?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    envoiId: number
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amount: number
    transactionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    method?: boolean
    status?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    method?: boolean
    status?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    method?: boolean
    status?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    envoiId?: boolean
    method?: boolean
    status?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "envoiId" | "method" | "status" | "amount" | "transactionId" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      envoi: Prisma.$EnvoiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      envoiId: number
      method: $Enums.PaymentMethod
      status: $Enums.PaymentStatus
      amount: number
      transactionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    envoi<T extends EnvoiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvoiDefaultArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly envoiId: FieldRef<"Payment", 'Int'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    name: string | null
    birthDate: Date | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    image: string | null
    role: $Enums.Role | null
    isVerified: boolean | null
    emailVerified: Date | null
    verificationToken: string | null
    verificationTokenExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isEnterprise: boolean | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    name: string | null
    birthDate: Date | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    image: string | null
    role: $Enums.Role | null
    isVerified: boolean | null
    emailVerified: Date | null
    verificationToken: string | null
    verificationTokenExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isEnterprise: boolean | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    name: number
    birthDate: number
    email: number
    phoneNumber: number
    password: number
    image: number
    role: number
    isVerified: number
    emailVerified: number
    verificationToken: number
    verificationTokenExpires: number
    createdAt: number
    updatedAt: number
    isEnterprise: number
    lastLogin: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    name?: true
    birthDate?: true
    email?: true
    phoneNumber?: true
    password?: true
    image?: true
    role?: true
    isVerified?: true
    emailVerified?: true
    verificationToken?: true
    verificationTokenExpires?: true
    createdAt?: true
    updatedAt?: true
    isEnterprise?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    name?: true
    birthDate?: true
    email?: true
    phoneNumber?: true
    password?: true
    image?: true
    role?: true
    isVerified?: true
    emailVerified?: true
    verificationToken?: true
    verificationTokenExpires?: true
    createdAt?: true
    updatedAt?: true
    isEnterprise?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    name?: true
    birthDate?: true
    email?: true
    phoneNumber?: true
    password?: true
    image?: true
    role?: true
    isVerified?: true
    emailVerified?: true
    verificationToken?: true
    verificationTokenExpires?: true
    createdAt?: true
    updatedAt?: true
    isEnterprise?: true
    lastLogin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    firstName: string | null
    lastName: string | null
    name: string | null
    birthDate: Date | null
    email: string
    phoneNumber: string | null
    password: string | null
    image: string | null
    role: $Enums.Role
    isVerified: boolean | null
    emailVerified: Date | null
    verificationToken: string | null
    verificationTokenExpires: Date | null
    createdAt: Date
    updatedAt: Date
    isEnterprise: boolean
    lastLogin: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    birthDate?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    isVerified?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isEnterprise?: boolean
    lastLogin?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    authenticator?: boolean | User$authenticatorArgs<ExtArgs>
    sentEnvois?: boolean | User$sentEnvoisArgs<ExtArgs>
    receivedEnvois?: boolean | User$receivedEnvoisArgs<ExtArgs>
    notificationsAsDestinataire?: boolean | User$notificationsAsDestinataireArgs<ExtArgs>
    notificationAsClient?: boolean | User$notificationAsClientArgs<ExtArgs>
    userCoupons?: boolean | User$userCouponsArgs<ExtArgs>
    clientLinks?: boolean | User$clientLinksArgs<ExtArgs>
    destinataireLinks?: boolean | User$destinataireLinksArgs<ExtArgs>
    clientAgencies?: boolean | User$clientAgenciesArgs<ExtArgs>
    agencyStaffs?: boolean | User$agencyStaffsArgs<ExtArgs>
    userAddresses?: boolean | User$userAddressesArgs<ExtArgs>
    createdAgencies?: boolean | User$createdAgenciesArgs<ExtArgs>
    staffsActivityLogs?: boolean | User$staffsActivityLogsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    birthDate?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    isVerified?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isEnterprise?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    birthDate?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    isVerified?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isEnterprise?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    birthDate?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    isVerified?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isEnterprise?: boolean
    lastLogin?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "name" | "birthDate" | "email" | "phoneNumber" | "password" | "image" | "role" | "isVerified" | "emailVerified" | "verificationToken" | "verificationTokenExpires" | "createdAt" | "updatedAt" | "isEnterprise" | "lastLogin", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    authenticator?: boolean | User$authenticatorArgs<ExtArgs>
    sentEnvois?: boolean | User$sentEnvoisArgs<ExtArgs>
    receivedEnvois?: boolean | User$receivedEnvoisArgs<ExtArgs>
    notificationsAsDestinataire?: boolean | User$notificationsAsDestinataireArgs<ExtArgs>
    notificationAsClient?: boolean | User$notificationAsClientArgs<ExtArgs>
    userCoupons?: boolean | User$userCouponsArgs<ExtArgs>
    clientLinks?: boolean | User$clientLinksArgs<ExtArgs>
    destinataireLinks?: boolean | User$destinataireLinksArgs<ExtArgs>
    clientAgencies?: boolean | User$clientAgenciesArgs<ExtArgs>
    agencyStaffs?: boolean | User$agencyStaffsArgs<ExtArgs>
    userAddresses?: boolean | User$userAddressesArgs<ExtArgs>
    createdAgencies?: boolean | User$createdAgenciesArgs<ExtArgs>
    staffsActivityLogs?: boolean | User$staffsActivityLogsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      authenticator: Prisma.$AuthenticatorPayload<ExtArgs>[]
      sentEnvois: Prisma.$EnvoiPayload<ExtArgs>[]
      receivedEnvois: Prisma.$EnvoiPayload<ExtArgs>[]
      notificationsAsDestinataire: Prisma.$NotificationPayload<ExtArgs>[]
      notificationAsClient: Prisma.$NotificationPayload<ExtArgs>[]
      userCoupons: Prisma.$UserCouponPayload<ExtArgs>[]
      clientLinks: Prisma.$ClientDestinatairePayload<ExtArgs>[]
      destinataireLinks: Prisma.$ClientDestinatairePayload<ExtArgs>[]
      clientAgencies: Prisma.$AgencyClientsPayload<ExtArgs>[]
      agencyStaffs: Prisma.$AgencyStaffPayload<ExtArgs>[]
      userAddresses: Prisma.$UserAddressPayload<ExtArgs>[]
      createdAgencies: Prisma.$AgencyPayload<ExtArgs>[]
      staffsActivityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string | null
      lastName: string | null
      name: string | null
      birthDate: Date | null
      email: string
      phoneNumber: string | null
      password: string | null
      image: string | null
      role: $Enums.Role
      isVerified: boolean | null
      emailVerified: Date | null
      verificationToken: string | null
      verificationTokenExpires: Date | null
      createdAt: Date
      updatedAt: Date
      isEnterprise: boolean
      lastLogin: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authenticator<T extends User$authenticatorArgs<ExtArgs> = {}>(args?: Subset<T, User$authenticatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentEnvois<T extends User$sentEnvoisArgs<ExtArgs> = {}>(args?: Subset<T, User$sentEnvoisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedEnvois<T extends User$receivedEnvoisArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedEnvoisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationsAsDestinataire<T extends User$notificationsAsDestinataireArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsAsDestinataireArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationAsClient<T extends User$notificationAsClientArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationAsClientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userCoupons<T extends User$userCouponsArgs<ExtArgs> = {}>(args?: Subset<T, User$userCouponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientLinks<T extends User$clientLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$clientLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    destinataireLinks<T extends User$destinataireLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$destinataireLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAgencies<T extends User$clientAgenciesArgs<ExtArgs> = {}>(args?: Subset<T, User$clientAgenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencyStaffs<T extends User$agencyStaffsArgs<ExtArgs> = {}>(args?: Subset<T, User$agencyStaffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userAddresses<T extends User$userAddressesArgs<ExtArgs> = {}>(args?: Subset<T, User$userAddressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdAgencies<T extends User$createdAgenciesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdAgenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staffsActivityLogs<T extends User$staffsActivityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$staffsActivityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly verificationTokenExpires: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly isEnterprise: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.authenticator
   */
  export type User$authenticatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    where?: AuthenticatorWhereInput
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    cursor?: AuthenticatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * User.sentEnvois
   */
  export type User$sentEnvoisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    where?: EnvoiWhereInput
    orderBy?: EnvoiOrderByWithRelationInput | EnvoiOrderByWithRelationInput[]
    cursor?: EnvoiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvoiScalarFieldEnum | EnvoiScalarFieldEnum[]
  }

  /**
   * User.receivedEnvois
   */
  export type User$receivedEnvoisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    where?: EnvoiWhereInput
    orderBy?: EnvoiOrderByWithRelationInput | EnvoiOrderByWithRelationInput[]
    cursor?: EnvoiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvoiScalarFieldEnum | EnvoiScalarFieldEnum[]
  }

  /**
   * User.notificationsAsDestinataire
   */
  export type User$notificationsAsDestinataireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.notificationAsClient
   */
  export type User$notificationAsClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.userCoupons
   */
  export type User$userCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    where?: UserCouponWhereInput
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    cursor?: UserCouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * User.clientLinks
   */
  export type User$clientLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    where?: ClientDestinataireWhereInput
    orderBy?: ClientDestinataireOrderByWithRelationInput | ClientDestinataireOrderByWithRelationInput[]
    cursor?: ClientDestinataireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientDestinataireScalarFieldEnum | ClientDestinataireScalarFieldEnum[]
  }

  /**
   * User.destinataireLinks
   */
  export type User$destinataireLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    where?: ClientDestinataireWhereInput
    orderBy?: ClientDestinataireOrderByWithRelationInput | ClientDestinataireOrderByWithRelationInput[]
    cursor?: ClientDestinataireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientDestinataireScalarFieldEnum | ClientDestinataireScalarFieldEnum[]
  }

  /**
   * User.clientAgencies
   */
  export type User$clientAgenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    where?: AgencyClientsWhereInput
    orderBy?: AgencyClientsOrderByWithRelationInput | AgencyClientsOrderByWithRelationInput[]
    cursor?: AgencyClientsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyClientsScalarFieldEnum | AgencyClientsScalarFieldEnum[]
  }

  /**
   * User.agencyStaffs
   */
  export type User$agencyStaffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    where?: AgencyStaffWhereInput
    orderBy?: AgencyStaffOrderByWithRelationInput | AgencyStaffOrderByWithRelationInput[]
    cursor?: AgencyStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyStaffScalarFieldEnum | AgencyStaffScalarFieldEnum[]
  }

  /**
   * User.userAddresses
   */
  export type User$userAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    cursor?: UserAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * User.createdAgencies
   */
  export type User$createdAgenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    cursor?: AgencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * User.staffsActivityLogs
   */
  export type User$staffsActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    userId: number | null
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    userId: number | null
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    userId: number | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    userId: number | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    userId?: true
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    userId?: true
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    userId: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const accountWithUserIdOnly = await prisma.account.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly userId: FieldRef<"Account", 'Int'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    sessionToken: string | null
    userId: number | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    sessionToken: string | null
    userId: number | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    sessionToken: string
    userId: number
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionToken" | "userId" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionToken: string
      userId: number
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.findMany({ select: { sessionToken: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.createManyAndReturn({
     *   select: { sessionToken: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.updateManyAndReturn({
     *   select: { sessionToken: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model AgencyClients
   */

  export type AggregateAgencyClients = {
    _count: AgencyClientsCountAggregateOutputType | null
    _avg: AgencyClientsAvgAggregateOutputType | null
    _sum: AgencyClientsSumAggregateOutputType | null
    _min: AgencyClientsMinAggregateOutputType | null
    _max: AgencyClientsMaxAggregateOutputType | null
  }

  export type AgencyClientsAvgAggregateOutputType = {
    clientId: number | null
    agencyId: number | null
  }

  export type AgencyClientsSumAggregateOutputType = {
    clientId: number | null
    agencyId: number | null
  }

  export type AgencyClientsMinAggregateOutputType = {
    clientId: number | null
    agencyId: number | null
  }

  export type AgencyClientsMaxAggregateOutputType = {
    clientId: number | null
    agencyId: number | null
  }

  export type AgencyClientsCountAggregateOutputType = {
    clientId: number
    agencyId: number
    _all: number
  }


  export type AgencyClientsAvgAggregateInputType = {
    clientId?: true
    agencyId?: true
  }

  export type AgencyClientsSumAggregateInputType = {
    clientId?: true
    agencyId?: true
  }

  export type AgencyClientsMinAggregateInputType = {
    clientId?: true
    agencyId?: true
  }

  export type AgencyClientsMaxAggregateInputType = {
    clientId?: true
    agencyId?: true
  }

  export type AgencyClientsCountAggregateInputType = {
    clientId?: true
    agencyId?: true
    _all?: true
  }

  export type AgencyClientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyClients to aggregate.
     */
    where?: AgencyClientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClients to fetch.
     */
    orderBy?: AgencyClientsOrderByWithRelationInput | AgencyClientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyClientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyClients
    **/
    _count?: true | AgencyClientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyClientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyClientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyClientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyClientsMaxAggregateInputType
  }

  export type GetAgencyClientsAggregateType<T extends AgencyClientsAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyClients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyClients[P]>
      : GetScalarType<T[P], AggregateAgencyClients[P]>
  }




  export type AgencyClientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientsWhereInput
    orderBy?: AgencyClientsOrderByWithAggregationInput | AgencyClientsOrderByWithAggregationInput[]
    by: AgencyClientsScalarFieldEnum[] | AgencyClientsScalarFieldEnum
    having?: AgencyClientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyClientsCountAggregateInputType | true
    _avg?: AgencyClientsAvgAggregateInputType
    _sum?: AgencyClientsSumAggregateInputType
    _min?: AgencyClientsMinAggregateInputType
    _max?: AgencyClientsMaxAggregateInputType
  }

  export type AgencyClientsGroupByOutputType = {
    clientId: number
    agencyId: number
    _count: AgencyClientsCountAggregateOutputType | null
    _avg: AgencyClientsAvgAggregateOutputType | null
    _sum: AgencyClientsSumAggregateOutputType | null
    _min: AgencyClientsMinAggregateOutputType | null
    _max: AgencyClientsMaxAggregateOutputType | null
  }

  type GetAgencyClientsGroupByPayload<T extends AgencyClientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyClientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyClientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyClientsGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyClientsGroupByOutputType[P]>
        }
      >
    >


  export type AgencyClientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    agencyId?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClients"]>

  export type AgencyClientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    agencyId?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClients"]>

  export type AgencyClientsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    agencyId?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClients"]>

  export type AgencyClientsSelectScalar = {
    clientId?: boolean
    agencyId?: boolean
  }

  export type AgencyClientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"clientId" | "agencyId", ExtArgs["result"]["agencyClients"]>
  export type AgencyClientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type AgencyClientsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type AgencyClientsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $AgencyClientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyClients"
    objects: {
      client: Prisma.$UserPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      clientId: number
      agencyId: number
    }, ExtArgs["result"]["agencyClients"]>
    composites: {}
  }

  type AgencyClientsGetPayload<S extends boolean | null | undefined | AgencyClientsDefaultArgs> = $Result.GetResult<Prisma.$AgencyClientsPayload, S>

  type AgencyClientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyClientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyClientsCountAggregateInputType | true
    }

  export interface AgencyClientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyClients'], meta: { name: 'AgencyClients' } }
    /**
     * Find zero or one AgencyClients that matches the filter.
     * @param {AgencyClientsFindUniqueArgs} args - Arguments to find a AgencyClients
     * @example
     * // Get one AgencyClients
     * const agencyClients = await prisma.agencyClients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyClientsFindUniqueArgs>(args: SelectSubset<T, AgencyClientsFindUniqueArgs<ExtArgs>>): Prisma__AgencyClientsClient<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyClients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyClientsFindUniqueOrThrowArgs} args - Arguments to find a AgencyClients
     * @example
     * // Get one AgencyClients
     * const agencyClients = await prisma.agencyClients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyClientsFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyClientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClientsClient<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientsFindFirstArgs} args - Arguments to find a AgencyClients
     * @example
     * // Get one AgencyClients
     * const agencyClients = await prisma.agencyClients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyClientsFindFirstArgs>(args?: SelectSubset<T, AgencyClientsFindFirstArgs<ExtArgs>>): Prisma__AgencyClientsClient<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyClients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientsFindFirstOrThrowArgs} args - Arguments to find a AgencyClients
     * @example
     * // Get one AgencyClients
     * const agencyClients = await prisma.agencyClients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyClientsFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyClientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClientsClient<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyClients
     * const agencyClients = await prisma.agencyClients.findMany()
     * 
     * // Get first 10 AgencyClients
     * const agencyClients = await prisma.agencyClients.findMany({ take: 10 })
     * 
     * // Only select the `clientId`
     * const agencyClientsWithClientIdOnly = await prisma.agencyClients.findMany({ select: { clientId: true } })
     * 
     */
    findMany<T extends AgencyClientsFindManyArgs>(args?: SelectSubset<T, AgencyClientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyClients.
     * @param {AgencyClientsCreateArgs} args - Arguments to create a AgencyClients.
     * @example
     * // Create one AgencyClients
     * const AgencyClients = await prisma.agencyClients.create({
     *   data: {
     *     // ... data to create a AgencyClients
     *   }
     * })
     * 
     */
    create<T extends AgencyClientsCreateArgs>(args: SelectSubset<T, AgencyClientsCreateArgs<ExtArgs>>): Prisma__AgencyClientsClient<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyClients.
     * @param {AgencyClientsCreateManyArgs} args - Arguments to create many AgencyClients.
     * @example
     * // Create many AgencyClients
     * const agencyClients = await prisma.agencyClients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyClientsCreateManyArgs>(args?: SelectSubset<T, AgencyClientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyClients and returns the data saved in the database.
     * @param {AgencyClientsCreateManyAndReturnArgs} args - Arguments to create many AgencyClients.
     * @example
     * // Create many AgencyClients
     * const agencyClients = await prisma.agencyClients.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyClients and only return the `clientId`
     * const agencyClientsWithClientIdOnly = await prisma.agencyClients.createManyAndReturn({
     *   select: { clientId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyClientsCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyClientsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyClients.
     * @param {AgencyClientsDeleteArgs} args - Arguments to delete one AgencyClients.
     * @example
     * // Delete one AgencyClients
     * const AgencyClients = await prisma.agencyClients.delete({
     *   where: {
     *     // ... filter to delete one AgencyClients
     *   }
     * })
     * 
     */
    delete<T extends AgencyClientsDeleteArgs>(args: SelectSubset<T, AgencyClientsDeleteArgs<ExtArgs>>): Prisma__AgencyClientsClient<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyClients.
     * @param {AgencyClientsUpdateArgs} args - Arguments to update one AgencyClients.
     * @example
     * // Update one AgencyClients
     * const agencyClients = await prisma.agencyClients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyClientsUpdateArgs>(args: SelectSubset<T, AgencyClientsUpdateArgs<ExtArgs>>): Prisma__AgencyClientsClient<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyClients.
     * @param {AgencyClientsDeleteManyArgs} args - Arguments to filter AgencyClients to delete.
     * @example
     * // Delete a few AgencyClients
     * const { count } = await prisma.agencyClients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyClientsDeleteManyArgs>(args?: SelectSubset<T, AgencyClientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyClients
     * const agencyClients = await prisma.agencyClients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyClientsUpdateManyArgs>(args: SelectSubset<T, AgencyClientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyClients and returns the data updated in the database.
     * @param {AgencyClientsUpdateManyAndReturnArgs} args - Arguments to update many AgencyClients.
     * @example
     * // Update many AgencyClients
     * const agencyClients = await prisma.agencyClients.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyClients and only return the `clientId`
     * const agencyClientsWithClientIdOnly = await prisma.agencyClients.updateManyAndReturn({
     *   select: { clientId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyClientsUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyClientsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyClients.
     * @param {AgencyClientsUpsertArgs} args - Arguments to update or create a AgencyClients.
     * @example
     * // Update or create a AgencyClients
     * const agencyClients = await prisma.agencyClients.upsert({
     *   create: {
     *     // ... data to create a AgencyClients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyClients we want to update
     *   }
     * })
     */
    upsert<T extends AgencyClientsUpsertArgs>(args: SelectSubset<T, AgencyClientsUpsertArgs<ExtArgs>>): Prisma__AgencyClientsClient<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientsCountArgs} args - Arguments to filter AgencyClients to count.
     * @example
     * // Count the number of AgencyClients
     * const count = await prisma.agencyClients.count({
     *   where: {
     *     // ... the filter for the AgencyClients we want to count
     *   }
     * })
    **/
    count<T extends AgencyClientsCountArgs>(
      args?: Subset<T, AgencyClientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyClientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyClientsAggregateArgs>(args: Subset<T, AgencyClientsAggregateArgs>): Prisma.PrismaPromise<GetAgencyClientsAggregateType<T>>

    /**
     * Group by AgencyClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyClientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyClientsGroupByArgs['orderBy'] }
        : { orderBy?: AgencyClientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyClientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyClientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyClients model
   */
  readonly fields: AgencyClientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyClients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyClients model
   */
  interface AgencyClientsFieldRefs {
    readonly clientId: FieldRef<"AgencyClients", 'Int'>
    readonly agencyId: FieldRef<"AgencyClients", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AgencyClients findUnique
   */
  export type AgencyClientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClients to fetch.
     */
    where: AgencyClientsWhereUniqueInput
  }

  /**
   * AgencyClients findUniqueOrThrow
   */
  export type AgencyClientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClients to fetch.
     */
    where: AgencyClientsWhereUniqueInput
  }

  /**
   * AgencyClients findFirst
   */
  export type AgencyClientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClients to fetch.
     */
    where?: AgencyClientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClients to fetch.
     */
    orderBy?: AgencyClientsOrderByWithRelationInput | AgencyClientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyClients.
     */
    cursor?: AgencyClientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyClients.
     */
    distinct?: AgencyClientsScalarFieldEnum | AgencyClientsScalarFieldEnum[]
  }

  /**
   * AgencyClients findFirstOrThrow
   */
  export type AgencyClientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClients to fetch.
     */
    where?: AgencyClientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClients to fetch.
     */
    orderBy?: AgencyClientsOrderByWithRelationInput | AgencyClientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyClients.
     */
    cursor?: AgencyClientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyClients.
     */
    distinct?: AgencyClientsScalarFieldEnum | AgencyClientsScalarFieldEnum[]
  }

  /**
   * AgencyClients findMany
   */
  export type AgencyClientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClients to fetch.
     */
    where?: AgencyClientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClients to fetch.
     */
    orderBy?: AgencyClientsOrderByWithRelationInput | AgencyClientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyClients.
     */
    cursor?: AgencyClientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClients.
     */
    skip?: number
    distinct?: AgencyClientsScalarFieldEnum | AgencyClientsScalarFieldEnum[]
  }

  /**
   * AgencyClients create
   */
  export type AgencyClientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyClients.
     */
    data: XOR<AgencyClientsCreateInput, AgencyClientsUncheckedCreateInput>
  }

  /**
   * AgencyClients createMany
   */
  export type AgencyClientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyClients.
     */
    data: AgencyClientsCreateManyInput | AgencyClientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyClients createManyAndReturn
   */
  export type AgencyClientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyClients.
     */
    data: AgencyClientsCreateManyInput | AgencyClientsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyClients update
   */
  export type AgencyClientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyClients.
     */
    data: XOR<AgencyClientsUpdateInput, AgencyClientsUncheckedUpdateInput>
    /**
     * Choose, which AgencyClients to update.
     */
    where: AgencyClientsWhereUniqueInput
  }

  /**
   * AgencyClients updateMany
   */
  export type AgencyClientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyClients.
     */
    data: XOR<AgencyClientsUpdateManyMutationInput, AgencyClientsUncheckedUpdateManyInput>
    /**
     * Filter which AgencyClients to update
     */
    where?: AgencyClientsWhereInput
    /**
     * Limit how many AgencyClients to update.
     */
    limit?: number
  }

  /**
   * AgencyClients updateManyAndReturn
   */
  export type AgencyClientsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * The data used to update AgencyClients.
     */
    data: XOR<AgencyClientsUpdateManyMutationInput, AgencyClientsUncheckedUpdateManyInput>
    /**
     * Filter which AgencyClients to update
     */
    where?: AgencyClientsWhereInput
    /**
     * Limit how many AgencyClients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyClients upsert
   */
  export type AgencyClientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyClients to update in case it exists.
     */
    where: AgencyClientsWhereUniqueInput
    /**
     * In case the AgencyClients found by the `where` argument doesn't exist, create a new AgencyClients with this data.
     */
    create: XOR<AgencyClientsCreateInput, AgencyClientsUncheckedCreateInput>
    /**
     * In case the AgencyClients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyClientsUpdateInput, AgencyClientsUncheckedUpdateInput>
  }

  /**
   * AgencyClients delete
   */
  export type AgencyClientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    /**
     * Filter which AgencyClients to delete.
     */
    where: AgencyClientsWhereUniqueInput
  }

  /**
   * AgencyClients deleteMany
   */
  export type AgencyClientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyClients to delete
     */
    where?: AgencyClientsWhereInput
    /**
     * Limit how many AgencyClients to delete.
     */
    limit?: number
  }

  /**
   * AgencyClients without action
   */
  export type AgencyClientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
  }


  /**
   * Model AgencyStaff
   */

  export type AggregateAgencyStaff = {
    _count: AgencyStaffCountAggregateOutputType | null
    _avg: AgencyStaffAvgAggregateOutputType | null
    _sum: AgencyStaffSumAggregateOutputType | null
    _min: AgencyStaffMinAggregateOutputType | null
    _max: AgencyStaffMaxAggregateOutputType | null
  }

  export type AgencyStaffAvgAggregateOutputType = {
    id: number | null
    staffId: number | null
    agencyId: number | null
  }

  export type AgencyStaffSumAggregateOutputType = {
    id: number | null
    staffId: number | null
    agencyId: number | null
  }

  export type AgencyStaffMinAggregateOutputType = {
    id: number | null
    staffId: number | null
    agencyId: number | null
    staffRole: $Enums.Role | null
  }

  export type AgencyStaffMaxAggregateOutputType = {
    id: number | null
    staffId: number | null
    agencyId: number | null
    staffRole: $Enums.Role | null
  }

  export type AgencyStaffCountAggregateOutputType = {
    id: number
    staffId: number
    agencyId: number
    staffRole: number
    _all: number
  }


  export type AgencyStaffAvgAggregateInputType = {
    id?: true
    staffId?: true
    agencyId?: true
  }

  export type AgencyStaffSumAggregateInputType = {
    id?: true
    staffId?: true
    agencyId?: true
  }

  export type AgencyStaffMinAggregateInputType = {
    id?: true
    staffId?: true
    agencyId?: true
    staffRole?: true
  }

  export type AgencyStaffMaxAggregateInputType = {
    id?: true
    staffId?: true
    agencyId?: true
    staffRole?: true
  }

  export type AgencyStaffCountAggregateInputType = {
    id?: true
    staffId?: true
    agencyId?: true
    staffRole?: true
    _all?: true
  }

  export type AgencyStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyStaff to aggregate.
     */
    where?: AgencyStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyStaffs to fetch.
     */
    orderBy?: AgencyStaffOrderByWithRelationInput | AgencyStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyStaffs
    **/
    _count?: true | AgencyStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyStaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyStaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyStaffMaxAggregateInputType
  }

  export type GetAgencyStaffAggregateType<T extends AgencyStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyStaff[P]>
      : GetScalarType<T[P], AggregateAgencyStaff[P]>
  }




  export type AgencyStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyStaffWhereInput
    orderBy?: AgencyStaffOrderByWithAggregationInput | AgencyStaffOrderByWithAggregationInput[]
    by: AgencyStaffScalarFieldEnum[] | AgencyStaffScalarFieldEnum
    having?: AgencyStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyStaffCountAggregateInputType | true
    _avg?: AgencyStaffAvgAggregateInputType
    _sum?: AgencyStaffSumAggregateInputType
    _min?: AgencyStaffMinAggregateInputType
    _max?: AgencyStaffMaxAggregateInputType
  }

  export type AgencyStaffGroupByOutputType = {
    id: number
    staffId: number
    agencyId: number
    staffRole: $Enums.Role
    _count: AgencyStaffCountAggregateOutputType | null
    _avg: AgencyStaffAvgAggregateOutputType | null
    _sum: AgencyStaffSumAggregateOutputType | null
    _min: AgencyStaffMinAggregateOutputType | null
    _max: AgencyStaffMaxAggregateOutputType | null
  }

  type GetAgencyStaffGroupByPayload<T extends AgencyStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyStaffGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyStaffGroupByOutputType[P]>
        }
      >
    >


  export type AgencyStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    agencyId?: boolean
    staffRole?: boolean
    staff?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyStaff"]>

  export type AgencyStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    agencyId?: boolean
    staffRole?: boolean
    staff?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyStaff"]>

  export type AgencyStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    agencyId?: boolean
    staffRole?: boolean
    staff?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyStaff"]>

  export type AgencyStaffSelectScalar = {
    id?: boolean
    staffId?: boolean
    agencyId?: boolean
    staffRole?: boolean
  }

  export type AgencyStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "agencyId" | "staffRole", ExtArgs["result"]["agencyStaff"]>
  export type AgencyStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type AgencyStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type AgencyStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $AgencyStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyStaff"
    objects: {
      staff: Prisma.$UserPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      staffId: number
      agencyId: number
      staffRole: $Enums.Role
    }, ExtArgs["result"]["agencyStaff"]>
    composites: {}
  }

  type AgencyStaffGetPayload<S extends boolean | null | undefined | AgencyStaffDefaultArgs> = $Result.GetResult<Prisma.$AgencyStaffPayload, S>

  type AgencyStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyStaffCountAggregateInputType | true
    }

  export interface AgencyStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyStaff'], meta: { name: 'AgencyStaff' } }
    /**
     * Find zero or one AgencyStaff that matches the filter.
     * @param {AgencyStaffFindUniqueArgs} args - Arguments to find a AgencyStaff
     * @example
     * // Get one AgencyStaff
     * const agencyStaff = await prisma.agencyStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyStaffFindUniqueArgs>(args: SelectSubset<T, AgencyStaffFindUniqueArgs<ExtArgs>>): Prisma__AgencyStaffClient<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyStaffFindUniqueOrThrowArgs} args - Arguments to find a AgencyStaff
     * @example
     * // Get one AgencyStaff
     * const agencyStaff = await prisma.agencyStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyStaffClient<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyStaffFindFirstArgs} args - Arguments to find a AgencyStaff
     * @example
     * // Get one AgencyStaff
     * const agencyStaff = await prisma.agencyStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyStaffFindFirstArgs>(args?: SelectSubset<T, AgencyStaffFindFirstArgs<ExtArgs>>): Prisma__AgencyStaffClient<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyStaffFindFirstOrThrowArgs} args - Arguments to find a AgencyStaff
     * @example
     * // Get one AgencyStaff
     * const agencyStaff = await prisma.agencyStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyStaffClient<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyStaffs
     * const agencyStaffs = await prisma.agencyStaff.findMany()
     * 
     * // Get first 10 AgencyStaffs
     * const agencyStaffs = await prisma.agencyStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyStaffWithIdOnly = await prisma.agencyStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyStaffFindManyArgs>(args?: SelectSubset<T, AgencyStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyStaff.
     * @param {AgencyStaffCreateArgs} args - Arguments to create a AgencyStaff.
     * @example
     * // Create one AgencyStaff
     * const AgencyStaff = await prisma.agencyStaff.create({
     *   data: {
     *     // ... data to create a AgencyStaff
     *   }
     * })
     * 
     */
    create<T extends AgencyStaffCreateArgs>(args: SelectSubset<T, AgencyStaffCreateArgs<ExtArgs>>): Prisma__AgencyStaffClient<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyStaffs.
     * @param {AgencyStaffCreateManyArgs} args - Arguments to create many AgencyStaffs.
     * @example
     * // Create many AgencyStaffs
     * const agencyStaff = await prisma.agencyStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyStaffCreateManyArgs>(args?: SelectSubset<T, AgencyStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyStaffs and returns the data saved in the database.
     * @param {AgencyStaffCreateManyAndReturnArgs} args - Arguments to create many AgencyStaffs.
     * @example
     * // Create many AgencyStaffs
     * const agencyStaff = await prisma.agencyStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyStaffs and only return the `id`
     * const agencyStaffWithIdOnly = await prisma.agencyStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyStaff.
     * @param {AgencyStaffDeleteArgs} args - Arguments to delete one AgencyStaff.
     * @example
     * // Delete one AgencyStaff
     * const AgencyStaff = await prisma.agencyStaff.delete({
     *   where: {
     *     // ... filter to delete one AgencyStaff
     *   }
     * })
     * 
     */
    delete<T extends AgencyStaffDeleteArgs>(args: SelectSubset<T, AgencyStaffDeleteArgs<ExtArgs>>): Prisma__AgencyStaffClient<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyStaff.
     * @param {AgencyStaffUpdateArgs} args - Arguments to update one AgencyStaff.
     * @example
     * // Update one AgencyStaff
     * const agencyStaff = await prisma.agencyStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyStaffUpdateArgs>(args: SelectSubset<T, AgencyStaffUpdateArgs<ExtArgs>>): Prisma__AgencyStaffClient<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyStaffs.
     * @param {AgencyStaffDeleteManyArgs} args - Arguments to filter AgencyStaffs to delete.
     * @example
     * // Delete a few AgencyStaffs
     * const { count } = await prisma.agencyStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyStaffDeleteManyArgs>(args?: SelectSubset<T, AgencyStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyStaffs
     * const agencyStaff = await prisma.agencyStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyStaffUpdateManyArgs>(args: SelectSubset<T, AgencyStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyStaffs and returns the data updated in the database.
     * @param {AgencyStaffUpdateManyAndReturnArgs} args - Arguments to update many AgencyStaffs.
     * @example
     * // Update many AgencyStaffs
     * const agencyStaff = await prisma.agencyStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyStaffs and only return the `id`
     * const agencyStaffWithIdOnly = await prisma.agencyStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyStaff.
     * @param {AgencyStaffUpsertArgs} args - Arguments to update or create a AgencyStaff.
     * @example
     * // Update or create a AgencyStaff
     * const agencyStaff = await prisma.agencyStaff.upsert({
     *   create: {
     *     // ... data to create a AgencyStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyStaff we want to update
     *   }
     * })
     */
    upsert<T extends AgencyStaffUpsertArgs>(args: SelectSubset<T, AgencyStaffUpsertArgs<ExtArgs>>): Prisma__AgencyStaffClient<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyStaffCountArgs} args - Arguments to filter AgencyStaffs to count.
     * @example
     * // Count the number of AgencyStaffs
     * const count = await prisma.agencyStaff.count({
     *   where: {
     *     // ... the filter for the AgencyStaffs we want to count
     *   }
     * })
    **/
    count<T extends AgencyStaffCountArgs>(
      args?: Subset<T, AgencyStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyStaffAggregateArgs>(args: Subset<T, AgencyStaffAggregateArgs>): Prisma.PrismaPromise<GetAgencyStaffAggregateType<T>>

    /**
     * Group by AgencyStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyStaffGroupByArgs['orderBy'] }
        : { orderBy?: AgencyStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyStaff model
   */
  readonly fields: AgencyStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyStaff model
   */
  interface AgencyStaffFieldRefs {
    readonly id: FieldRef<"AgencyStaff", 'Int'>
    readonly staffId: FieldRef<"AgencyStaff", 'Int'>
    readonly agencyId: FieldRef<"AgencyStaff", 'Int'>
    readonly staffRole: FieldRef<"AgencyStaff", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * AgencyStaff findUnique
   */
  export type AgencyStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    /**
     * Filter, which AgencyStaff to fetch.
     */
    where: AgencyStaffWhereUniqueInput
  }

  /**
   * AgencyStaff findUniqueOrThrow
   */
  export type AgencyStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    /**
     * Filter, which AgencyStaff to fetch.
     */
    where: AgencyStaffWhereUniqueInput
  }

  /**
   * AgencyStaff findFirst
   */
  export type AgencyStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    /**
     * Filter, which AgencyStaff to fetch.
     */
    where?: AgencyStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyStaffs to fetch.
     */
    orderBy?: AgencyStaffOrderByWithRelationInput | AgencyStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyStaffs.
     */
    cursor?: AgencyStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyStaffs.
     */
    distinct?: AgencyStaffScalarFieldEnum | AgencyStaffScalarFieldEnum[]
  }

  /**
   * AgencyStaff findFirstOrThrow
   */
  export type AgencyStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    /**
     * Filter, which AgencyStaff to fetch.
     */
    where?: AgencyStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyStaffs to fetch.
     */
    orderBy?: AgencyStaffOrderByWithRelationInput | AgencyStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyStaffs.
     */
    cursor?: AgencyStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyStaffs.
     */
    distinct?: AgencyStaffScalarFieldEnum | AgencyStaffScalarFieldEnum[]
  }

  /**
   * AgencyStaff findMany
   */
  export type AgencyStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    /**
     * Filter, which AgencyStaffs to fetch.
     */
    where?: AgencyStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyStaffs to fetch.
     */
    orderBy?: AgencyStaffOrderByWithRelationInput | AgencyStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyStaffs.
     */
    cursor?: AgencyStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyStaffs.
     */
    skip?: number
    distinct?: AgencyStaffScalarFieldEnum | AgencyStaffScalarFieldEnum[]
  }

  /**
   * AgencyStaff create
   */
  export type AgencyStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyStaff.
     */
    data: XOR<AgencyStaffCreateInput, AgencyStaffUncheckedCreateInput>
  }

  /**
   * AgencyStaff createMany
   */
  export type AgencyStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyStaffs.
     */
    data: AgencyStaffCreateManyInput | AgencyStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyStaff createManyAndReturn
   */
  export type AgencyStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyStaffs.
     */
    data: AgencyStaffCreateManyInput | AgencyStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyStaff update
   */
  export type AgencyStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyStaff.
     */
    data: XOR<AgencyStaffUpdateInput, AgencyStaffUncheckedUpdateInput>
    /**
     * Choose, which AgencyStaff to update.
     */
    where: AgencyStaffWhereUniqueInput
  }

  /**
   * AgencyStaff updateMany
   */
  export type AgencyStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyStaffs.
     */
    data: XOR<AgencyStaffUpdateManyMutationInput, AgencyStaffUncheckedUpdateManyInput>
    /**
     * Filter which AgencyStaffs to update
     */
    where?: AgencyStaffWhereInput
    /**
     * Limit how many AgencyStaffs to update.
     */
    limit?: number
  }

  /**
   * AgencyStaff updateManyAndReturn
   */
  export type AgencyStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * The data used to update AgencyStaffs.
     */
    data: XOR<AgencyStaffUpdateManyMutationInput, AgencyStaffUncheckedUpdateManyInput>
    /**
     * Filter which AgencyStaffs to update
     */
    where?: AgencyStaffWhereInput
    /**
     * Limit how many AgencyStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyStaff upsert
   */
  export type AgencyStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyStaff to update in case it exists.
     */
    where: AgencyStaffWhereUniqueInput
    /**
     * In case the AgencyStaff found by the `where` argument doesn't exist, create a new AgencyStaff with this data.
     */
    create: XOR<AgencyStaffCreateInput, AgencyStaffUncheckedCreateInput>
    /**
     * In case the AgencyStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyStaffUpdateInput, AgencyStaffUncheckedUpdateInput>
  }

  /**
   * AgencyStaff delete
   */
  export type AgencyStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    /**
     * Filter which AgencyStaff to delete.
     */
    where: AgencyStaffWhereUniqueInput
  }

  /**
   * AgencyStaff deleteMany
   */
  export type AgencyStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyStaffs to delete
     */
    where?: AgencyStaffWhereInput
    /**
     * Limit how many AgencyStaffs to delete.
     */
    limit?: number
  }

  /**
   * AgencyStaff without action
   */
  export type AgencyStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    staffId: number | null
    agencyId: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    staffId: number | null
    agencyId: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    activityType: $Enums.ActivityType | null
    staffId: number | null
    agencyId: number | null
    details: string | null
    staffRole: $Enums.Role | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    activityType: $Enums.ActivityType | null
    staffId: number | null
    agencyId: number | null
    details: string | null
    staffRole: $Enums.Role | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    activityType: number
    staffId: number
    agencyId: number
    details: number
    staffRole: number
    createdAt: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    staffId?: true
    agencyId?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    staffId?: true
    agencyId?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    activityType?: true
    staffId?: true
    agencyId?: true
    details?: true
    staffRole?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    activityType?: true
    staffId?: true
    agencyId?: true
    details?: true
    staffRole?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    activityType?: true
    staffId?: true
    agencyId?: true
    details?: true
    staffRole?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: number
    activityType: $Enums.ActivityType
    staffId: number | null
    agencyId: number | null
    details: string | null
    staffRole: $Enums.Role
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityType?: boolean
    staffId?: boolean
    agencyId?: boolean
    details?: boolean
    staffRole?: boolean
    createdAt?: boolean
    staff?: boolean | ActivityLog$staffArgs<ExtArgs>
    agency?: boolean | ActivityLog$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityType?: boolean
    staffId?: boolean
    agencyId?: boolean
    details?: boolean
    staffRole?: boolean
    createdAt?: boolean
    staff?: boolean | ActivityLog$staffArgs<ExtArgs>
    agency?: boolean | ActivityLog$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityType?: boolean
    staffId?: boolean
    agencyId?: boolean
    details?: boolean
    staffRole?: boolean
    createdAt?: boolean
    staff?: boolean | ActivityLog$staffArgs<ExtArgs>
    agency?: boolean | ActivityLog$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    activityType?: boolean
    staffId?: boolean
    agencyId?: boolean
    details?: boolean
    staffRole?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "activityType" | "staffId" | "agencyId" | "details" | "staffRole" | "createdAt", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ActivityLog$staffArgs<ExtArgs>
    agency?: boolean | ActivityLog$agencyArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ActivityLog$staffArgs<ExtArgs>
    agency?: boolean | ActivityLog$agencyArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ActivityLog$staffArgs<ExtArgs>
    agency?: boolean | ActivityLog$agencyArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      staff: Prisma.$UserPayload<ExtArgs> | null
      agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      activityType: $Enums.ActivityType
      staffId: number | null
      agencyId: number | null
      details: string | null
      staffRole: $Enums.Role
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends ActivityLog$staffArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$staffArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agency<T extends ActivityLog$agencyArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'Int'>
    readonly activityType: FieldRef<"ActivityLog", 'ActivityType'>
    readonly staffId: FieldRef<"ActivityLog", 'Int'>
    readonly agencyId: FieldRef<"ActivityLog", 'Int'>
    readonly details: FieldRef<"ActivityLog", 'String'>
    readonly staffRole: FieldRef<"ActivityLog", 'Role'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog.staff
   */
  export type ActivityLog$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityLog.agency
   */
  export type ActivityLog$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model Authenticator
   */

  export type AggregateAuthenticator = {
    _count: AuthenticatorCountAggregateOutputType | null
    _avg: AuthenticatorAvgAggregateOutputType | null
    _sum: AuthenticatorSumAggregateOutputType | null
    _min: AuthenticatorMinAggregateOutputType | null
    _max: AuthenticatorMaxAggregateOutputType | null
  }

  export type AuthenticatorAvgAggregateOutputType = {
    userId: number | null
    counter: number | null
  }

  export type AuthenticatorSumAggregateOutputType = {
    userId: number | null
    counter: number | null
  }

  export type AuthenticatorMinAggregateOutputType = {
    credentialID: string | null
    userId: number | null
    providerAccountId: string | null
    credentialPublicKey: string | null
    counter: number | null
    credentialDeviceType: string | null
    credentialBackedUp: boolean | null
    transports: string | null
  }

  export type AuthenticatorMaxAggregateOutputType = {
    credentialID: string | null
    userId: number | null
    providerAccountId: string | null
    credentialPublicKey: string | null
    counter: number | null
    credentialDeviceType: string | null
    credentialBackedUp: boolean | null
    transports: string | null
  }

  export type AuthenticatorCountAggregateOutputType = {
    credentialID: number
    userId: number
    providerAccountId: number
    credentialPublicKey: number
    counter: number
    credentialDeviceType: number
    credentialBackedUp: number
    transports: number
    _all: number
  }


  export type AuthenticatorAvgAggregateInputType = {
    userId?: true
    counter?: true
  }

  export type AuthenticatorSumAggregateInputType = {
    userId?: true
    counter?: true
  }

  export type AuthenticatorMinAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
  }

  export type AuthenticatorMaxAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
  }

  export type AuthenticatorCountAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
    _all?: true
  }

  export type AuthenticatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authenticator to aggregate.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authenticators
    **/
    _count?: true | AuthenticatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthenticatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthenticatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthenticatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthenticatorMaxAggregateInputType
  }

  export type GetAuthenticatorAggregateType<T extends AuthenticatorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthenticator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthenticator[P]>
      : GetScalarType<T[P], AggregateAuthenticator[P]>
  }




  export type AuthenticatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthenticatorWhereInput
    orderBy?: AuthenticatorOrderByWithAggregationInput | AuthenticatorOrderByWithAggregationInput[]
    by: AuthenticatorScalarFieldEnum[] | AuthenticatorScalarFieldEnum
    having?: AuthenticatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthenticatorCountAggregateInputType | true
    _avg?: AuthenticatorAvgAggregateInputType
    _sum?: AuthenticatorSumAggregateInputType
    _min?: AuthenticatorMinAggregateInputType
    _max?: AuthenticatorMaxAggregateInputType
  }

  export type AuthenticatorGroupByOutputType = {
    credentialID: string
    userId: number
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports: string | null
    _count: AuthenticatorCountAggregateOutputType | null
    _avg: AuthenticatorAvgAggregateOutputType | null
    _sum: AuthenticatorSumAggregateOutputType | null
    _min: AuthenticatorMinAggregateOutputType | null
    _max: AuthenticatorMaxAggregateOutputType | null
  }

  type GetAuthenticatorGroupByPayload<T extends AuthenticatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthenticatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthenticatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthenticatorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthenticatorGroupByOutputType[P]>
        }
      >
    >


  export type AuthenticatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authenticator"]>

  export type AuthenticatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authenticator"]>

  export type AuthenticatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authenticator"]>

  export type AuthenticatorSelectScalar = {
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
  }

  export type AuthenticatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"credentialID" | "userId" | "providerAccountId" | "credentialPublicKey" | "counter" | "credentialDeviceType" | "credentialBackedUp" | "transports", ExtArgs["result"]["authenticator"]>
  export type AuthenticatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthenticatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthenticatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthenticatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Authenticator"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      credentialID: string
      userId: number
      providerAccountId: string
      credentialPublicKey: string
      counter: number
      credentialDeviceType: string
      credentialBackedUp: boolean
      transports: string | null
    }, ExtArgs["result"]["authenticator"]>
    composites: {}
  }

  type AuthenticatorGetPayload<S extends boolean | null | undefined | AuthenticatorDefaultArgs> = $Result.GetResult<Prisma.$AuthenticatorPayload, S>

  type AuthenticatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthenticatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthenticatorCountAggregateInputType | true
    }

  export interface AuthenticatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Authenticator'], meta: { name: 'Authenticator' } }
    /**
     * Find zero or one Authenticator that matches the filter.
     * @param {AuthenticatorFindUniqueArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthenticatorFindUniqueArgs>(args: SelectSubset<T, AuthenticatorFindUniqueArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Authenticator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthenticatorFindUniqueOrThrowArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthenticatorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthenticatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authenticator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindFirstArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthenticatorFindFirstArgs>(args?: SelectSubset<T, AuthenticatorFindFirstArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authenticator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindFirstOrThrowArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthenticatorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthenticatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authenticators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authenticators
     * const authenticators = await prisma.authenticator.findMany()
     * 
     * // Get first 10 Authenticators
     * const authenticators = await prisma.authenticator.findMany({ take: 10 })
     * 
     * // Only select the `credentialID`
     * const authenticatorWithCredentialIDOnly = await prisma.authenticator.findMany({ select: { credentialID: true } })
     * 
     */
    findMany<T extends AuthenticatorFindManyArgs>(args?: SelectSubset<T, AuthenticatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Authenticator.
     * @param {AuthenticatorCreateArgs} args - Arguments to create a Authenticator.
     * @example
     * // Create one Authenticator
     * const Authenticator = await prisma.authenticator.create({
     *   data: {
     *     // ... data to create a Authenticator
     *   }
     * })
     * 
     */
    create<T extends AuthenticatorCreateArgs>(args: SelectSubset<T, AuthenticatorCreateArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authenticators.
     * @param {AuthenticatorCreateManyArgs} args - Arguments to create many Authenticators.
     * @example
     * // Create many Authenticators
     * const authenticator = await prisma.authenticator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthenticatorCreateManyArgs>(args?: SelectSubset<T, AuthenticatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authenticators and returns the data saved in the database.
     * @param {AuthenticatorCreateManyAndReturnArgs} args - Arguments to create many Authenticators.
     * @example
     * // Create many Authenticators
     * const authenticator = await prisma.authenticator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authenticators and only return the `credentialID`
     * const authenticatorWithCredentialIDOnly = await prisma.authenticator.createManyAndReturn({
     *   select: { credentialID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthenticatorCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthenticatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Authenticator.
     * @param {AuthenticatorDeleteArgs} args - Arguments to delete one Authenticator.
     * @example
     * // Delete one Authenticator
     * const Authenticator = await prisma.authenticator.delete({
     *   where: {
     *     // ... filter to delete one Authenticator
     *   }
     * })
     * 
     */
    delete<T extends AuthenticatorDeleteArgs>(args: SelectSubset<T, AuthenticatorDeleteArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Authenticator.
     * @param {AuthenticatorUpdateArgs} args - Arguments to update one Authenticator.
     * @example
     * // Update one Authenticator
     * const authenticator = await prisma.authenticator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthenticatorUpdateArgs>(args: SelectSubset<T, AuthenticatorUpdateArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authenticators.
     * @param {AuthenticatorDeleteManyArgs} args - Arguments to filter Authenticators to delete.
     * @example
     * // Delete a few Authenticators
     * const { count } = await prisma.authenticator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthenticatorDeleteManyArgs>(args?: SelectSubset<T, AuthenticatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authenticators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authenticators
     * const authenticator = await prisma.authenticator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthenticatorUpdateManyArgs>(args: SelectSubset<T, AuthenticatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authenticators and returns the data updated in the database.
     * @param {AuthenticatorUpdateManyAndReturnArgs} args - Arguments to update many Authenticators.
     * @example
     * // Update many Authenticators
     * const authenticator = await prisma.authenticator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authenticators and only return the `credentialID`
     * const authenticatorWithCredentialIDOnly = await prisma.authenticator.updateManyAndReturn({
     *   select: { credentialID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthenticatorUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthenticatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Authenticator.
     * @param {AuthenticatorUpsertArgs} args - Arguments to update or create a Authenticator.
     * @example
     * // Update or create a Authenticator
     * const authenticator = await prisma.authenticator.upsert({
     *   create: {
     *     // ... data to create a Authenticator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authenticator we want to update
     *   }
     * })
     */
    upsert<T extends AuthenticatorUpsertArgs>(args: SelectSubset<T, AuthenticatorUpsertArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authenticators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorCountArgs} args - Arguments to filter Authenticators to count.
     * @example
     * // Count the number of Authenticators
     * const count = await prisma.authenticator.count({
     *   where: {
     *     // ... the filter for the Authenticators we want to count
     *   }
     * })
    **/
    count<T extends AuthenticatorCountArgs>(
      args?: Subset<T, AuthenticatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthenticatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authenticator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthenticatorAggregateArgs>(args: Subset<T, AuthenticatorAggregateArgs>): Prisma.PrismaPromise<GetAuthenticatorAggregateType<T>>

    /**
     * Group by Authenticator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthenticatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthenticatorGroupByArgs['orderBy'] }
        : { orderBy?: AuthenticatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthenticatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthenticatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Authenticator model
   */
  readonly fields: AuthenticatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Authenticator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthenticatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Authenticator model
   */
  interface AuthenticatorFieldRefs {
    readonly credentialID: FieldRef<"Authenticator", 'String'>
    readonly userId: FieldRef<"Authenticator", 'Int'>
    readonly providerAccountId: FieldRef<"Authenticator", 'String'>
    readonly credentialPublicKey: FieldRef<"Authenticator", 'String'>
    readonly counter: FieldRef<"Authenticator", 'Int'>
    readonly credentialDeviceType: FieldRef<"Authenticator", 'String'>
    readonly credentialBackedUp: FieldRef<"Authenticator", 'Boolean'>
    readonly transports: FieldRef<"Authenticator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Authenticator findUnique
   */
  export type AuthenticatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator findUniqueOrThrow
   */
  export type AuthenticatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator findFirst
   */
  export type AuthenticatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authenticators.
     */
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator findFirstOrThrow
   */
  export type AuthenticatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authenticators.
     */
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator findMany
   */
  export type AuthenticatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticators to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator create
   */
  export type AuthenticatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Authenticator.
     */
    data: XOR<AuthenticatorCreateInput, AuthenticatorUncheckedCreateInput>
  }

  /**
   * Authenticator createMany
   */
  export type AuthenticatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authenticators.
     */
    data: AuthenticatorCreateManyInput | AuthenticatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Authenticator createManyAndReturn
   */
  export type AuthenticatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * The data used to create many Authenticators.
     */
    data: AuthenticatorCreateManyInput | AuthenticatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Authenticator update
   */
  export type AuthenticatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Authenticator.
     */
    data: XOR<AuthenticatorUpdateInput, AuthenticatorUncheckedUpdateInput>
    /**
     * Choose, which Authenticator to update.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator updateMany
   */
  export type AuthenticatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authenticators.
     */
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyInput>
    /**
     * Filter which Authenticators to update
     */
    where?: AuthenticatorWhereInput
    /**
     * Limit how many Authenticators to update.
     */
    limit?: number
  }

  /**
   * Authenticator updateManyAndReturn
   */
  export type AuthenticatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * The data used to update Authenticators.
     */
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyInput>
    /**
     * Filter which Authenticators to update
     */
    where?: AuthenticatorWhereInput
    /**
     * Limit how many Authenticators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Authenticator upsert
   */
  export type AuthenticatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Authenticator to update in case it exists.
     */
    where: AuthenticatorWhereUniqueInput
    /**
     * In case the Authenticator found by the `where` argument doesn't exist, create a new Authenticator with this data.
     */
    create: XOR<AuthenticatorCreateInput, AuthenticatorUncheckedCreateInput>
    /**
     * In case the Authenticator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthenticatorUpdateInput, AuthenticatorUncheckedUpdateInput>
  }

  /**
   * Authenticator delete
   */
  export type AuthenticatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter which Authenticator to delete.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator deleteMany
   */
  export type AuthenticatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authenticators to delete
     */
    where?: AuthenticatorWhereInput
    /**
     * Limit how many Authenticators to delete.
     */
    limit?: number
  }

  /**
   * Authenticator without action
   */
  export type AuthenticatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    agencyId: number | null
    destinataireId: number | null
    clientId: number | null
    envoiId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    agencyId: number | null
    destinataireId: number | null
    clientId: number | null
    envoiId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    message: string | null
    agencyId: number | null
    destinataireId: number | null
    clientId: number | null
    envoiId: number | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    message: string | null
    agencyId: number | null
    destinataireId: number | null
    clientId: number | null
    envoiId: number | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    message: number
    agencyId: number
    destinataireId: number
    clientId: number
    envoiId: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    agencyId?: true
    destinataireId?: true
    clientId?: true
    envoiId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    agencyId?: true
    destinataireId?: true
    clientId?: true
    envoiId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    message?: true
    agencyId?: true
    destinataireId?: true
    clientId?: true
    envoiId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    message?: true
    agencyId?: true
    destinataireId?: true
    clientId?: true
    envoiId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    message?: true
    agencyId?: true
    destinataireId?: true
    clientId?: true
    envoiId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    message: string
    agencyId: number
    destinataireId: number | null
    clientId: number | null
    envoiId: number
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    agencyId?: boolean
    destinataireId?: boolean
    clientId?: boolean
    envoiId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    destinataireNotification?: boolean | Notification$destinataireNotificationArgs<ExtArgs>
    clientNotification?: boolean | Notification$clientNotificationArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    agencyId?: boolean
    destinataireId?: boolean
    clientId?: boolean
    envoiId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    destinataireNotification?: boolean | Notification$destinataireNotificationArgs<ExtArgs>
    clientNotification?: boolean | Notification$clientNotificationArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    agencyId?: boolean
    destinataireId?: boolean
    clientId?: boolean
    envoiId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    destinataireNotification?: boolean | Notification$destinataireNotificationArgs<ExtArgs>
    clientNotification?: boolean | Notification$clientNotificationArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    message?: boolean
    agencyId?: boolean
    destinataireId?: boolean
    clientId?: boolean
    envoiId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "agencyId" | "destinataireId" | "clientId" | "envoiId" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    destinataireNotification?: boolean | Notification$destinataireNotificationArgs<ExtArgs>
    clientNotification?: boolean | Notification$clientNotificationArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    destinataireNotification?: boolean | Notification$destinataireNotificationArgs<ExtArgs>
    clientNotification?: boolean | Notification$clientNotificationArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    destinataireNotification?: boolean | Notification$destinataireNotificationArgs<ExtArgs>
    clientNotification?: boolean | Notification$clientNotificationArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      envoi: Prisma.$EnvoiPayload<ExtArgs>
      destinataireNotification: Prisma.$UserPayload<ExtArgs> | null
      clientNotification: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      message: string
      agencyId: number
      destinataireId: number | null
      clientId: number | null
      envoiId: number
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    envoi<T extends EnvoiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvoiDefaultArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    destinataireNotification<T extends Notification$destinataireNotificationArgs<ExtArgs> = {}>(args?: Subset<T, Notification$destinataireNotificationArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientNotification<T extends Notification$clientNotificationArgs<ExtArgs> = {}>(args?: Subset<T, Notification$clientNotificationArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly agencyId: FieldRef<"Notification", 'Int'>
    readonly destinataireId: FieldRef<"Notification", 'Int'>
    readonly clientId: FieldRef<"Notification", 'Int'>
    readonly envoiId: FieldRef<"Notification", 'Int'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.destinataireNotification
   */
  export type Notification$destinataireNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification.clientNotification
   */
  export type Notification$clientNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model VatRate
   */

  export type AggregateVatRate = {
    _count: VatRateCountAggregateOutputType | null
    _avg: VatRateAvgAggregateOutputType | null
    _sum: VatRateSumAggregateOutputType | null
    _min: VatRateMinAggregateOutputType | null
    _max: VatRateMaxAggregateOutputType | null
  }

  export type VatRateAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
    itemClassId: number | null
    vatPercent: Decimal | null
  }

  export type VatRateSumAggregateOutputType = {
    id: number | null
    countryId: number | null
    itemClassId: number | null
    vatPercent: Decimal | null
  }

  export type VatRateMinAggregateOutputType = {
    id: number | null
    countryId: number | null
    itemClassId: number | null
    vatPercent: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    vatType: $Enums.VatType | null
  }

  export type VatRateMaxAggregateOutputType = {
    id: number | null
    countryId: number | null
    itemClassId: number | null
    vatPercent: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    vatType: $Enums.VatType | null
  }

  export type VatRateCountAggregateOutputType = {
    id: number
    countryId: number
    itemClassId: number
    vatPercent: number
    createdAt: number
    updatedAt: number
    vatType: number
    _all: number
  }


  export type VatRateAvgAggregateInputType = {
    id?: true
    countryId?: true
    itemClassId?: true
    vatPercent?: true
  }

  export type VatRateSumAggregateInputType = {
    id?: true
    countryId?: true
    itemClassId?: true
    vatPercent?: true
  }

  export type VatRateMinAggregateInputType = {
    id?: true
    countryId?: true
    itemClassId?: true
    vatPercent?: true
    createdAt?: true
    updatedAt?: true
    vatType?: true
  }

  export type VatRateMaxAggregateInputType = {
    id?: true
    countryId?: true
    itemClassId?: true
    vatPercent?: true
    createdAt?: true
    updatedAt?: true
    vatType?: true
  }

  export type VatRateCountAggregateInputType = {
    id?: true
    countryId?: true
    itemClassId?: true
    vatPercent?: true
    createdAt?: true
    updatedAt?: true
    vatType?: true
    _all?: true
  }

  export type VatRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VatRate to aggregate.
     */
    where?: VatRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VatRates to fetch.
     */
    orderBy?: VatRateOrderByWithRelationInput | VatRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VatRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VatRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VatRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VatRates
    **/
    _count?: true | VatRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VatRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VatRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VatRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VatRateMaxAggregateInputType
  }

  export type GetVatRateAggregateType<T extends VatRateAggregateArgs> = {
        [P in keyof T & keyof AggregateVatRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVatRate[P]>
      : GetScalarType<T[P], AggregateVatRate[P]>
  }




  export type VatRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VatRateWhereInput
    orderBy?: VatRateOrderByWithAggregationInput | VatRateOrderByWithAggregationInput[]
    by: VatRateScalarFieldEnum[] | VatRateScalarFieldEnum
    having?: VatRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VatRateCountAggregateInputType | true
    _avg?: VatRateAvgAggregateInputType
    _sum?: VatRateSumAggregateInputType
    _min?: VatRateMinAggregateInputType
    _max?: VatRateMaxAggregateInputType
  }

  export type VatRateGroupByOutputType = {
    id: number
    countryId: number
    itemClassId: number
    vatPercent: Decimal
    createdAt: Date
    updatedAt: Date
    vatType: $Enums.VatType | null
    _count: VatRateCountAggregateOutputType | null
    _avg: VatRateAvgAggregateOutputType | null
    _sum: VatRateSumAggregateOutputType | null
    _min: VatRateMinAggregateOutputType | null
    _max: VatRateMaxAggregateOutputType | null
  }

  type GetVatRateGroupByPayload<T extends VatRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VatRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VatRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VatRateGroupByOutputType[P]>
            : GetScalarType<T[P], VatRateGroupByOutputType[P]>
        }
      >
    >


  export type VatRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryId?: boolean
    itemClassId?: boolean
    vatPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vatType?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vatRate"]>

  export type VatRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryId?: boolean
    itemClassId?: boolean
    vatPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vatType?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vatRate"]>

  export type VatRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryId?: boolean
    itemClassId?: boolean
    vatPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vatType?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vatRate"]>

  export type VatRateSelectScalar = {
    id?: boolean
    countryId?: boolean
    itemClassId?: boolean
    vatPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vatType?: boolean
  }

  export type VatRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countryId" | "itemClassId" | "vatPercent" | "createdAt" | "updatedAt" | "vatType", ExtArgs["result"]["vatRate"]>
  export type VatRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type VatRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type VatRateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $VatRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VatRate"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      countryId: number
      itemClassId: number
      vatPercent: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      vatType: $Enums.VatType | null
    }, ExtArgs["result"]["vatRate"]>
    composites: {}
  }

  type VatRateGetPayload<S extends boolean | null | undefined | VatRateDefaultArgs> = $Result.GetResult<Prisma.$VatRatePayload, S>

  type VatRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VatRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VatRateCountAggregateInputType | true
    }

  export interface VatRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VatRate'], meta: { name: 'VatRate' } }
    /**
     * Find zero or one VatRate that matches the filter.
     * @param {VatRateFindUniqueArgs} args - Arguments to find a VatRate
     * @example
     * // Get one VatRate
     * const vatRate = await prisma.vatRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VatRateFindUniqueArgs>(args: SelectSubset<T, VatRateFindUniqueArgs<ExtArgs>>): Prisma__VatRateClient<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VatRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VatRateFindUniqueOrThrowArgs} args - Arguments to find a VatRate
     * @example
     * // Get one VatRate
     * const vatRate = await prisma.vatRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VatRateFindUniqueOrThrowArgs>(args: SelectSubset<T, VatRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VatRateClient<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VatRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VatRateFindFirstArgs} args - Arguments to find a VatRate
     * @example
     * // Get one VatRate
     * const vatRate = await prisma.vatRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VatRateFindFirstArgs>(args?: SelectSubset<T, VatRateFindFirstArgs<ExtArgs>>): Prisma__VatRateClient<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VatRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VatRateFindFirstOrThrowArgs} args - Arguments to find a VatRate
     * @example
     * // Get one VatRate
     * const vatRate = await prisma.vatRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VatRateFindFirstOrThrowArgs>(args?: SelectSubset<T, VatRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__VatRateClient<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VatRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VatRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VatRates
     * const vatRates = await prisma.vatRate.findMany()
     * 
     * // Get first 10 VatRates
     * const vatRates = await prisma.vatRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vatRateWithIdOnly = await prisma.vatRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VatRateFindManyArgs>(args?: SelectSubset<T, VatRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VatRate.
     * @param {VatRateCreateArgs} args - Arguments to create a VatRate.
     * @example
     * // Create one VatRate
     * const VatRate = await prisma.vatRate.create({
     *   data: {
     *     // ... data to create a VatRate
     *   }
     * })
     * 
     */
    create<T extends VatRateCreateArgs>(args: SelectSubset<T, VatRateCreateArgs<ExtArgs>>): Prisma__VatRateClient<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VatRates.
     * @param {VatRateCreateManyArgs} args - Arguments to create many VatRates.
     * @example
     * // Create many VatRates
     * const vatRate = await prisma.vatRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VatRateCreateManyArgs>(args?: SelectSubset<T, VatRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VatRates and returns the data saved in the database.
     * @param {VatRateCreateManyAndReturnArgs} args - Arguments to create many VatRates.
     * @example
     * // Create many VatRates
     * const vatRate = await prisma.vatRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VatRates and only return the `id`
     * const vatRateWithIdOnly = await prisma.vatRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VatRateCreateManyAndReturnArgs>(args?: SelectSubset<T, VatRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VatRate.
     * @param {VatRateDeleteArgs} args - Arguments to delete one VatRate.
     * @example
     * // Delete one VatRate
     * const VatRate = await prisma.vatRate.delete({
     *   where: {
     *     // ... filter to delete one VatRate
     *   }
     * })
     * 
     */
    delete<T extends VatRateDeleteArgs>(args: SelectSubset<T, VatRateDeleteArgs<ExtArgs>>): Prisma__VatRateClient<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VatRate.
     * @param {VatRateUpdateArgs} args - Arguments to update one VatRate.
     * @example
     * // Update one VatRate
     * const vatRate = await prisma.vatRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VatRateUpdateArgs>(args: SelectSubset<T, VatRateUpdateArgs<ExtArgs>>): Prisma__VatRateClient<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VatRates.
     * @param {VatRateDeleteManyArgs} args - Arguments to filter VatRates to delete.
     * @example
     * // Delete a few VatRates
     * const { count } = await prisma.vatRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VatRateDeleteManyArgs>(args?: SelectSubset<T, VatRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VatRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VatRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VatRates
     * const vatRate = await prisma.vatRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VatRateUpdateManyArgs>(args: SelectSubset<T, VatRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VatRates and returns the data updated in the database.
     * @param {VatRateUpdateManyAndReturnArgs} args - Arguments to update many VatRates.
     * @example
     * // Update many VatRates
     * const vatRate = await prisma.vatRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VatRates and only return the `id`
     * const vatRateWithIdOnly = await prisma.vatRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VatRateUpdateManyAndReturnArgs>(args: SelectSubset<T, VatRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VatRate.
     * @param {VatRateUpsertArgs} args - Arguments to update or create a VatRate.
     * @example
     * // Update or create a VatRate
     * const vatRate = await prisma.vatRate.upsert({
     *   create: {
     *     // ... data to create a VatRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VatRate we want to update
     *   }
     * })
     */
    upsert<T extends VatRateUpsertArgs>(args: SelectSubset<T, VatRateUpsertArgs<ExtArgs>>): Prisma__VatRateClient<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VatRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VatRateCountArgs} args - Arguments to filter VatRates to count.
     * @example
     * // Count the number of VatRates
     * const count = await prisma.vatRate.count({
     *   where: {
     *     // ... the filter for the VatRates we want to count
     *   }
     * })
    **/
    count<T extends VatRateCountArgs>(
      args?: Subset<T, VatRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VatRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VatRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VatRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VatRateAggregateArgs>(args: Subset<T, VatRateAggregateArgs>): Prisma.PrismaPromise<GetVatRateAggregateType<T>>

    /**
     * Group by VatRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VatRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VatRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VatRateGroupByArgs['orderBy'] }
        : { orderBy?: VatRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VatRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVatRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VatRate model
   */
  readonly fields: VatRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VatRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VatRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VatRate model
   */
  interface VatRateFieldRefs {
    readonly id: FieldRef<"VatRate", 'Int'>
    readonly countryId: FieldRef<"VatRate", 'Int'>
    readonly itemClassId: FieldRef<"VatRate", 'Int'>
    readonly vatPercent: FieldRef<"VatRate", 'Decimal'>
    readonly createdAt: FieldRef<"VatRate", 'DateTime'>
    readonly updatedAt: FieldRef<"VatRate", 'DateTime'>
    readonly vatType: FieldRef<"VatRate", 'VatType'>
  }
    

  // Custom InputTypes
  /**
   * VatRate findUnique
   */
  export type VatRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    /**
     * Filter, which VatRate to fetch.
     */
    where: VatRateWhereUniqueInput
  }

  /**
   * VatRate findUniqueOrThrow
   */
  export type VatRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    /**
     * Filter, which VatRate to fetch.
     */
    where: VatRateWhereUniqueInput
  }

  /**
   * VatRate findFirst
   */
  export type VatRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    /**
     * Filter, which VatRate to fetch.
     */
    where?: VatRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VatRates to fetch.
     */
    orderBy?: VatRateOrderByWithRelationInput | VatRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VatRates.
     */
    cursor?: VatRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VatRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VatRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VatRates.
     */
    distinct?: VatRateScalarFieldEnum | VatRateScalarFieldEnum[]
  }

  /**
   * VatRate findFirstOrThrow
   */
  export type VatRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    /**
     * Filter, which VatRate to fetch.
     */
    where?: VatRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VatRates to fetch.
     */
    orderBy?: VatRateOrderByWithRelationInput | VatRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VatRates.
     */
    cursor?: VatRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VatRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VatRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VatRates.
     */
    distinct?: VatRateScalarFieldEnum | VatRateScalarFieldEnum[]
  }

  /**
   * VatRate findMany
   */
  export type VatRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    /**
     * Filter, which VatRates to fetch.
     */
    where?: VatRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VatRates to fetch.
     */
    orderBy?: VatRateOrderByWithRelationInput | VatRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VatRates.
     */
    cursor?: VatRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VatRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VatRates.
     */
    skip?: number
    distinct?: VatRateScalarFieldEnum | VatRateScalarFieldEnum[]
  }

  /**
   * VatRate create
   */
  export type VatRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    /**
     * The data needed to create a VatRate.
     */
    data: XOR<VatRateCreateInput, VatRateUncheckedCreateInput>
  }

  /**
   * VatRate createMany
   */
  export type VatRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VatRates.
     */
    data: VatRateCreateManyInput | VatRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VatRate createManyAndReturn
   */
  export type VatRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * The data used to create many VatRates.
     */
    data: VatRateCreateManyInput | VatRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VatRate update
   */
  export type VatRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    /**
     * The data needed to update a VatRate.
     */
    data: XOR<VatRateUpdateInput, VatRateUncheckedUpdateInput>
    /**
     * Choose, which VatRate to update.
     */
    where: VatRateWhereUniqueInput
  }

  /**
   * VatRate updateMany
   */
  export type VatRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VatRates.
     */
    data: XOR<VatRateUpdateManyMutationInput, VatRateUncheckedUpdateManyInput>
    /**
     * Filter which VatRates to update
     */
    where?: VatRateWhereInput
    /**
     * Limit how many VatRates to update.
     */
    limit?: number
  }

  /**
   * VatRate updateManyAndReturn
   */
  export type VatRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * The data used to update VatRates.
     */
    data: XOR<VatRateUpdateManyMutationInput, VatRateUncheckedUpdateManyInput>
    /**
     * Filter which VatRates to update
     */
    where?: VatRateWhereInput
    /**
     * Limit how many VatRates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VatRate upsert
   */
  export type VatRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    /**
     * The filter to search for the VatRate to update in case it exists.
     */
    where: VatRateWhereUniqueInput
    /**
     * In case the VatRate found by the `where` argument doesn't exist, create a new VatRate with this data.
     */
    create: XOR<VatRateCreateInput, VatRateUncheckedCreateInput>
    /**
     * In case the VatRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VatRateUpdateInput, VatRateUncheckedUpdateInput>
  }

  /**
   * VatRate delete
   */
  export type VatRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    /**
     * Filter which VatRate to delete.
     */
    where: VatRateWhereUniqueInput
  }

  /**
   * VatRate deleteMany
   */
  export type VatRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VatRates to delete
     */
    where?: VatRateWhereInput
    /**
     * Limit how many VatRates to delete.
     */
    limit?: number
  }

  /**
   * VatRate without action
   */
  export type VatRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    name: string | null
    latitude: string | null
    longitude: string | null
    countryId: number | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    latitude: string | null
    longitude: string | null
    countryId: number | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    latitude: number
    longitude: number
    countryId: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    countryId?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    countryId?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    countryId?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: number
    name: string
    latitude: string | null
    longitude: string | null
    countryId: number
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    addresses?: boolean | City$addressesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    countryId?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "latitude" | "longitude" | "countryId", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    addresses?: boolean | City$addressesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      addresses: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      latitude: string | null
      longitude: string | null
      countryId: number
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addresses<T extends City$addressesArgs<ExtArgs> = {}>(args?: Subset<T, City$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'Int'>
    readonly name: FieldRef<"City", 'String'>
    readonly latitude: FieldRef<"City", 'String'>
    readonly longitude: FieldRef<"City", 'String'>
    readonly countryId: FieldRef<"City", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.addresses
   */
  export type City$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    name: string | null
    iso2: string | null
    iso3: string | null
    phonecode: string | null
    capital: string | null
    currency: string | null
    latitude: string | null
    longitude: string | null
    emoji: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    iso2: string | null
    iso3: string | null
    phonecode: string | null
    capital: string | null
    currency: string | null
    latitude: string | null
    longitude: string | null
    emoji: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    iso2: number
    iso3: number
    phonecode: number
    capital: number
    currency: number
    latitude: number
    longitude: number
    emoji: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    iso2?: true
    iso3?: true
    phonecode?: true
    capital?: true
    currency?: true
    latitude?: true
    longitude?: true
    emoji?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    iso2?: true
    iso3?: true
    phonecode?: true
    capital?: true
    currency?: true
    latitude?: true
    longitude?: true
    emoji?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    iso2?: true
    iso3?: true
    phonecode?: true
    capital?: true
    currency?: true
    latitude?: true
    longitude?: true
    emoji?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: number
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital: string | null
    currency: string | null
    latitude: string | null
    longitude: string | null
    emoji: string | null
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iso2?: boolean
    iso3?: boolean
    phonecode?: boolean
    capital?: boolean
    currency?: boolean
    latitude?: boolean
    longitude?: boolean
    emoji?: boolean
    cities?: boolean | Country$citiesArgs<ExtArgs>
    timezones?: boolean | Country$timezonesArgs<ExtArgs>
    vatRates?: boolean | Country$vatRatesArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iso2?: boolean
    iso3?: boolean
    phonecode?: boolean
    capital?: boolean
    currency?: boolean
    latitude?: boolean
    longitude?: boolean
    emoji?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iso2?: boolean
    iso3?: boolean
    phonecode?: boolean
    capital?: boolean
    currency?: boolean
    latitude?: boolean
    longitude?: boolean
    emoji?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    iso2?: boolean
    iso3?: boolean
    phonecode?: boolean
    capital?: boolean
    currency?: boolean
    latitude?: boolean
    longitude?: boolean
    emoji?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "iso2" | "iso3" | "phonecode" | "capital" | "currency" | "latitude" | "longitude" | "emoji", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | Country$citiesArgs<ExtArgs>
    timezones?: boolean | Country$timezonesArgs<ExtArgs>
    vatRates?: boolean | Country$vatRatesArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      cities: Prisma.$CityPayload<ExtArgs>[]
      timezones: Prisma.$TimezonePayload<ExtArgs>[]
      vatRates: Prisma.$VatRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      iso2: string
      iso3: string
      phonecode: string
      capital: string | null
      currency: string | null
      latitude: string | null
      longitude: string | null
      emoji: string | null
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends Country$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Country$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timezones<T extends Country$timezonesArgs<ExtArgs> = {}>(args?: Subset<T, Country$timezonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vatRates<T extends Country$vatRatesArgs<ExtArgs> = {}>(args?: Subset<T, Country$vatRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VatRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'Int'>
    readonly name: FieldRef<"Country", 'String'>
    readonly iso2: FieldRef<"Country", 'String'>
    readonly iso3: FieldRef<"Country", 'String'>
    readonly phonecode: FieldRef<"Country", 'String'>
    readonly capital: FieldRef<"Country", 'String'>
    readonly currency: FieldRef<"Country", 'String'>
    readonly latitude: FieldRef<"Country", 'String'>
    readonly longitude: FieldRef<"Country", 'String'>
    readonly emoji: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.cities
   */
  export type Country$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Country.timezones
   */
  export type Country$timezonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    where?: TimezoneWhereInput
    orderBy?: TimezoneOrderByWithRelationInput | TimezoneOrderByWithRelationInput[]
    cursor?: TimezoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimezoneScalarFieldEnum | TimezoneScalarFieldEnum[]
  }

  /**
   * Country.vatRates
   */
  export type Country$vatRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VatRate
     */
    select?: VatRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VatRate
     */
    omit?: VatRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VatRateInclude<ExtArgs> | null
    where?: VatRateWhereInput
    orderBy?: VatRateOrderByWithRelationInput | VatRateOrderByWithRelationInput[]
    cursor?: VatRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VatRateScalarFieldEnum | VatRateScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model Timezone
   */

  export type AggregateTimezone = {
    _count: TimezoneCountAggregateOutputType | null
    _avg: TimezoneAvgAggregateOutputType | null
    _sum: TimezoneSumAggregateOutputType | null
    _min: TimezoneMinAggregateOutputType | null
    _max: TimezoneMaxAggregateOutputType | null
  }

  export type TimezoneAvgAggregateOutputType = {
    id: number | null
    gmtOffset: number | null
    countryId: number | null
  }

  export type TimezoneSumAggregateOutputType = {
    id: number | null
    gmtOffset: number | null
    countryId: number | null
  }

  export type TimezoneMinAggregateOutputType = {
    id: number | null
    zoneName: string | null
    gmtOffset: number | null
    abbreviation: string | null
    countryId: number | null
  }

  export type TimezoneMaxAggregateOutputType = {
    id: number | null
    zoneName: string | null
    gmtOffset: number | null
    abbreviation: string | null
    countryId: number | null
  }

  export type TimezoneCountAggregateOutputType = {
    id: number
    zoneName: number
    gmtOffset: number
    abbreviation: number
    countryId: number
    _all: number
  }


  export type TimezoneAvgAggregateInputType = {
    id?: true
    gmtOffset?: true
    countryId?: true
  }

  export type TimezoneSumAggregateInputType = {
    id?: true
    gmtOffset?: true
    countryId?: true
  }

  export type TimezoneMinAggregateInputType = {
    id?: true
    zoneName?: true
    gmtOffset?: true
    abbreviation?: true
    countryId?: true
  }

  export type TimezoneMaxAggregateInputType = {
    id?: true
    zoneName?: true
    gmtOffset?: true
    abbreviation?: true
    countryId?: true
  }

  export type TimezoneCountAggregateInputType = {
    id?: true
    zoneName?: true
    gmtOffset?: true
    abbreviation?: true
    countryId?: true
    _all?: true
  }

  export type TimezoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timezone to aggregate.
     */
    where?: TimezoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timezones to fetch.
     */
    orderBy?: TimezoneOrderByWithRelationInput | TimezoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimezoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timezones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timezones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Timezones
    **/
    _count?: true | TimezoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimezoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimezoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimezoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimezoneMaxAggregateInputType
  }

  export type GetTimezoneAggregateType<T extends TimezoneAggregateArgs> = {
        [P in keyof T & keyof AggregateTimezone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimezone[P]>
      : GetScalarType<T[P], AggregateTimezone[P]>
  }




  export type TimezoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimezoneWhereInput
    orderBy?: TimezoneOrderByWithAggregationInput | TimezoneOrderByWithAggregationInput[]
    by: TimezoneScalarFieldEnum[] | TimezoneScalarFieldEnum
    having?: TimezoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimezoneCountAggregateInputType | true
    _avg?: TimezoneAvgAggregateInputType
    _sum?: TimezoneSumAggregateInputType
    _min?: TimezoneMinAggregateInputType
    _max?: TimezoneMaxAggregateInputType
  }

  export type TimezoneGroupByOutputType = {
    id: number
    zoneName: string
    gmtOffset: number
    abbreviation: string
    countryId: number
    _count: TimezoneCountAggregateOutputType | null
    _avg: TimezoneAvgAggregateOutputType | null
    _sum: TimezoneSumAggregateOutputType | null
    _min: TimezoneMinAggregateOutputType | null
    _max: TimezoneMaxAggregateOutputType | null
  }

  type GetTimezoneGroupByPayload<T extends TimezoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimezoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimezoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimezoneGroupByOutputType[P]>
            : GetScalarType<T[P], TimezoneGroupByOutputType[P]>
        }
      >
    >


  export type TimezoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneName?: boolean
    gmtOffset?: boolean
    abbreviation?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timezone"]>

  export type TimezoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneName?: boolean
    gmtOffset?: boolean
    abbreviation?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timezone"]>

  export type TimezoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneName?: boolean
    gmtOffset?: boolean
    abbreviation?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timezone"]>

  export type TimezoneSelectScalar = {
    id?: boolean
    zoneName?: boolean
    gmtOffset?: boolean
    abbreviation?: boolean
    countryId?: boolean
  }

  export type TimezoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zoneName" | "gmtOffset" | "abbreviation" | "countryId", ExtArgs["result"]["timezone"]>
  export type TimezoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type TimezoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type TimezoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $TimezonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Timezone"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      zoneName: string
      gmtOffset: number
      abbreviation: string
      countryId: number
    }, ExtArgs["result"]["timezone"]>
    composites: {}
  }

  type TimezoneGetPayload<S extends boolean | null | undefined | TimezoneDefaultArgs> = $Result.GetResult<Prisma.$TimezonePayload, S>

  type TimezoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimezoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimezoneCountAggregateInputType | true
    }

  export interface TimezoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Timezone'], meta: { name: 'Timezone' } }
    /**
     * Find zero or one Timezone that matches the filter.
     * @param {TimezoneFindUniqueArgs} args - Arguments to find a Timezone
     * @example
     * // Get one Timezone
     * const timezone = await prisma.timezone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimezoneFindUniqueArgs>(args: SelectSubset<T, TimezoneFindUniqueArgs<ExtArgs>>): Prisma__TimezoneClient<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Timezone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimezoneFindUniqueOrThrowArgs} args - Arguments to find a Timezone
     * @example
     * // Get one Timezone
     * const timezone = await prisma.timezone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimezoneFindUniqueOrThrowArgs>(args: SelectSubset<T, TimezoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimezoneClient<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timezone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimezoneFindFirstArgs} args - Arguments to find a Timezone
     * @example
     * // Get one Timezone
     * const timezone = await prisma.timezone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimezoneFindFirstArgs>(args?: SelectSubset<T, TimezoneFindFirstArgs<ExtArgs>>): Prisma__TimezoneClient<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timezone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimezoneFindFirstOrThrowArgs} args - Arguments to find a Timezone
     * @example
     * // Get one Timezone
     * const timezone = await prisma.timezone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimezoneFindFirstOrThrowArgs>(args?: SelectSubset<T, TimezoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimezoneClient<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Timezones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimezoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timezones
     * const timezones = await prisma.timezone.findMany()
     * 
     * // Get first 10 Timezones
     * const timezones = await prisma.timezone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timezoneWithIdOnly = await prisma.timezone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimezoneFindManyArgs>(args?: SelectSubset<T, TimezoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Timezone.
     * @param {TimezoneCreateArgs} args - Arguments to create a Timezone.
     * @example
     * // Create one Timezone
     * const Timezone = await prisma.timezone.create({
     *   data: {
     *     // ... data to create a Timezone
     *   }
     * })
     * 
     */
    create<T extends TimezoneCreateArgs>(args: SelectSubset<T, TimezoneCreateArgs<ExtArgs>>): Prisma__TimezoneClient<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Timezones.
     * @param {TimezoneCreateManyArgs} args - Arguments to create many Timezones.
     * @example
     * // Create many Timezones
     * const timezone = await prisma.timezone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimezoneCreateManyArgs>(args?: SelectSubset<T, TimezoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Timezones and returns the data saved in the database.
     * @param {TimezoneCreateManyAndReturnArgs} args - Arguments to create many Timezones.
     * @example
     * // Create many Timezones
     * const timezone = await prisma.timezone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Timezones and only return the `id`
     * const timezoneWithIdOnly = await prisma.timezone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimezoneCreateManyAndReturnArgs>(args?: SelectSubset<T, TimezoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Timezone.
     * @param {TimezoneDeleteArgs} args - Arguments to delete one Timezone.
     * @example
     * // Delete one Timezone
     * const Timezone = await prisma.timezone.delete({
     *   where: {
     *     // ... filter to delete one Timezone
     *   }
     * })
     * 
     */
    delete<T extends TimezoneDeleteArgs>(args: SelectSubset<T, TimezoneDeleteArgs<ExtArgs>>): Prisma__TimezoneClient<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Timezone.
     * @param {TimezoneUpdateArgs} args - Arguments to update one Timezone.
     * @example
     * // Update one Timezone
     * const timezone = await prisma.timezone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimezoneUpdateArgs>(args: SelectSubset<T, TimezoneUpdateArgs<ExtArgs>>): Prisma__TimezoneClient<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Timezones.
     * @param {TimezoneDeleteManyArgs} args - Arguments to filter Timezones to delete.
     * @example
     * // Delete a few Timezones
     * const { count } = await prisma.timezone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimezoneDeleteManyArgs>(args?: SelectSubset<T, TimezoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timezones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimezoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timezones
     * const timezone = await prisma.timezone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimezoneUpdateManyArgs>(args: SelectSubset<T, TimezoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timezones and returns the data updated in the database.
     * @param {TimezoneUpdateManyAndReturnArgs} args - Arguments to update many Timezones.
     * @example
     * // Update many Timezones
     * const timezone = await prisma.timezone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Timezones and only return the `id`
     * const timezoneWithIdOnly = await prisma.timezone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimezoneUpdateManyAndReturnArgs>(args: SelectSubset<T, TimezoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Timezone.
     * @param {TimezoneUpsertArgs} args - Arguments to update or create a Timezone.
     * @example
     * // Update or create a Timezone
     * const timezone = await prisma.timezone.upsert({
     *   create: {
     *     // ... data to create a Timezone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timezone we want to update
     *   }
     * })
     */
    upsert<T extends TimezoneUpsertArgs>(args: SelectSubset<T, TimezoneUpsertArgs<ExtArgs>>): Prisma__TimezoneClient<$Result.GetResult<Prisma.$TimezonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Timezones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimezoneCountArgs} args - Arguments to filter Timezones to count.
     * @example
     * // Count the number of Timezones
     * const count = await prisma.timezone.count({
     *   where: {
     *     // ... the filter for the Timezones we want to count
     *   }
     * })
    **/
    count<T extends TimezoneCountArgs>(
      args?: Subset<T, TimezoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimezoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timezone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimezoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimezoneAggregateArgs>(args: Subset<T, TimezoneAggregateArgs>): Prisma.PrismaPromise<GetTimezoneAggregateType<T>>

    /**
     * Group by Timezone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimezoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimezoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimezoneGroupByArgs['orderBy'] }
        : { orderBy?: TimezoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimezoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimezoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Timezone model
   */
  readonly fields: TimezoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Timezone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimezoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Timezone model
   */
  interface TimezoneFieldRefs {
    readonly id: FieldRef<"Timezone", 'Int'>
    readonly zoneName: FieldRef<"Timezone", 'String'>
    readonly gmtOffset: FieldRef<"Timezone", 'Int'>
    readonly abbreviation: FieldRef<"Timezone", 'String'>
    readonly countryId: FieldRef<"Timezone", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Timezone findUnique
   */
  export type TimezoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    /**
     * Filter, which Timezone to fetch.
     */
    where: TimezoneWhereUniqueInput
  }

  /**
   * Timezone findUniqueOrThrow
   */
  export type TimezoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    /**
     * Filter, which Timezone to fetch.
     */
    where: TimezoneWhereUniqueInput
  }

  /**
   * Timezone findFirst
   */
  export type TimezoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    /**
     * Filter, which Timezone to fetch.
     */
    where?: TimezoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timezones to fetch.
     */
    orderBy?: TimezoneOrderByWithRelationInput | TimezoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timezones.
     */
    cursor?: TimezoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timezones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timezones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timezones.
     */
    distinct?: TimezoneScalarFieldEnum | TimezoneScalarFieldEnum[]
  }

  /**
   * Timezone findFirstOrThrow
   */
  export type TimezoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    /**
     * Filter, which Timezone to fetch.
     */
    where?: TimezoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timezones to fetch.
     */
    orderBy?: TimezoneOrderByWithRelationInput | TimezoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timezones.
     */
    cursor?: TimezoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timezones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timezones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timezones.
     */
    distinct?: TimezoneScalarFieldEnum | TimezoneScalarFieldEnum[]
  }

  /**
   * Timezone findMany
   */
  export type TimezoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    /**
     * Filter, which Timezones to fetch.
     */
    where?: TimezoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timezones to fetch.
     */
    orderBy?: TimezoneOrderByWithRelationInput | TimezoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Timezones.
     */
    cursor?: TimezoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timezones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timezones.
     */
    skip?: number
    distinct?: TimezoneScalarFieldEnum | TimezoneScalarFieldEnum[]
  }

  /**
   * Timezone create
   */
  export type TimezoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Timezone.
     */
    data: XOR<TimezoneCreateInput, TimezoneUncheckedCreateInput>
  }

  /**
   * Timezone createMany
   */
  export type TimezoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Timezones.
     */
    data: TimezoneCreateManyInput | TimezoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Timezone createManyAndReturn
   */
  export type TimezoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * The data used to create many Timezones.
     */
    data: TimezoneCreateManyInput | TimezoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Timezone update
   */
  export type TimezoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Timezone.
     */
    data: XOR<TimezoneUpdateInput, TimezoneUncheckedUpdateInput>
    /**
     * Choose, which Timezone to update.
     */
    where: TimezoneWhereUniqueInput
  }

  /**
   * Timezone updateMany
   */
  export type TimezoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Timezones.
     */
    data: XOR<TimezoneUpdateManyMutationInput, TimezoneUncheckedUpdateManyInput>
    /**
     * Filter which Timezones to update
     */
    where?: TimezoneWhereInput
    /**
     * Limit how many Timezones to update.
     */
    limit?: number
  }

  /**
   * Timezone updateManyAndReturn
   */
  export type TimezoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * The data used to update Timezones.
     */
    data: XOR<TimezoneUpdateManyMutationInput, TimezoneUncheckedUpdateManyInput>
    /**
     * Filter which Timezones to update
     */
    where?: TimezoneWhereInput
    /**
     * Limit how many Timezones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Timezone upsert
   */
  export type TimezoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Timezone to update in case it exists.
     */
    where: TimezoneWhereUniqueInput
    /**
     * In case the Timezone found by the `where` argument doesn't exist, create a new Timezone with this data.
     */
    create: XOR<TimezoneCreateInput, TimezoneUncheckedCreateInput>
    /**
     * In case the Timezone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimezoneUpdateInput, TimezoneUncheckedUpdateInput>
  }

  /**
   * Timezone delete
   */
  export type TimezoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
    /**
     * Filter which Timezone to delete.
     */
    where: TimezoneWhereUniqueInput
  }

  /**
   * Timezone deleteMany
   */
  export type TimezoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timezones to delete
     */
    where?: TimezoneWhereInput
    /**
     * Limit how many Timezones to delete.
     */
    limit?: number
  }

  /**
   * Timezone without action
   */
  export type TimezoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timezone
     */
    select?: TimezoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timezone
     */
    omit?: TimezoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimezoneInclude<ExtArgs> | null
  }


  /**
   * Model UserAddress
   */

  export type AggregateUserAddress = {
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  export type UserAddressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    addressId: number | null
  }

  export type UserAddressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    addressId: number | null
  }

  export type UserAddressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    addressId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    addressType: $Enums.AddressType | null
  }

  export type UserAddressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    addressId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    addressType: $Enums.AddressType | null
  }

  export type UserAddressCountAggregateOutputType = {
    id: number
    userId: number
    addressId: number
    createdAt: number
    updatedAt: number
    addressType: number
    _all: number
  }


  export type UserAddressAvgAggregateInputType = {
    id?: true
    userId?: true
    addressId?: true
  }

  export type UserAddressSumAggregateInputType = {
    id?: true
    userId?: true
    addressId?: true
  }

  export type UserAddressMinAggregateInputType = {
    id?: true
    userId?: true
    addressId?: true
    createdAt?: true
    updatedAt?: true
    addressType?: true
  }

  export type UserAddressMaxAggregateInputType = {
    id?: true
    userId?: true
    addressId?: true
    createdAt?: true
    updatedAt?: true
    addressType?: true
  }

  export type UserAddressCountAggregateInputType = {
    id?: true
    userId?: true
    addressId?: true
    createdAt?: true
    updatedAt?: true
    addressType?: true
    _all?: true
  }

  export type UserAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddress to aggregate.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAddresses
    **/
    _count?: true | UserAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAddressMaxAggregateInputType
  }

  export type GetUserAddressAggregateType<T extends UserAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAddress[P]>
      : GetScalarType<T[P], AggregateUserAddress[P]>
  }




  export type UserAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithAggregationInput | UserAddressOrderByWithAggregationInput[]
    by: UserAddressScalarFieldEnum[] | UserAddressScalarFieldEnum
    having?: UserAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAddressCountAggregateInputType | true
    _avg?: UserAddressAvgAggregateInputType
    _sum?: UserAddressSumAggregateInputType
    _min?: UserAddressMinAggregateInputType
    _max?: UserAddressMaxAggregateInputType
  }

  export type UserAddressGroupByOutputType = {
    id: number
    userId: number
    addressId: number
    createdAt: Date
    updatedAt: Date
    addressType: $Enums.AddressType
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  type GetUserAddressGroupByPayload<T extends UserAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
            : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
        }
      >
    >


  export type UserAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressType?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressType?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressType?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectScalar = {
    id?: boolean
    userId?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressType?: boolean
  }

  export type UserAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "addressId" | "createdAt" | "updatedAt" | "addressType", ExtArgs["result"]["userAddress"]>
  export type UserAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAddress"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      addressId: number
      createdAt: Date
      updatedAt: Date
      addressType: $Enums.AddressType
    }, ExtArgs["result"]["userAddress"]>
    composites: {}
  }

  type UserAddressGetPayload<S extends boolean | null | undefined | UserAddressDefaultArgs> = $Result.GetResult<Prisma.$UserAddressPayload, S>

  type UserAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAddressCountAggregateInputType | true
    }

  export interface UserAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAddress'], meta: { name: 'UserAddress' } }
    /**
     * Find zero or one UserAddress that matches the filter.
     * @param {UserAddressFindUniqueArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAddressFindUniqueArgs>(args: SelectSubset<T, UserAddressFindUniqueArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAddressFindUniqueOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAddressFindFirstArgs>(args?: SelectSubset<T, UserAddressFindFirstArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAddresses
     * const userAddresses = await prisma.userAddress.findMany()
     * 
     * // Get first 10 UserAddresses
     * const userAddresses = await prisma.userAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAddressFindManyArgs>(args?: SelectSubset<T, UserAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAddress.
     * @param {UserAddressCreateArgs} args - Arguments to create a UserAddress.
     * @example
     * // Create one UserAddress
     * const UserAddress = await prisma.userAddress.create({
     *   data: {
     *     // ... data to create a UserAddress
     *   }
     * })
     * 
     */
    create<T extends UserAddressCreateArgs>(args: SelectSubset<T, UserAddressCreateArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAddresses.
     * @param {UserAddressCreateManyArgs} args - Arguments to create many UserAddresses.
     * @example
     * // Create many UserAddresses
     * const userAddress = await prisma.userAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAddressCreateManyArgs>(args?: SelectSubset<T, UserAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAddresses and returns the data saved in the database.
     * @param {UserAddressCreateManyAndReturnArgs} args - Arguments to create many UserAddresses.
     * @example
     * // Create many UserAddresses
     * const userAddress = await prisma.userAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAddresses and only return the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAddress.
     * @param {UserAddressDeleteArgs} args - Arguments to delete one UserAddress.
     * @example
     * // Delete one UserAddress
     * const UserAddress = await prisma.userAddress.delete({
     *   where: {
     *     // ... filter to delete one UserAddress
     *   }
     * })
     * 
     */
    delete<T extends UserAddressDeleteArgs>(args: SelectSubset<T, UserAddressDeleteArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAddress.
     * @param {UserAddressUpdateArgs} args - Arguments to update one UserAddress.
     * @example
     * // Update one UserAddress
     * const userAddress = await prisma.userAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAddressUpdateArgs>(args: SelectSubset<T, UserAddressUpdateArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAddresses.
     * @param {UserAddressDeleteManyArgs} args - Arguments to filter UserAddresses to delete.
     * @example
     * // Delete a few UserAddresses
     * const { count } = await prisma.userAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAddressDeleteManyArgs>(args?: SelectSubset<T, UserAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAddressUpdateManyArgs>(args: SelectSubset<T, UserAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses and returns the data updated in the database.
     * @param {UserAddressUpdateManyAndReturnArgs} args - Arguments to update many UserAddresses.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAddresses and only return the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAddress.
     * @param {UserAddressUpsertArgs} args - Arguments to update or create a UserAddress.
     * @example
     * // Update or create a UserAddress
     * const userAddress = await prisma.userAddress.upsert({
     *   create: {
     *     // ... data to create a UserAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAddress we want to update
     *   }
     * })
     */
    upsert<T extends UserAddressUpsertArgs>(args: SelectSubset<T, UserAddressUpsertArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressCountArgs} args - Arguments to filter UserAddresses to count.
     * @example
     * // Count the number of UserAddresses
     * const count = await prisma.userAddress.count({
     *   where: {
     *     // ... the filter for the UserAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserAddressCountArgs>(
      args?: Subset<T, UserAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAddressAggregateArgs>(args: Subset<T, UserAddressAggregateArgs>): Prisma.PrismaPromise<GetUserAddressAggregateType<T>>

    /**
     * Group by UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAddress model
   */
  readonly fields: UserAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends AddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressDefaultArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAddress model
   */
  interface UserAddressFieldRefs {
    readonly id: FieldRef<"UserAddress", 'Int'>
    readonly userId: FieldRef<"UserAddress", 'Int'>
    readonly addressId: FieldRef<"UserAddress", 'Int'>
    readonly createdAt: FieldRef<"UserAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAddress", 'DateTime'>
    readonly addressType: FieldRef<"UserAddress", 'AddressType'>
  }
    

  // Custom InputTypes
  /**
   * UserAddress findUnique
   */
  export type UserAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findUniqueOrThrow
   */
  export type UserAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findFirst
   */
  export type UserAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findFirstOrThrow
   */
  export type UserAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findMany
   */
  export type UserAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddresses to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress create
   */
  export type UserAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAddress.
     */
    data: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
  }

  /**
   * UserAddress createMany
   */
  export type UserAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAddresses.
     */
    data: UserAddressCreateManyInput | UserAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAddress createManyAndReturn
   */
  export type UserAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * The data used to create many UserAddresses.
     */
    data: UserAddressCreateManyInput | UserAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAddress update
   */
  export type UserAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAddress.
     */
    data: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
    /**
     * Choose, which UserAddress to update.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress updateMany
   */
  export type UserAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAddresses.
     */
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     */
    where?: UserAddressWhereInput
    /**
     * Limit how many UserAddresses to update.
     */
    limit?: number
  }

  /**
   * UserAddress updateManyAndReturn
   */
  export type UserAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * The data used to update UserAddresses.
     */
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     */
    where?: UserAddressWhereInput
    /**
     * Limit how many UserAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAddress upsert
   */
  export type UserAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAddress to update in case it exists.
     */
    where: UserAddressWhereUniqueInput
    /**
     * In case the UserAddress found by the `where` argument doesn't exist, create a new UserAddress with this data.
     */
    create: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
    /**
     * In case the UserAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
  }

  /**
   * UserAddress delete
   */
  export type UserAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter which UserAddress to delete.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress deleteMany
   */
  export type UserAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddresses to delete
     */
    where?: UserAddressWhereInput
    /**
     * Limit how many UserAddresses to delete.
     */
    limit?: number
  }

  /**
   * UserAddress without action
   */
  export type UserAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    street: string | null
    complement: string | null
    streetNumber: string | null
    boxNumber: string | null
    cityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    street: string | null
    complement: string | null
    streetNumber: string | null
    boxNumber: string | null
    cityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    street: number
    complement: number
    streetNumber: number
    boxNumber: number
    cityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    street?: true
    complement?: true
    streetNumber?: true
    boxNumber?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    street?: true
    complement?: true
    streetNumber?: true
    boxNumber?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    street?: true
    complement?: true
    streetNumber?: true
    boxNumber?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    street: string
    complement: string | null
    streetNumber: string | null
    boxNumber: string | null
    cityId: number
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    complement?: boolean
    streetNumber?: boolean
    boxNumber?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    userAddresses?: boolean | Address$userAddressesArgs<ExtArgs>
    agency?: boolean | Address$agencyArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    complement?: boolean
    streetNumber?: boolean
    boxNumber?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    complement?: boolean
    streetNumber?: boolean
    boxNumber?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    street?: boolean
    complement?: boolean
    streetNumber?: boolean
    boxNumber?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "street" | "complement" | "streetNumber" | "boxNumber" | "cityId" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    userAddresses?: boolean | Address$userAddressesArgs<ExtArgs>
    agency?: boolean | Address$agencyArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      userAddresses: Prisma.$UserAddressPayload<ExtArgs>[]
      agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      street: string
      complement: string | null
      streetNumber: string | null
      boxNumber: string | null
      cityId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userAddresses<T extends Address$userAddressesArgs<ExtArgs> = {}>(args?: Subset<T, Address$userAddressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agency<T extends Address$agencyArgs<ExtArgs> = {}>(args?: Subset<T, Address$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly street: FieldRef<"Address", 'String'>
    readonly complement: FieldRef<"Address", 'String'>
    readonly streetNumber: FieldRef<"Address", 'String'>
    readonly boxNumber: FieldRef<"Address", 'String'>
    readonly cityId: FieldRef<"Address", 'Int'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.userAddresses
   */
  export type Address$userAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    cursor?: UserAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * Address.agency
   */
  export type Address$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyAvgAggregateOutputType = {
    id: number | null
    addressId: number | null
    capacity: number | null
    availableSlots: number | null
    createdById: number | null
  }

  export type AgencySumAggregateOutputType = {
    id: number | null
    addressId: number | null
    capacity: number | null
    availableSlots: number | null
    createdById: number | null
  }

  export type AgencyMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    phoneNumber: string | null
    email: string | null
    vatNumber: string | null
    addressId: number | null
    capacity: number | null
    availableSlots: number | null
    updatedAt: Date | null
    createdAt: Date | null
    createdById: number | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    phoneNumber: string | null
    email: string | null
    vatNumber: string | null
    addressId: number | null
    capacity: number | null
    availableSlots: number | null
    updatedAt: Date | null
    createdAt: Date | null
    createdById: number | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    name: number
    location: number
    phoneNumber: number
    email: number
    vatNumber: number
    addressId: number
    capacity: number
    availableSlots: number
    updatedAt: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type AgencyAvgAggregateInputType = {
    id?: true
    addressId?: true
    capacity?: true
    availableSlots?: true
    createdById?: true
  }

  export type AgencySumAggregateInputType = {
    id?: true
    addressId?: true
    capacity?: true
    availableSlots?: true
    createdById?: true
  }

  export type AgencyMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    phoneNumber?: true
    email?: true
    vatNumber?: true
    addressId?: true
    capacity?: true
    availableSlots?: true
    updatedAt?: true
    createdAt?: true
    createdById?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    phoneNumber?: true
    email?: true
    vatNumber?: true
    addressId?: true
    capacity?: true
    availableSlots?: true
    updatedAt?: true
    createdAt?: true
    createdById?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    phoneNumber?: true
    email?: true
    vatNumber?: true
    addressId?: true
    capacity?: true
    availableSlots?: true
    updatedAt?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _avg?: AgencyAvgAggregateInputType
    _sum?: AgencySumAggregateInputType
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: number
    name: string
    location: string | null
    phoneNumber: string | null
    email: string | null
    vatNumber: string | null
    addressId: number
    capacity: number | null
    availableSlots: number | null
    updatedAt: Date
    createdAt: Date
    createdById: number | null
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    phoneNumber?: boolean
    email?: boolean
    vatNumber?: boolean
    addressId?: boolean
    capacity?: boolean
    availableSlots?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Agency$createdByArgs<ExtArgs>
    arrivalEnvoi?: boolean | Agency$arrivalEnvoiArgs<ExtArgs>
    departureEnvoi?: boolean | Agency$departureEnvoiArgs<ExtArgs>
    notifications?: boolean | Agency$notificationsArgs<ExtArgs>
    appointments?: boolean | Agency$appointmentsArgs<ExtArgs>
    transports?: boolean | Agency$transportsArgs<ExtArgs>
    tarifs?: boolean | Agency$tarifsArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
    agencyClients?: boolean | Agency$agencyClientsArgs<ExtArgs>
    agencyStaff?: boolean | Agency$agencyStaffArgs<ExtArgs>
    activityLogs?: boolean | Agency$activityLogsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    phoneNumber?: boolean
    email?: boolean
    vatNumber?: boolean
    addressId?: boolean
    capacity?: boolean
    availableSlots?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Agency$createdByArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    phoneNumber?: boolean
    email?: boolean
    vatNumber?: boolean
    addressId?: boolean
    capacity?: boolean
    availableSlots?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Agency$createdByArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    phoneNumber?: boolean
    email?: boolean
    vatNumber?: boolean
    addressId?: boolean
    capacity?: boolean
    availableSlots?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type AgencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "phoneNumber" | "email" | "vatNumber" | "addressId" | "capacity" | "availableSlots" | "updatedAt" | "createdAt" | "createdById", ExtArgs["result"]["agency"]>
  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Agency$createdByArgs<ExtArgs>
    arrivalEnvoi?: boolean | Agency$arrivalEnvoiArgs<ExtArgs>
    departureEnvoi?: boolean | Agency$departureEnvoiArgs<ExtArgs>
    notifications?: boolean | Agency$notificationsArgs<ExtArgs>
    appointments?: boolean | Agency$appointmentsArgs<ExtArgs>
    transports?: boolean | Agency$transportsArgs<ExtArgs>
    tarifs?: boolean | Agency$tarifsArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
    agencyClients?: boolean | Agency$agencyClientsArgs<ExtArgs>
    agencyStaff?: boolean | Agency$agencyStaffArgs<ExtArgs>
    activityLogs?: boolean | Agency$activityLogsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Agency$createdByArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Agency$createdByArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      arrivalEnvoi: Prisma.$EnvoiPayload<ExtArgs>[]
      departureEnvoi: Prisma.$EnvoiPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      transports: Prisma.$TransportPayload<ExtArgs>[]
      tarifs: Prisma.$TarifsPayload<ExtArgs>[]
      address: Prisma.$AddressPayload<ExtArgs>
      agencyClients: Prisma.$AgencyClientsPayload<ExtArgs>[]
      agencyStaff: Prisma.$AgencyStaffPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string | null
      phoneNumber: string | null
      email: string | null
      vatNumber: string | null
      addressId: number
      capacity: number | null
      availableSlots: number | null
      updatedAt: Date
      createdAt: Date
      createdById: number | null
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyFindUniqueArgs>(args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyFindFirstArgs>(args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyFindManyArgs>(args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
     */
    create<T extends AgencyCreateArgs>(args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyCreateManyArgs>(args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agencies and returns the data saved in the database.
     * @param {AgencyCreateManyAndReturnArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
     */
    delete<T extends AgencyDeleteArgs>(args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyUpdateArgs>(args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyDeleteManyArgs>(args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyUpdateManyArgs>(args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies and returns the data updated in the database.
     * @param {AgencyUpdateManyAndReturnArgs} args - Arguments to update many Agencies.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
     */
    upsert<T extends AgencyUpsertArgs>(args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Agency$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Agency$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    arrivalEnvoi<T extends Agency$arrivalEnvoiArgs<ExtArgs> = {}>(args?: Subset<T, Agency$arrivalEnvoiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departureEnvoi<T extends Agency$departureEnvoiArgs<ExtArgs> = {}>(args?: Subset<T, Agency$departureEnvoiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Agency$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Agency$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transports<T extends Agency$transportsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$transportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tarifs<T extends Agency$tarifsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$tarifsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    address<T extends AddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressDefaultArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agencyClients<T extends Agency$agencyClientsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agencyClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencyStaff<T extends Agency$agencyStaffArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agencyStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends Agency$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agency model
   */
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'Int'>
    readonly name: FieldRef<"Agency", 'String'>
    readonly location: FieldRef<"Agency", 'String'>
    readonly phoneNumber: FieldRef<"Agency", 'String'>
    readonly email: FieldRef<"Agency", 'String'>
    readonly vatNumber: FieldRef<"Agency", 'String'>
    readonly addressId: FieldRef<"Agency", 'Int'>
    readonly capacity: FieldRef<"Agency", 'Int'>
    readonly availableSlots: FieldRef<"Agency", 'Int'>
    readonly updatedAt: FieldRef<"Agency", 'DateTime'>
    readonly createdAt: FieldRef<"Agency", 'DateTime'>
    readonly createdById: FieldRef<"Agency", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency createManyAndReturn
   */
  export type AgencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency updateManyAndReturn
   */
  export type AgencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to delete.
     */
    limit?: number
  }

  /**
   * Agency.createdBy
   */
  export type Agency$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Agency.arrivalEnvoi
   */
  export type Agency$arrivalEnvoiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    where?: EnvoiWhereInput
    orderBy?: EnvoiOrderByWithRelationInput | EnvoiOrderByWithRelationInput[]
    cursor?: EnvoiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvoiScalarFieldEnum | EnvoiScalarFieldEnum[]
  }

  /**
   * Agency.departureEnvoi
   */
  export type Agency$departureEnvoiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    where?: EnvoiWhereInput
    orderBy?: EnvoiOrderByWithRelationInput | EnvoiOrderByWithRelationInput[]
    cursor?: EnvoiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvoiScalarFieldEnum | EnvoiScalarFieldEnum[]
  }

  /**
   * Agency.notifications
   */
  export type Agency$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Agency.appointments
   */
  export type Agency$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Agency.transports
   */
  export type Agency$transportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    where?: TransportWhereInput
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    cursor?: TransportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportScalarFieldEnum | TransportScalarFieldEnum[]
  }

  /**
   * Agency.tarifs
   */
  export type Agency$tarifsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    where?: TarifsWhereInput
    orderBy?: TarifsOrderByWithRelationInput | TarifsOrderByWithRelationInput[]
    cursor?: TarifsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TarifsScalarFieldEnum | TarifsScalarFieldEnum[]
  }

  /**
   * Agency.agencyClients
   */
  export type Agency$agencyClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClients
     */
    select?: AgencyClientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClients
     */
    omit?: AgencyClientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientsInclude<ExtArgs> | null
    where?: AgencyClientsWhereInput
    orderBy?: AgencyClientsOrderByWithRelationInput | AgencyClientsOrderByWithRelationInput[]
    cursor?: AgencyClientsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyClientsScalarFieldEnum | AgencyClientsScalarFieldEnum[]
  }

  /**
   * Agency.agencyStaff
   */
  export type Agency$agencyStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyStaff
     */
    select?: AgencyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyStaff
     */
    omit?: AgencyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyStaffInclude<ExtArgs> | null
    where?: AgencyStaffWhereInput
    orderBy?: AgencyStaffOrderByWithRelationInput | AgencyStaffOrderByWithRelationInput[]
    cursor?: AgencyStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyStaffScalarFieldEnum | AgencyStaffScalarFieldEnum[]
  }

  /**
   * Agency.activityLogs
   */
  export type Agency$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model ClientDestinataire
   */

  export type AggregateClientDestinataire = {
    _count: ClientDestinataireCountAggregateOutputType | null
    _avg: ClientDestinataireAvgAggregateOutputType | null
    _sum: ClientDestinataireSumAggregateOutputType | null
    _min: ClientDestinataireMinAggregateOutputType | null
    _max: ClientDestinataireMaxAggregateOutputType | null
  }

  export type ClientDestinataireAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    destinataireId: number | null
  }

  export type ClientDestinataireSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    destinataireId: number | null
  }

  export type ClientDestinataireMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    destinataireId: number | null
    createdAt: Date | null
  }

  export type ClientDestinataireMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    destinataireId: number | null
    createdAt: Date | null
  }

  export type ClientDestinataireCountAggregateOutputType = {
    id: number
    clientId: number
    destinataireId: number
    createdAt: number
    _all: number
  }


  export type ClientDestinataireAvgAggregateInputType = {
    id?: true
    clientId?: true
    destinataireId?: true
  }

  export type ClientDestinataireSumAggregateInputType = {
    id?: true
    clientId?: true
    destinataireId?: true
  }

  export type ClientDestinataireMinAggregateInputType = {
    id?: true
    clientId?: true
    destinataireId?: true
    createdAt?: true
  }

  export type ClientDestinataireMaxAggregateInputType = {
    id?: true
    clientId?: true
    destinataireId?: true
    createdAt?: true
  }

  export type ClientDestinataireCountAggregateInputType = {
    id?: true
    clientId?: true
    destinataireId?: true
    createdAt?: true
    _all?: true
  }

  export type ClientDestinataireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientDestinataire to aggregate.
     */
    where?: ClientDestinataireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDestinataires to fetch.
     */
    orderBy?: ClientDestinataireOrderByWithRelationInput | ClientDestinataireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientDestinataireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDestinataires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDestinataires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientDestinataires
    **/
    _count?: true | ClientDestinataireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientDestinataireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientDestinataireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientDestinataireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientDestinataireMaxAggregateInputType
  }

  export type GetClientDestinataireAggregateType<T extends ClientDestinataireAggregateArgs> = {
        [P in keyof T & keyof AggregateClientDestinataire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientDestinataire[P]>
      : GetScalarType<T[P], AggregateClientDestinataire[P]>
  }




  export type ClientDestinataireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientDestinataireWhereInput
    orderBy?: ClientDestinataireOrderByWithAggregationInput | ClientDestinataireOrderByWithAggregationInput[]
    by: ClientDestinataireScalarFieldEnum[] | ClientDestinataireScalarFieldEnum
    having?: ClientDestinataireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientDestinataireCountAggregateInputType | true
    _avg?: ClientDestinataireAvgAggregateInputType
    _sum?: ClientDestinataireSumAggregateInputType
    _min?: ClientDestinataireMinAggregateInputType
    _max?: ClientDestinataireMaxAggregateInputType
  }

  export type ClientDestinataireGroupByOutputType = {
    id: number
    clientId: number
    destinataireId: number
    createdAt: Date
    _count: ClientDestinataireCountAggregateOutputType | null
    _avg: ClientDestinataireAvgAggregateOutputType | null
    _sum: ClientDestinataireSumAggregateOutputType | null
    _min: ClientDestinataireMinAggregateOutputType | null
    _max: ClientDestinataireMaxAggregateOutputType | null
  }

  type GetClientDestinataireGroupByPayload<T extends ClientDestinataireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientDestinataireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientDestinataireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientDestinataireGroupByOutputType[P]>
            : GetScalarType<T[P], ClientDestinataireGroupByOutputType[P]>
        }
      >
    >


  export type ClientDestinataireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    destinataireId?: boolean
    createdAt?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
    destinataire?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientDestinataire"]>

  export type ClientDestinataireSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    destinataireId?: boolean
    createdAt?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
    destinataire?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientDestinataire"]>

  export type ClientDestinataireSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    destinataireId?: boolean
    createdAt?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
    destinataire?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientDestinataire"]>

  export type ClientDestinataireSelectScalar = {
    id?: boolean
    clientId?: boolean
    destinataireId?: boolean
    createdAt?: boolean
  }

  export type ClientDestinataireOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "destinataireId" | "createdAt", ExtArgs["result"]["clientDestinataire"]>
  export type ClientDestinataireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
    destinataire?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientDestinataireIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
    destinataire?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientDestinataireIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
    destinataire?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientDestinatairePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientDestinataire"
    objects: {
      client: Prisma.$UserPayload<ExtArgs>
      destinataire: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clientId: number
      destinataireId: number
      createdAt: Date
    }, ExtArgs["result"]["clientDestinataire"]>
    composites: {}
  }

  type ClientDestinataireGetPayload<S extends boolean | null | undefined | ClientDestinataireDefaultArgs> = $Result.GetResult<Prisma.$ClientDestinatairePayload, S>

  type ClientDestinataireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientDestinataireFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientDestinataireCountAggregateInputType | true
    }

  export interface ClientDestinataireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientDestinataire'], meta: { name: 'ClientDestinataire' } }
    /**
     * Find zero or one ClientDestinataire that matches the filter.
     * @param {ClientDestinataireFindUniqueArgs} args - Arguments to find a ClientDestinataire
     * @example
     * // Get one ClientDestinataire
     * const clientDestinataire = await prisma.clientDestinataire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientDestinataireFindUniqueArgs>(args: SelectSubset<T, ClientDestinataireFindUniqueArgs<ExtArgs>>): Prisma__ClientDestinataireClient<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientDestinataire that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientDestinataireFindUniqueOrThrowArgs} args - Arguments to find a ClientDestinataire
     * @example
     * // Get one ClientDestinataire
     * const clientDestinataire = await prisma.clientDestinataire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientDestinataireFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientDestinataireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientDestinataireClient<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientDestinataire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDestinataireFindFirstArgs} args - Arguments to find a ClientDestinataire
     * @example
     * // Get one ClientDestinataire
     * const clientDestinataire = await prisma.clientDestinataire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientDestinataireFindFirstArgs>(args?: SelectSubset<T, ClientDestinataireFindFirstArgs<ExtArgs>>): Prisma__ClientDestinataireClient<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientDestinataire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDestinataireFindFirstOrThrowArgs} args - Arguments to find a ClientDestinataire
     * @example
     * // Get one ClientDestinataire
     * const clientDestinataire = await prisma.clientDestinataire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientDestinataireFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientDestinataireFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientDestinataireClient<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientDestinataires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDestinataireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientDestinataires
     * const clientDestinataires = await prisma.clientDestinataire.findMany()
     * 
     * // Get first 10 ClientDestinataires
     * const clientDestinataires = await prisma.clientDestinataire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientDestinataireWithIdOnly = await prisma.clientDestinataire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientDestinataireFindManyArgs>(args?: SelectSubset<T, ClientDestinataireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientDestinataire.
     * @param {ClientDestinataireCreateArgs} args - Arguments to create a ClientDestinataire.
     * @example
     * // Create one ClientDestinataire
     * const ClientDestinataire = await prisma.clientDestinataire.create({
     *   data: {
     *     // ... data to create a ClientDestinataire
     *   }
     * })
     * 
     */
    create<T extends ClientDestinataireCreateArgs>(args: SelectSubset<T, ClientDestinataireCreateArgs<ExtArgs>>): Prisma__ClientDestinataireClient<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientDestinataires.
     * @param {ClientDestinataireCreateManyArgs} args - Arguments to create many ClientDestinataires.
     * @example
     * // Create many ClientDestinataires
     * const clientDestinataire = await prisma.clientDestinataire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientDestinataireCreateManyArgs>(args?: SelectSubset<T, ClientDestinataireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientDestinataires and returns the data saved in the database.
     * @param {ClientDestinataireCreateManyAndReturnArgs} args - Arguments to create many ClientDestinataires.
     * @example
     * // Create many ClientDestinataires
     * const clientDestinataire = await prisma.clientDestinataire.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientDestinataires and only return the `id`
     * const clientDestinataireWithIdOnly = await prisma.clientDestinataire.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientDestinataireCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientDestinataireCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientDestinataire.
     * @param {ClientDestinataireDeleteArgs} args - Arguments to delete one ClientDestinataire.
     * @example
     * // Delete one ClientDestinataire
     * const ClientDestinataire = await prisma.clientDestinataire.delete({
     *   where: {
     *     // ... filter to delete one ClientDestinataire
     *   }
     * })
     * 
     */
    delete<T extends ClientDestinataireDeleteArgs>(args: SelectSubset<T, ClientDestinataireDeleteArgs<ExtArgs>>): Prisma__ClientDestinataireClient<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientDestinataire.
     * @param {ClientDestinataireUpdateArgs} args - Arguments to update one ClientDestinataire.
     * @example
     * // Update one ClientDestinataire
     * const clientDestinataire = await prisma.clientDestinataire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientDestinataireUpdateArgs>(args: SelectSubset<T, ClientDestinataireUpdateArgs<ExtArgs>>): Prisma__ClientDestinataireClient<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientDestinataires.
     * @param {ClientDestinataireDeleteManyArgs} args - Arguments to filter ClientDestinataires to delete.
     * @example
     * // Delete a few ClientDestinataires
     * const { count } = await prisma.clientDestinataire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDestinataireDeleteManyArgs>(args?: SelectSubset<T, ClientDestinataireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientDestinataires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDestinataireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientDestinataires
     * const clientDestinataire = await prisma.clientDestinataire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientDestinataireUpdateManyArgs>(args: SelectSubset<T, ClientDestinataireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientDestinataires and returns the data updated in the database.
     * @param {ClientDestinataireUpdateManyAndReturnArgs} args - Arguments to update many ClientDestinataires.
     * @example
     * // Update many ClientDestinataires
     * const clientDestinataire = await prisma.clientDestinataire.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientDestinataires and only return the `id`
     * const clientDestinataireWithIdOnly = await prisma.clientDestinataire.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientDestinataireUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientDestinataireUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientDestinataire.
     * @param {ClientDestinataireUpsertArgs} args - Arguments to update or create a ClientDestinataire.
     * @example
     * // Update or create a ClientDestinataire
     * const clientDestinataire = await prisma.clientDestinataire.upsert({
     *   create: {
     *     // ... data to create a ClientDestinataire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientDestinataire we want to update
     *   }
     * })
     */
    upsert<T extends ClientDestinataireUpsertArgs>(args: SelectSubset<T, ClientDestinataireUpsertArgs<ExtArgs>>): Prisma__ClientDestinataireClient<$Result.GetResult<Prisma.$ClientDestinatairePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientDestinataires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDestinataireCountArgs} args - Arguments to filter ClientDestinataires to count.
     * @example
     * // Count the number of ClientDestinataires
     * const count = await prisma.clientDestinataire.count({
     *   where: {
     *     // ... the filter for the ClientDestinataires we want to count
     *   }
     * })
    **/
    count<T extends ClientDestinataireCountArgs>(
      args?: Subset<T, ClientDestinataireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientDestinataireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientDestinataire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDestinataireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientDestinataireAggregateArgs>(args: Subset<T, ClientDestinataireAggregateArgs>): Prisma.PrismaPromise<GetClientDestinataireAggregateType<T>>

    /**
     * Group by ClientDestinataire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDestinataireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientDestinataireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientDestinataireGroupByArgs['orderBy'] }
        : { orderBy?: ClientDestinataireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientDestinataireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientDestinataireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientDestinataire model
   */
  readonly fields: ClientDestinataireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientDestinataire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientDestinataireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    destinataire<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientDestinataire model
   */
  interface ClientDestinataireFieldRefs {
    readonly id: FieldRef<"ClientDestinataire", 'Int'>
    readonly clientId: FieldRef<"ClientDestinataire", 'Int'>
    readonly destinataireId: FieldRef<"ClientDestinataire", 'Int'>
    readonly createdAt: FieldRef<"ClientDestinataire", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientDestinataire findUnique
   */
  export type ClientDestinataireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    /**
     * Filter, which ClientDestinataire to fetch.
     */
    where: ClientDestinataireWhereUniqueInput
  }

  /**
   * ClientDestinataire findUniqueOrThrow
   */
  export type ClientDestinataireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    /**
     * Filter, which ClientDestinataire to fetch.
     */
    where: ClientDestinataireWhereUniqueInput
  }

  /**
   * ClientDestinataire findFirst
   */
  export type ClientDestinataireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    /**
     * Filter, which ClientDestinataire to fetch.
     */
    where?: ClientDestinataireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDestinataires to fetch.
     */
    orderBy?: ClientDestinataireOrderByWithRelationInput | ClientDestinataireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientDestinataires.
     */
    cursor?: ClientDestinataireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDestinataires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDestinataires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientDestinataires.
     */
    distinct?: ClientDestinataireScalarFieldEnum | ClientDestinataireScalarFieldEnum[]
  }

  /**
   * ClientDestinataire findFirstOrThrow
   */
  export type ClientDestinataireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    /**
     * Filter, which ClientDestinataire to fetch.
     */
    where?: ClientDestinataireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDestinataires to fetch.
     */
    orderBy?: ClientDestinataireOrderByWithRelationInput | ClientDestinataireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientDestinataires.
     */
    cursor?: ClientDestinataireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDestinataires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDestinataires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientDestinataires.
     */
    distinct?: ClientDestinataireScalarFieldEnum | ClientDestinataireScalarFieldEnum[]
  }

  /**
   * ClientDestinataire findMany
   */
  export type ClientDestinataireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    /**
     * Filter, which ClientDestinataires to fetch.
     */
    where?: ClientDestinataireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDestinataires to fetch.
     */
    orderBy?: ClientDestinataireOrderByWithRelationInput | ClientDestinataireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientDestinataires.
     */
    cursor?: ClientDestinataireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDestinataires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDestinataires.
     */
    skip?: number
    distinct?: ClientDestinataireScalarFieldEnum | ClientDestinataireScalarFieldEnum[]
  }

  /**
   * ClientDestinataire create
   */
  export type ClientDestinataireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientDestinataire.
     */
    data: XOR<ClientDestinataireCreateInput, ClientDestinataireUncheckedCreateInput>
  }

  /**
   * ClientDestinataire createMany
   */
  export type ClientDestinataireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientDestinataires.
     */
    data: ClientDestinataireCreateManyInput | ClientDestinataireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientDestinataire createManyAndReturn
   */
  export type ClientDestinataireCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * The data used to create many ClientDestinataires.
     */
    data: ClientDestinataireCreateManyInput | ClientDestinataireCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientDestinataire update
   */
  export type ClientDestinataireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientDestinataire.
     */
    data: XOR<ClientDestinataireUpdateInput, ClientDestinataireUncheckedUpdateInput>
    /**
     * Choose, which ClientDestinataire to update.
     */
    where: ClientDestinataireWhereUniqueInput
  }

  /**
   * ClientDestinataire updateMany
   */
  export type ClientDestinataireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientDestinataires.
     */
    data: XOR<ClientDestinataireUpdateManyMutationInput, ClientDestinataireUncheckedUpdateManyInput>
    /**
     * Filter which ClientDestinataires to update
     */
    where?: ClientDestinataireWhereInput
    /**
     * Limit how many ClientDestinataires to update.
     */
    limit?: number
  }

  /**
   * ClientDestinataire updateManyAndReturn
   */
  export type ClientDestinataireUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * The data used to update ClientDestinataires.
     */
    data: XOR<ClientDestinataireUpdateManyMutationInput, ClientDestinataireUncheckedUpdateManyInput>
    /**
     * Filter which ClientDestinataires to update
     */
    where?: ClientDestinataireWhereInput
    /**
     * Limit how many ClientDestinataires to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientDestinataire upsert
   */
  export type ClientDestinataireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientDestinataire to update in case it exists.
     */
    where: ClientDestinataireWhereUniqueInput
    /**
     * In case the ClientDestinataire found by the `where` argument doesn't exist, create a new ClientDestinataire with this data.
     */
    create: XOR<ClientDestinataireCreateInput, ClientDestinataireUncheckedCreateInput>
    /**
     * In case the ClientDestinataire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientDestinataireUpdateInput, ClientDestinataireUncheckedUpdateInput>
  }

  /**
   * ClientDestinataire delete
   */
  export type ClientDestinataireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
    /**
     * Filter which ClientDestinataire to delete.
     */
    where: ClientDestinataireWhereUniqueInput
  }

  /**
   * ClientDestinataire deleteMany
   */
  export type ClientDestinataireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientDestinataires to delete
     */
    where?: ClientDestinataireWhereInput
    /**
     * Limit how many ClientDestinataires to delete.
     */
    limit?: number
  }

  /**
   * ClientDestinataire without action
   */
  export type ClientDestinataireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDestinataire
     */
    select?: ClientDestinataireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDestinataire
     */
    omit?: ClientDestinataireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDestinataireInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    id: number | null
    discountAmount: Decimal | null
    discountPercentage: Decimal | null
    numberOfUses: number | null
  }

  export type CouponSumAggregateOutputType = {
    id: number | null
    discountAmount: Decimal | null
    discountPercentage: Decimal | null
    numberOfUses: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: number | null
    couponCode: string | null
    discountAmount: Decimal | null
    discountPercentage: Decimal | null
    numberOfUses: number | null
    startDate: Date | null
    expirationDate: Date | null
    termsAndConditions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: number | null
    couponCode: string | null
    discountAmount: Decimal | null
    discountPercentage: Decimal | null
    numberOfUses: number | null
    startDate: Date | null
    expirationDate: Date | null
    termsAndConditions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    couponCode: number
    discountAmount: number
    discountPercentage: number
    numberOfUses: number
    startDate: number
    expirationDate: number
    termsAndConditions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    id?: true
    discountAmount?: true
    discountPercentage?: true
    numberOfUses?: true
  }

  export type CouponSumAggregateInputType = {
    id?: true
    discountAmount?: true
    discountPercentage?: true
    numberOfUses?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    couponCode?: true
    discountAmount?: true
    discountPercentage?: true
    numberOfUses?: true
    startDate?: true
    expirationDate?: true
    termsAndConditions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    couponCode?: true
    discountAmount?: true
    discountPercentage?: true
    numberOfUses?: true
    startDate?: true
    expirationDate?: true
    termsAndConditions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    couponCode?: true
    discountAmount?: true
    discountPercentage?: true
    numberOfUses?: true
    startDate?: true
    expirationDate?: true
    termsAndConditions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: number
    couponCode: string
    discountAmount: Decimal
    discountPercentage: Decimal
    numberOfUses: number
    startDate: Date
    expirationDate: Date | null
    termsAndConditions: string | null
    createdAt: Date
    updatedAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponCode?: boolean
    discountAmount?: boolean
    discountPercentage?: boolean
    numberOfUses?: boolean
    startDate?: boolean
    expirationDate?: boolean
    termsAndConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userCoupon?: boolean | Coupon$userCouponArgs<ExtArgs>
    envoiCoupon?: boolean | Coupon$envoiCouponArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponCode?: boolean
    discountAmount?: boolean
    discountPercentage?: boolean
    numberOfUses?: boolean
    startDate?: boolean
    expirationDate?: boolean
    termsAndConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponCode?: boolean
    discountAmount?: boolean
    discountPercentage?: boolean
    numberOfUses?: boolean
    startDate?: boolean
    expirationDate?: boolean
    termsAndConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    couponCode?: boolean
    discountAmount?: boolean
    discountPercentage?: boolean
    numberOfUses?: boolean
    startDate?: boolean
    expirationDate?: boolean
    termsAndConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "couponCode" | "discountAmount" | "discountPercentage" | "numberOfUses" | "startDate" | "expirationDate" | "termsAndConditions" | "createdAt" | "updatedAt", ExtArgs["result"]["coupon"]>
  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCoupon?: boolean | Coupon$userCouponArgs<ExtArgs>
    envoiCoupon?: boolean | Coupon$envoiCouponArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      userCoupon: Prisma.$UserCouponPayload<ExtArgs>[]
      envoiCoupon: Prisma.$EnvoiCouponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      couponCode: string
      discountAmount: Prisma.Decimal
      discountPercentage: Prisma.Decimal
      numberOfUses: number
      startDate: Date
      expirationDate: Date | null
      termsAndConditions: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {CouponUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouponUpdateManyAndReturnArgs>(args: SelectSubset<T, CouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userCoupon<T extends Coupon$userCouponArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$userCouponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    envoiCoupon<T extends Coupon$envoiCouponArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$envoiCouponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'Int'>
    readonly couponCode: FieldRef<"Coupon", 'String'>
    readonly discountAmount: FieldRef<"Coupon", 'Decimal'>
    readonly discountPercentage: FieldRef<"Coupon", 'Decimal'>
    readonly numberOfUses: FieldRef<"Coupon", 'Int'>
    readonly startDate: FieldRef<"Coupon", 'DateTime'>
    readonly expirationDate: FieldRef<"Coupon", 'DateTime'>
    readonly termsAndConditions: FieldRef<"Coupon", 'String'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon updateManyAndReturn
   */
  export type CouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number
  }

  /**
   * Coupon.userCoupon
   */
  export type Coupon$userCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    where?: UserCouponWhereInput
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    cursor?: UserCouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * Coupon.envoiCoupon
   */
  export type Coupon$envoiCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    where?: EnvoiCouponWhereInput
    orderBy?: EnvoiCouponOrderByWithRelationInput | EnvoiCouponOrderByWithRelationInput[]
    cursor?: EnvoiCouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvoiCouponScalarFieldEnum | EnvoiCouponScalarFieldEnum[]
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model UserCoupon
   */

  export type AggregateUserCoupon = {
    _count: UserCouponCountAggregateOutputType | null
    _avg: UserCouponAvgAggregateOutputType | null
    _sum: UserCouponSumAggregateOutputType | null
    _min: UserCouponMinAggregateOutputType | null
    _max: UserCouponMaxAggregateOutputType | null
  }

  export type UserCouponAvgAggregateOutputType = {
    userId: number | null
    couponId: number | null
  }

  export type UserCouponSumAggregateOutputType = {
    userId: number | null
    couponId: number | null
  }

  export type UserCouponMinAggregateOutputType = {
    userId: number | null
    couponId: number | null
  }

  export type UserCouponMaxAggregateOutputType = {
    userId: number | null
    couponId: number | null
  }

  export type UserCouponCountAggregateOutputType = {
    userId: number
    couponId: number
    _all: number
  }


  export type UserCouponAvgAggregateInputType = {
    userId?: true
    couponId?: true
  }

  export type UserCouponSumAggregateInputType = {
    userId?: true
    couponId?: true
  }

  export type UserCouponMinAggregateInputType = {
    userId?: true
    couponId?: true
  }

  export type UserCouponMaxAggregateInputType = {
    userId?: true
    couponId?: true
  }

  export type UserCouponCountAggregateInputType = {
    userId?: true
    couponId?: true
    _all?: true
  }

  export type UserCouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCoupon to aggregate.
     */
    where?: UserCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCoupons
    **/
    _count?: true | UserCouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCouponMaxAggregateInputType
  }

  export type GetUserCouponAggregateType<T extends UserCouponAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCoupon[P]>
      : GetScalarType<T[P], AggregateUserCoupon[P]>
  }




  export type UserCouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCouponWhereInput
    orderBy?: UserCouponOrderByWithAggregationInput | UserCouponOrderByWithAggregationInput[]
    by: UserCouponScalarFieldEnum[] | UserCouponScalarFieldEnum
    having?: UserCouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCouponCountAggregateInputType | true
    _avg?: UserCouponAvgAggregateInputType
    _sum?: UserCouponSumAggregateInputType
    _min?: UserCouponMinAggregateInputType
    _max?: UserCouponMaxAggregateInputType
  }

  export type UserCouponGroupByOutputType = {
    userId: number
    couponId: number
    _count: UserCouponCountAggregateOutputType | null
    _avg: UserCouponAvgAggregateOutputType | null
    _sum: UserCouponSumAggregateOutputType | null
    _min: UserCouponMinAggregateOutputType | null
    _max: UserCouponMaxAggregateOutputType | null
  }

  type GetUserCouponGroupByPayload<T extends UserCouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCouponGroupByOutputType[P]>
            : GetScalarType<T[P], UserCouponGroupByOutputType[P]>
        }
      >
    >


  export type UserCouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    couponId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCoupon"]>

  export type UserCouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    couponId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCoupon"]>

  export type UserCouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    couponId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCoupon"]>

  export type UserCouponSelectScalar = {
    userId?: boolean
    couponId?: boolean
  }

  export type UserCouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "couponId", ExtArgs["result"]["userCoupon"]>
  export type UserCouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }
  export type UserCouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }
  export type UserCouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }

  export type $UserCouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCoupon"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coupon: Prisma.$CouponPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      couponId: number
    }, ExtArgs["result"]["userCoupon"]>
    composites: {}
  }

  type UserCouponGetPayload<S extends boolean | null | undefined | UserCouponDefaultArgs> = $Result.GetResult<Prisma.$UserCouponPayload, S>

  type UserCouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCouponCountAggregateInputType | true
    }

  export interface UserCouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCoupon'], meta: { name: 'UserCoupon' } }
    /**
     * Find zero or one UserCoupon that matches the filter.
     * @param {UserCouponFindUniqueArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCouponFindUniqueArgs>(args: SelectSubset<T, UserCouponFindUniqueArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCoupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCouponFindUniqueOrThrowArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCouponFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCoupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponFindFirstArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCouponFindFirstArgs>(args?: SelectSubset<T, UserCouponFindFirstArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCoupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponFindFirstOrThrowArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCouponFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCoupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCoupons
     * const userCoupons = await prisma.userCoupon.findMany()
     * 
     * // Get first 10 UserCoupons
     * const userCoupons = await prisma.userCoupon.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userCouponWithUserIdOnly = await prisma.userCoupon.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserCouponFindManyArgs>(args?: SelectSubset<T, UserCouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCoupon.
     * @param {UserCouponCreateArgs} args - Arguments to create a UserCoupon.
     * @example
     * // Create one UserCoupon
     * const UserCoupon = await prisma.userCoupon.create({
     *   data: {
     *     // ... data to create a UserCoupon
     *   }
     * })
     * 
     */
    create<T extends UserCouponCreateArgs>(args: SelectSubset<T, UserCouponCreateArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCoupons.
     * @param {UserCouponCreateManyArgs} args - Arguments to create many UserCoupons.
     * @example
     * // Create many UserCoupons
     * const userCoupon = await prisma.userCoupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCouponCreateManyArgs>(args?: SelectSubset<T, UserCouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCoupons and returns the data saved in the database.
     * @param {UserCouponCreateManyAndReturnArgs} args - Arguments to create many UserCoupons.
     * @example
     * // Create many UserCoupons
     * const userCoupon = await prisma.userCoupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCoupons and only return the `userId`
     * const userCouponWithUserIdOnly = await prisma.userCoupon.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCouponCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCoupon.
     * @param {UserCouponDeleteArgs} args - Arguments to delete one UserCoupon.
     * @example
     * // Delete one UserCoupon
     * const UserCoupon = await prisma.userCoupon.delete({
     *   where: {
     *     // ... filter to delete one UserCoupon
     *   }
     * })
     * 
     */
    delete<T extends UserCouponDeleteArgs>(args: SelectSubset<T, UserCouponDeleteArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCoupon.
     * @param {UserCouponUpdateArgs} args - Arguments to update one UserCoupon.
     * @example
     * // Update one UserCoupon
     * const userCoupon = await prisma.userCoupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCouponUpdateArgs>(args: SelectSubset<T, UserCouponUpdateArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCoupons.
     * @param {UserCouponDeleteManyArgs} args - Arguments to filter UserCoupons to delete.
     * @example
     * // Delete a few UserCoupons
     * const { count } = await prisma.userCoupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCouponDeleteManyArgs>(args?: SelectSubset<T, UserCouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCoupons
     * const userCoupon = await prisma.userCoupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCouponUpdateManyArgs>(args: SelectSubset<T, UserCouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCoupons and returns the data updated in the database.
     * @param {UserCouponUpdateManyAndReturnArgs} args - Arguments to update many UserCoupons.
     * @example
     * // Update many UserCoupons
     * const userCoupon = await prisma.userCoupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCoupons and only return the `userId`
     * const userCouponWithUserIdOnly = await prisma.userCoupon.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCouponUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCoupon.
     * @param {UserCouponUpsertArgs} args - Arguments to update or create a UserCoupon.
     * @example
     * // Update or create a UserCoupon
     * const userCoupon = await prisma.userCoupon.upsert({
     *   create: {
     *     // ... data to create a UserCoupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCoupon we want to update
     *   }
     * })
     */
    upsert<T extends UserCouponUpsertArgs>(args: SelectSubset<T, UserCouponUpsertArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponCountArgs} args - Arguments to filter UserCoupons to count.
     * @example
     * // Count the number of UserCoupons
     * const count = await prisma.userCoupon.count({
     *   where: {
     *     // ... the filter for the UserCoupons we want to count
     *   }
     * })
    **/
    count<T extends UserCouponCountArgs>(
      args?: Subset<T, UserCouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCouponAggregateArgs>(args: Subset<T, UserCouponAggregateArgs>): Prisma.PrismaPromise<GetUserCouponAggregateType<T>>

    /**
     * Group by UserCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCouponGroupByArgs['orderBy'] }
        : { orderBy?: UserCouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCoupon model
   */
  readonly fields: UserCouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCoupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coupon<T extends CouponDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CouponDefaultArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCoupon model
   */
  interface UserCouponFieldRefs {
    readonly userId: FieldRef<"UserCoupon", 'Int'>
    readonly couponId: FieldRef<"UserCoupon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserCoupon findUnique
   */
  export type UserCouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupon to fetch.
     */
    where: UserCouponWhereUniqueInput
  }

  /**
   * UserCoupon findUniqueOrThrow
   */
  export type UserCouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupon to fetch.
     */
    where: UserCouponWhereUniqueInput
  }

  /**
   * UserCoupon findFirst
   */
  export type UserCouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupon to fetch.
     */
    where?: UserCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCoupons.
     */
    cursor?: UserCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCoupons.
     */
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * UserCoupon findFirstOrThrow
   */
  export type UserCouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupon to fetch.
     */
    where?: UserCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCoupons.
     */
    cursor?: UserCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCoupons.
     */
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * UserCoupon findMany
   */
  export type UserCouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupons to fetch.
     */
    where?: UserCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCoupons.
     */
    cursor?: UserCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCoupons.
     */
    skip?: number
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * UserCoupon create
   */
  export type UserCouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCoupon.
     */
    data: XOR<UserCouponCreateInput, UserCouponUncheckedCreateInput>
  }

  /**
   * UserCoupon createMany
   */
  export type UserCouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCoupons.
     */
    data: UserCouponCreateManyInput | UserCouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCoupon createManyAndReturn
   */
  export type UserCouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * The data used to create many UserCoupons.
     */
    data: UserCouponCreateManyInput | UserCouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCoupon update
   */
  export type UserCouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCoupon.
     */
    data: XOR<UserCouponUpdateInput, UserCouponUncheckedUpdateInput>
    /**
     * Choose, which UserCoupon to update.
     */
    where: UserCouponWhereUniqueInput
  }

  /**
   * UserCoupon updateMany
   */
  export type UserCouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCoupons.
     */
    data: XOR<UserCouponUpdateManyMutationInput, UserCouponUncheckedUpdateManyInput>
    /**
     * Filter which UserCoupons to update
     */
    where?: UserCouponWhereInput
    /**
     * Limit how many UserCoupons to update.
     */
    limit?: number
  }

  /**
   * UserCoupon updateManyAndReturn
   */
  export type UserCouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * The data used to update UserCoupons.
     */
    data: XOR<UserCouponUpdateManyMutationInput, UserCouponUncheckedUpdateManyInput>
    /**
     * Filter which UserCoupons to update
     */
    where?: UserCouponWhereInput
    /**
     * Limit how many UserCoupons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCoupon upsert
   */
  export type UserCouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCoupon to update in case it exists.
     */
    where: UserCouponWhereUniqueInput
    /**
     * In case the UserCoupon found by the `where` argument doesn't exist, create a new UserCoupon with this data.
     */
    create: XOR<UserCouponCreateInput, UserCouponUncheckedCreateInput>
    /**
     * In case the UserCoupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCouponUpdateInput, UserCouponUncheckedUpdateInput>
  }

  /**
   * UserCoupon delete
   */
  export type UserCouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter which UserCoupon to delete.
     */
    where: UserCouponWhereUniqueInput
  }

  /**
   * UserCoupon deleteMany
   */
  export type UserCouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCoupons to delete
     */
    where?: UserCouponWhereInput
    /**
     * Limit how many UserCoupons to delete.
     */
    limit?: number
  }

  /**
   * UserCoupon without action
   */
  export type UserCouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
  }


  /**
   * Model Transport
   */

  export type AggregateTransport = {
    _count: TransportCountAggregateOutputType | null
    _avg: TransportAvgAggregateOutputType | null
    _sum: TransportSumAggregateOutputType | null
    _min: TransportMinAggregateOutputType | null
    _max: TransportMaxAggregateOutputType | null
  }

  export type TransportAvgAggregateOutputType = {
    id: number | null
    baseVolume: Decimal | null
    baseWeight: Decimal | null
    currentVolume: Decimal | null
    currentWeight: Decimal | null
    agencyId: number | null
  }

  export type TransportSumAggregateOutputType = {
    id: number | null
    baseVolume: Decimal | null
    baseWeight: Decimal | null
    currentVolume: Decimal | null
    currentWeight: Decimal | null
    agencyId: number | null
  }

  export type TransportMinAggregateOutputType = {
    id: number | null
    number: string | null
    baseVolume: Decimal | null
    baseWeight: Decimal | null
    currentVolume: Decimal | null
    currentWeight: Decimal | null
    isAvailable: boolean | null
    agencyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransportMaxAggregateOutputType = {
    id: number | null
    number: string | null
    baseVolume: Decimal | null
    baseWeight: Decimal | null
    currentVolume: Decimal | null
    currentWeight: Decimal | null
    isAvailable: boolean | null
    agencyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransportCountAggregateOutputType = {
    id: number
    number: number
    baseVolume: number
    baseWeight: number
    currentVolume: number
    currentWeight: number
    isAvailable: number
    agencyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransportAvgAggregateInputType = {
    id?: true
    baseVolume?: true
    baseWeight?: true
    currentVolume?: true
    currentWeight?: true
    agencyId?: true
  }

  export type TransportSumAggregateInputType = {
    id?: true
    baseVolume?: true
    baseWeight?: true
    currentVolume?: true
    currentWeight?: true
    agencyId?: true
  }

  export type TransportMinAggregateInputType = {
    id?: true
    number?: true
    baseVolume?: true
    baseWeight?: true
    currentVolume?: true
    currentWeight?: true
    isAvailable?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransportMaxAggregateInputType = {
    id?: true
    number?: true
    baseVolume?: true
    baseWeight?: true
    currentVolume?: true
    currentWeight?: true
    isAvailable?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransportCountAggregateInputType = {
    id?: true
    number?: true
    baseVolume?: true
    baseWeight?: true
    currentVolume?: true
    currentWeight?: true
    isAvailable?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transport to aggregate.
     */
    where?: TransportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transports to fetch.
     */
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transports
    **/
    _count?: true | TransportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransportMaxAggregateInputType
  }

  export type GetTransportAggregateType<T extends TransportAggregateArgs> = {
        [P in keyof T & keyof AggregateTransport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransport[P]>
      : GetScalarType<T[P], AggregateTransport[P]>
  }




  export type TransportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportWhereInput
    orderBy?: TransportOrderByWithAggregationInput | TransportOrderByWithAggregationInput[]
    by: TransportScalarFieldEnum[] | TransportScalarFieldEnum
    having?: TransportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransportCountAggregateInputType | true
    _avg?: TransportAvgAggregateInputType
    _sum?: TransportSumAggregateInputType
    _min?: TransportMinAggregateInputType
    _max?: TransportMaxAggregateInputType
  }

  export type TransportGroupByOutputType = {
    id: number
    number: string
    baseVolume: Decimal
    baseWeight: Decimal
    currentVolume: Decimal
    currentWeight: Decimal
    isAvailable: boolean
    agencyId: number | null
    createdAt: Date
    updatedAt: Date
    _count: TransportCountAggregateOutputType | null
    _avg: TransportAvgAggregateOutputType | null
    _sum: TransportSumAggregateOutputType | null
    _min: TransportMinAggregateOutputType | null
    _max: TransportMaxAggregateOutputType | null
  }

  type GetTransportGroupByPayload<T extends TransportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransportGroupByOutputType[P]>
            : GetScalarType<T[P], TransportGroupByOutputType[P]>
        }
      >
    >


  export type TransportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    baseVolume?: boolean
    baseWeight?: boolean
    currentVolume?: boolean
    currentWeight?: boolean
    isAvailable?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envois?: boolean | Transport$envoisArgs<ExtArgs>
    transportSchedules?: boolean | Transport$transportSchedulesArgs<ExtArgs>
    agency?: boolean | Transport$agencyArgs<ExtArgs>
    _count?: boolean | TransportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transport"]>

  export type TransportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    baseVolume?: boolean
    baseWeight?: boolean
    currentVolume?: boolean
    currentWeight?: boolean
    isAvailable?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | Transport$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["transport"]>

  export type TransportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    baseVolume?: boolean
    baseWeight?: boolean
    currentVolume?: boolean
    currentWeight?: boolean
    isAvailable?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | Transport$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["transport"]>

  export type TransportSelectScalar = {
    id?: boolean
    number?: boolean
    baseVolume?: boolean
    baseWeight?: boolean
    currentVolume?: boolean
    currentWeight?: boolean
    isAvailable?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "baseVolume" | "baseWeight" | "currentVolume" | "currentWeight" | "isAvailable" | "agencyId" | "createdAt" | "updatedAt", ExtArgs["result"]["transport"]>
  export type TransportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envois?: boolean | Transport$envoisArgs<ExtArgs>
    transportSchedules?: boolean | Transport$transportSchedulesArgs<ExtArgs>
    agency?: boolean | Transport$agencyArgs<ExtArgs>
    _count?: boolean | TransportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | Transport$agencyArgs<ExtArgs>
  }
  export type TransportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | Transport$agencyArgs<ExtArgs>
  }

  export type $TransportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transport"
    objects: {
      envois: Prisma.$EnvoiPayload<ExtArgs>[]
      transportSchedules: Prisma.$TransportSchedulePayload<ExtArgs>[]
      agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      baseVolume: Prisma.Decimal
      baseWeight: Prisma.Decimal
      currentVolume: Prisma.Decimal
      currentWeight: Prisma.Decimal
      isAvailable: boolean
      agencyId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transport"]>
    composites: {}
  }

  type TransportGetPayload<S extends boolean | null | undefined | TransportDefaultArgs> = $Result.GetResult<Prisma.$TransportPayload, S>

  type TransportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransportCountAggregateInputType | true
    }

  export interface TransportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transport'], meta: { name: 'Transport' } }
    /**
     * Find zero or one Transport that matches the filter.
     * @param {TransportFindUniqueArgs} args - Arguments to find a Transport
     * @example
     * // Get one Transport
     * const transport = await prisma.transport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransportFindUniqueArgs>(args: SelectSubset<T, TransportFindUniqueArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransportFindUniqueOrThrowArgs} args - Arguments to find a Transport
     * @example
     * // Get one Transport
     * const transport = await prisma.transport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransportFindUniqueOrThrowArgs>(args: SelectSubset<T, TransportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportFindFirstArgs} args - Arguments to find a Transport
     * @example
     * // Get one Transport
     * const transport = await prisma.transport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransportFindFirstArgs>(args?: SelectSubset<T, TransportFindFirstArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportFindFirstOrThrowArgs} args - Arguments to find a Transport
     * @example
     * // Get one Transport
     * const transport = await prisma.transport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransportFindFirstOrThrowArgs>(args?: SelectSubset<T, TransportFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transports
     * const transports = await prisma.transport.findMany()
     * 
     * // Get first 10 Transports
     * const transports = await prisma.transport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transportWithIdOnly = await prisma.transport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransportFindManyArgs>(args?: SelectSubset<T, TransportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transport.
     * @param {TransportCreateArgs} args - Arguments to create a Transport.
     * @example
     * // Create one Transport
     * const Transport = await prisma.transport.create({
     *   data: {
     *     // ... data to create a Transport
     *   }
     * })
     * 
     */
    create<T extends TransportCreateArgs>(args: SelectSubset<T, TransportCreateArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transports.
     * @param {TransportCreateManyArgs} args - Arguments to create many Transports.
     * @example
     * // Create many Transports
     * const transport = await prisma.transport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransportCreateManyArgs>(args?: SelectSubset<T, TransportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transports and returns the data saved in the database.
     * @param {TransportCreateManyAndReturnArgs} args - Arguments to create many Transports.
     * @example
     * // Create many Transports
     * const transport = await prisma.transport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transports and only return the `id`
     * const transportWithIdOnly = await prisma.transport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransportCreateManyAndReturnArgs>(args?: SelectSubset<T, TransportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transport.
     * @param {TransportDeleteArgs} args - Arguments to delete one Transport.
     * @example
     * // Delete one Transport
     * const Transport = await prisma.transport.delete({
     *   where: {
     *     // ... filter to delete one Transport
     *   }
     * })
     * 
     */
    delete<T extends TransportDeleteArgs>(args: SelectSubset<T, TransportDeleteArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transport.
     * @param {TransportUpdateArgs} args - Arguments to update one Transport.
     * @example
     * // Update one Transport
     * const transport = await prisma.transport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransportUpdateArgs>(args: SelectSubset<T, TransportUpdateArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transports.
     * @param {TransportDeleteManyArgs} args - Arguments to filter Transports to delete.
     * @example
     * // Delete a few Transports
     * const { count } = await prisma.transport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransportDeleteManyArgs>(args?: SelectSubset<T, TransportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transports
     * const transport = await prisma.transport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransportUpdateManyArgs>(args: SelectSubset<T, TransportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transports and returns the data updated in the database.
     * @param {TransportUpdateManyAndReturnArgs} args - Arguments to update many Transports.
     * @example
     * // Update many Transports
     * const transport = await prisma.transport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transports and only return the `id`
     * const transportWithIdOnly = await prisma.transport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransportUpdateManyAndReturnArgs>(args: SelectSubset<T, TransportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transport.
     * @param {TransportUpsertArgs} args - Arguments to update or create a Transport.
     * @example
     * // Update or create a Transport
     * const transport = await prisma.transport.upsert({
     *   create: {
     *     // ... data to create a Transport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transport we want to update
     *   }
     * })
     */
    upsert<T extends TransportUpsertArgs>(args: SelectSubset<T, TransportUpsertArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportCountArgs} args - Arguments to filter Transports to count.
     * @example
     * // Count the number of Transports
     * const count = await prisma.transport.count({
     *   where: {
     *     // ... the filter for the Transports we want to count
     *   }
     * })
    **/
    count<T extends TransportCountArgs>(
      args?: Subset<T, TransportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransportAggregateArgs>(args: Subset<T, TransportAggregateArgs>): Prisma.PrismaPromise<GetTransportAggregateType<T>>

    /**
     * Group by Transport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransportGroupByArgs['orderBy'] }
        : { orderBy?: TransportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transport model
   */
  readonly fields: TransportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    envois<T extends Transport$envoisArgs<ExtArgs> = {}>(args?: Subset<T, Transport$envoisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transportSchedules<T extends Transport$transportSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Transport$transportSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agency<T extends Transport$agencyArgs<ExtArgs> = {}>(args?: Subset<T, Transport$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transport model
   */
  interface TransportFieldRefs {
    readonly id: FieldRef<"Transport", 'Int'>
    readonly number: FieldRef<"Transport", 'String'>
    readonly baseVolume: FieldRef<"Transport", 'Decimal'>
    readonly baseWeight: FieldRef<"Transport", 'Decimal'>
    readonly currentVolume: FieldRef<"Transport", 'Decimal'>
    readonly currentWeight: FieldRef<"Transport", 'Decimal'>
    readonly isAvailable: FieldRef<"Transport", 'Boolean'>
    readonly agencyId: FieldRef<"Transport", 'Int'>
    readonly createdAt: FieldRef<"Transport", 'DateTime'>
    readonly updatedAt: FieldRef<"Transport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transport findUnique
   */
  export type TransportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transport to fetch.
     */
    where: TransportWhereUniqueInput
  }

  /**
   * Transport findUniqueOrThrow
   */
  export type TransportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transport to fetch.
     */
    where: TransportWhereUniqueInput
  }

  /**
   * Transport findFirst
   */
  export type TransportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transport to fetch.
     */
    where?: TransportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transports to fetch.
     */
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transports.
     */
    cursor?: TransportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transports.
     */
    distinct?: TransportScalarFieldEnum | TransportScalarFieldEnum[]
  }

  /**
   * Transport findFirstOrThrow
   */
  export type TransportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transport to fetch.
     */
    where?: TransportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transports to fetch.
     */
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transports.
     */
    cursor?: TransportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transports.
     */
    distinct?: TransportScalarFieldEnum | TransportScalarFieldEnum[]
  }

  /**
   * Transport findMany
   */
  export type TransportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transports to fetch.
     */
    where?: TransportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transports to fetch.
     */
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transports.
     */
    cursor?: TransportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transports.
     */
    skip?: number
    distinct?: TransportScalarFieldEnum | TransportScalarFieldEnum[]
  }

  /**
   * Transport create
   */
  export type TransportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * The data needed to create a Transport.
     */
    data: XOR<TransportCreateInput, TransportUncheckedCreateInput>
  }

  /**
   * Transport createMany
   */
  export type TransportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transports.
     */
    data: TransportCreateManyInput | TransportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transport createManyAndReturn
   */
  export type TransportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * The data used to create many Transports.
     */
    data: TransportCreateManyInput | TransportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transport update
   */
  export type TransportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * The data needed to update a Transport.
     */
    data: XOR<TransportUpdateInput, TransportUncheckedUpdateInput>
    /**
     * Choose, which Transport to update.
     */
    where: TransportWhereUniqueInput
  }

  /**
   * Transport updateMany
   */
  export type TransportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transports.
     */
    data: XOR<TransportUpdateManyMutationInput, TransportUncheckedUpdateManyInput>
    /**
     * Filter which Transports to update
     */
    where?: TransportWhereInput
    /**
     * Limit how many Transports to update.
     */
    limit?: number
  }

  /**
   * Transport updateManyAndReturn
   */
  export type TransportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * The data used to update Transports.
     */
    data: XOR<TransportUpdateManyMutationInput, TransportUncheckedUpdateManyInput>
    /**
     * Filter which Transports to update
     */
    where?: TransportWhereInput
    /**
     * Limit how many Transports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transport upsert
   */
  export type TransportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * The filter to search for the Transport to update in case it exists.
     */
    where: TransportWhereUniqueInput
    /**
     * In case the Transport found by the `where` argument doesn't exist, create a new Transport with this data.
     */
    create: XOR<TransportCreateInput, TransportUncheckedCreateInput>
    /**
     * In case the Transport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransportUpdateInput, TransportUncheckedUpdateInput>
  }

  /**
   * Transport delete
   */
  export type TransportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter which Transport to delete.
     */
    where: TransportWhereUniqueInput
  }

  /**
   * Transport deleteMany
   */
  export type TransportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transports to delete
     */
    where?: TransportWhereInput
    /**
     * Limit how many Transports to delete.
     */
    limit?: number
  }

  /**
   * Transport.envois
   */
  export type Transport$envoisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    where?: EnvoiWhereInput
    orderBy?: EnvoiOrderByWithRelationInput | EnvoiOrderByWithRelationInput[]
    cursor?: EnvoiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvoiScalarFieldEnum | EnvoiScalarFieldEnum[]
  }

  /**
   * Transport.transportSchedules
   */
  export type Transport$transportSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    where?: TransportScheduleWhereInput
    orderBy?: TransportScheduleOrderByWithRelationInput | TransportScheduleOrderByWithRelationInput[]
    cursor?: TransportScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportScheduleScalarFieldEnum | TransportScheduleScalarFieldEnum[]
  }

  /**
   * Transport.agency
   */
  export type Transport$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Transport without action
   */
  export type TransportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
  }


  /**
   * Model Envoi
   */

  export type AggregateEnvoi = {
    _count: EnvoiCountAggregateOutputType | null
    _avg: EnvoiAvgAggregateOutputType | null
    _sum: EnvoiSumAggregateOutputType | null
    _min: EnvoiMinAggregateOutputType | null
    _max: EnvoiMaxAggregateOutputType | null
  }

  export type EnvoiAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    destinataireId: number | null
    transportId: number | null
    departureAgencyId: number | null
    arrivalAgencyId: number | null
    totalWeight: number | null
    totalVolume: number | null
    totalPrice: number | null
  }

  export type EnvoiSumAggregateOutputType = {
    id: number | null
    userId: number | null
    destinataireId: number | null
    transportId: number | null
    departureAgencyId: number | null
    arrivalAgencyId: number | null
    totalWeight: number | null
    totalVolume: number | null
    totalPrice: number | null
  }

  export type EnvoiMinAggregateOutputType = {
    id: number | null
    trackingNumber: string | null
    qrCodeUrl: string | null
    userId: number | null
    destinataireId: number | null
    transportId: number | null
    departureAgencyId: number | null
    arrivalAgencyId: number | null
    simulationStatus: $Enums.SimulationStatus | null
    envoiStatus: $Enums.EnvoiStatus | null
    totalWeight: number | null
    totalVolume: number | null
    totalPrice: number | null
    paid: boolean | null
    departureDate: Date | null
    arrivalDate: Date | null
    verificationToken: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnvoiMaxAggregateOutputType = {
    id: number | null
    trackingNumber: string | null
    qrCodeUrl: string | null
    userId: number | null
    destinataireId: number | null
    transportId: number | null
    departureAgencyId: number | null
    arrivalAgencyId: number | null
    simulationStatus: $Enums.SimulationStatus | null
    envoiStatus: $Enums.EnvoiStatus | null
    totalWeight: number | null
    totalVolume: number | null
    totalPrice: number | null
    paid: boolean | null
    departureDate: Date | null
    arrivalDate: Date | null
    verificationToken: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnvoiCountAggregateOutputType = {
    id: number
    trackingNumber: number
    qrCodeUrl: number
    userId: number
    destinataireId: number
    transportId: number
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus: number
    envoiStatus: number
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid: number
    departureDate: number
    arrivalDate: number
    verificationToken: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnvoiAvgAggregateInputType = {
    id?: true
    userId?: true
    destinataireId?: true
    transportId?: true
    departureAgencyId?: true
    arrivalAgencyId?: true
    totalWeight?: true
    totalVolume?: true
    totalPrice?: true
  }

  export type EnvoiSumAggregateInputType = {
    id?: true
    userId?: true
    destinataireId?: true
    transportId?: true
    departureAgencyId?: true
    arrivalAgencyId?: true
    totalWeight?: true
    totalVolume?: true
    totalPrice?: true
  }

  export type EnvoiMinAggregateInputType = {
    id?: true
    trackingNumber?: true
    qrCodeUrl?: true
    userId?: true
    destinataireId?: true
    transportId?: true
    departureAgencyId?: true
    arrivalAgencyId?: true
    simulationStatus?: true
    envoiStatus?: true
    totalWeight?: true
    totalVolume?: true
    totalPrice?: true
    paid?: true
    departureDate?: true
    arrivalDate?: true
    verificationToken?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnvoiMaxAggregateInputType = {
    id?: true
    trackingNumber?: true
    qrCodeUrl?: true
    userId?: true
    destinataireId?: true
    transportId?: true
    departureAgencyId?: true
    arrivalAgencyId?: true
    simulationStatus?: true
    envoiStatus?: true
    totalWeight?: true
    totalVolume?: true
    totalPrice?: true
    paid?: true
    departureDate?: true
    arrivalDate?: true
    verificationToken?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnvoiCountAggregateInputType = {
    id?: true
    trackingNumber?: true
    qrCodeUrl?: true
    userId?: true
    destinataireId?: true
    transportId?: true
    departureAgencyId?: true
    arrivalAgencyId?: true
    simulationStatus?: true
    envoiStatus?: true
    totalWeight?: true
    totalVolume?: true
    totalPrice?: true
    paid?: true
    departureDate?: true
    arrivalDate?: true
    verificationToken?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnvoiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Envoi to aggregate.
     */
    where?: EnvoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envois to fetch.
     */
    orderBy?: EnvoiOrderByWithRelationInput | EnvoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Envois
    **/
    _count?: true | EnvoiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnvoiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnvoiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvoiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvoiMaxAggregateInputType
  }

  export type GetEnvoiAggregateType<T extends EnvoiAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvoi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvoi[P]>
      : GetScalarType<T[P], AggregateEnvoi[P]>
  }




  export type EnvoiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvoiWhereInput
    orderBy?: EnvoiOrderByWithAggregationInput | EnvoiOrderByWithAggregationInput[]
    by: EnvoiScalarFieldEnum[] | EnvoiScalarFieldEnum
    having?: EnvoiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvoiCountAggregateInputType | true
    _avg?: EnvoiAvgAggregateInputType
    _sum?: EnvoiSumAggregateInputType
    _min?: EnvoiMinAggregateInputType
    _max?: EnvoiMaxAggregateInputType
  }

  export type EnvoiGroupByOutputType = {
    id: number
    trackingNumber: string | null
    qrCodeUrl: string | null
    userId: number | null
    destinataireId: number | null
    transportId: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus: $Enums.SimulationStatus
    envoiStatus: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid: boolean
    departureDate: Date
    arrivalDate: Date
    verificationToken: string
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: EnvoiCountAggregateOutputType | null
    _avg: EnvoiAvgAggregateOutputType | null
    _sum: EnvoiSumAggregateOutputType | null
    _min: EnvoiMinAggregateOutputType | null
    _max: EnvoiMaxAggregateOutputType | null
  }

  type GetEnvoiGroupByPayload<T extends EnvoiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvoiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvoiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvoiGroupByOutputType[P]>
            : GetScalarType<T[P], EnvoiGroupByOutputType[P]>
        }
      >
    >


  export type EnvoiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingNumber?: boolean
    qrCodeUrl?: boolean
    userId?: boolean
    destinataireId?: boolean
    transportId?: boolean
    departureAgencyId?: boolean
    arrivalAgencyId?: boolean
    simulationStatus?: boolean
    envoiStatus?: boolean
    totalWeight?: boolean
    totalVolume?: boolean
    totalPrice?: boolean
    paid?: boolean
    departureDate?: boolean
    arrivalDate?: boolean
    verificationToken?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    arrivalAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    departureAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    transport?: boolean | Envoi$transportArgs<ExtArgs>
    destinataire?: boolean | Envoi$destinataireArgs<ExtArgs>
    client?: boolean | Envoi$clientArgs<ExtArgs>
    envoiCoupons?: boolean | Envoi$envoiCouponsArgs<ExtArgs>
    parcels?: boolean | Envoi$parcelsArgs<ExtArgs>
    appointments?: boolean | Envoi$appointmentsArgs<ExtArgs>
    notifications?: boolean | Envoi$notificationsArgs<ExtArgs>
    payment?: boolean | Envoi$paymentArgs<ExtArgs>
    trackingEvents?: boolean | Envoi$trackingEventsArgs<ExtArgs>
    _count?: boolean | EnvoiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["envoi"]>

  export type EnvoiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingNumber?: boolean
    qrCodeUrl?: boolean
    userId?: boolean
    destinataireId?: boolean
    transportId?: boolean
    departureAgencyId?: boolean
    arrivalAgencyId?: boolean
    simulationStatus?: boolean
    envoiStatus?: boolean
    totalWeight?: boolean
    totalVolume?: boolean
    totalPrice?: boolean
    paid?: boolean
    departureDate?: boolean
    arrivalDate?: boolean
    verificationToken?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    arrivalAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    departureAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    transport?: boolean | Envoi$transportArgs<ExtArgs>
    destinataire?: boolean | Envoi$destinataireArgs<ExtArgs>
    client?: boolean | Envoi$clientArgs<ExtArgs>
  }, ExtArgs["result"]["envoi"]>

  export type EnvoiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingNumber?: boolean
    qrCodeUrl?: boolean
    userId?: boolean
    destinataireId?: boolean
    transportId?: boolean
    departureAgencyId?: boolean
    arrivalAgencyId?: boolean
    simulationStatus?: boolean
    envoiStatus?: boolean
    totalWeight?: boolean
    totalVolume?: boolean
    totalPrice?: boolean
    paid?: boolean
    departureDate?: boolean
    arrivalDate?: boolean
    verificationToken?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    arrivalAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    departureAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    transport?: boolean | Envoi$transportArgs<ExtArgs>
    destinataire?: boolean | Envoi$destinataireArgs<ExtArgs>
    client?: boolean | Envoi$clientArgs<ExtArgs>
  }, ExtArgs["result"]["envoi"]>

  export type EnvoiSelectScalar = {
    id?: boolean
    trackingNumber?: boolean
    qrCodeUrl?: boolean
    userId?: boolean
    destinataireId?: boolean
    transportId?: boolean
    departureAgencyId?: boolean
    arrivalAgencyId?: boolean
    simulationStatus?: boolean
    envoiStatus?: boolean
    totalWeight?: boolean
    totalVolume?: boolean
    totalPrice?: boolean
    paid?: boolean
    departureDate?: boolean
    arrivalDate?: boolean
    verificationToken?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EnvoiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trackingNumber" | "qrCodeUrl" | "userId" | "destinataireId" | "transportId" | "departureAgencyId" | "arrivalAgencyId" | "simulationStatus" | "envoiStatus" | "totalWeight" | "totalVolume" | "totalPrice" | "paid" | "departureDate" | "arrivalDate" | "verificationToken" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["envoi"]>
  export type EnvoiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrivalAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    departureAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    transport?: boolean | Envoi$transportArgs<ExtArgs>
    destinataire?: boolean | Envoi$destinataireArgs<ExtArgs>
    client?: boolean | Envoi$clientArgs<ExtArgs>
    envoiCoupons?: boolean | Envoi$envoiCouponsArgs<ExtArgs>
    parcels?: boolean | Envoi$parcelsArgs<ExtArgs>
    appointments?: boolean | Envoi$appointmentsArgs<ExtArgs>
    notifications?: boolean | Envoi$notificationsArgs<ExtArgs>
    payment?: boolean | Envoi$paymentArgs<ExtArgs>
    trackingEvents?: boolean | Envoi$trackingEventsArgs<ExtArgs>
    _count?: boolean | EnvoiCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnvoiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrivalAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    departureAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    transport?: boolean | Envoi$transportArgs<ExtArgs>
    destinataire?: boolean | Envoi$destinataireArgs<ExtArgs>
    client?: boolean | Envoi$clientArgs<ExtArgs>
  }
  export type EnvoiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrivalAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    departureAgency?: boolean | AgencyDefaultArgs<ExtArgs>
    transport?: boolean | Envoi$transportArgs<ExtArgs>
    destinataire?: boolean | Envoi$destinataireArgs<ExtArgs>
    client?: boolean | Envoi$clientArgs<ExtArgs>
  }

  export type $EnvoiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Envoi"
    objects: {
      arrivalAgency: Prisma.$AgencyPayload<ExtArgs>
      departureAgency: Prisma.$AgencyPayload<ExtArgs>
      transport: Prisma.$TransportPayload<ExtArgs> | null
      destinataire: Prisma.$UserPayload<ExtArgs> | null
      client: Prisma.$UserPayload<ExtArgs> | null
      envoiCoupons: Prisma.$EnvoiCouponPayload<ExtArgs>[]
      parcels: Prisma.$ParcelPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      trackingEvents: Prisma.$TrackingEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      trackingNumber: string | null
      qrCodeUrl: string | null
      userId: number | null
      destinataireId: number | null
      transportId: number | null
      departureAgencyId: number
      arrivalAgencyId: number
      simulationStatus: $Enums.SimulationStatus
      envoiStatus: $Enums.EnvoiStatus
      totalWeight: number
      totalVolume: number
      totalPrice: number
      paid: boolean
      departureDate: Date
      arrivalDate: Date
      verificationToken: string
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["envoi"]>
    composites: {}
  }

  type EnvoiGetPayload<S extends boolean | null | undefined | EnvoiDefaultArgs> = $Result.GetResult<Prisma.$EnvoiPayload, S>

  type EnvoiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnvoiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnvoiCountAggregateInputType | true
    }

  export interface EnvoiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Envoi'], meta: { name: 'Envoi' } }
    /**
     * Find zero or one Envoi that matches the filter.
     * @param {EnvoiFindUniqueArgs} args - Arguments to find a Envoi
     * @example
     * // Get one Envoi
     * const envoi = await prisma.envoi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnvoiFindUniqueArgs>(args: SelectSubset<T, EnvoiFindUniqueArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Envoi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnvoiFindUniqueOrThrowArgs} args - Arguments to find a Envoi
     * @example
     * // Get one Envoi
     * const envoi = await prisma.envoi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnvoiFindUniqueOrThrowArgs>(args: SelectSubset<T, EnvoiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Envoi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiFindFirstArgs} args - Arguments to find a Envoi
     * @example
     * // Get one Envoi
     * const envoi = await prisma.envoi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnvoiFindFirstArgs>(args?: SelectSubset<T, EnvoiFindFirstArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Envoi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiFindFirstOrThrowArgs} args - Arguments to find a Envoi
     * @example
     * // Get one Envoi
     * const envoi = await prisma.envoi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnvoiFindFirstOrThrowArgs>(args?: SelectSubset<T, EnvoiFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Envois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Envois
     * const envois = await prisma.envoi.findMany()
     * 
     * // Get first 10 Envois
     * const envois = await prisma.envoi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const envoiWithIdOnly = await prisma.envoi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnvoiFindManyArgs>(args?: SelectSubset<T, EnvoiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Envoi.
     * @param {EnvoiCreateArgs} args - Arguments to create a Envoi.
     * @example
     * // Create one Envoi
     * const Envoi = await prisma.envoi.create({
     *   data: {
     *     // ... data to create a Envoi
     *   }
     * })
     * 
     */
    create<T extends EnvoiCreateArgs>(args: SelectSubset<T, EnvoiCreateArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Envois.
     * @param {EnvoiCreateManyArgs} args - Arguments to create many Envois.
     * @example
     * // Create many Envois
     * const envoi = await prisma.envoi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnvoiCreateManyArgs>(args?: SelectSubset<T, EnvoiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Envois and returns the data saved in the database.
     * @param {EnvoiCreateManyAndReturnArgs} args - Arguments to create many Envois.
     * @example
     * // Create many Envois
     * const envoi = await prisma.envoi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Envois and only return the `id`
     * const envoiWithIdOnly = await prisma.envoi.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnvoiCreateManyAndReturnArgs>(args?: SelectSubset<T, EnvoiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Envoi.
     * @param {EnvoiDeleteArgs} args - Arguments to delete one Envoi.
     * @example
     * // Delete one Envoi
     * const Envoi = await prisma.envoi.delete({
     *   where: {
     *     // ... filter to delete one Envoi
     *   }
     * })
     * 
     */
    delete<T extends EnvoiDeleteArgs>(args: SelectSubset<T, EnvoiDeleteArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Envoi.
     * @param {EnvoiUpdateArgs} args - Arguments to update one Envoi.
     * @example
     * // Update one Envoi
     * const envoi = await prisma.envoi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnvoiUpdateArgs>(args: SelectSubset<T, EnvoiUpdateArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Envois.
     * @param {EnvoiDeleteManyArgs} args - Arguments to filter Envois to delete.
     * @example
     * // Delete a few Envois
     * const { count } = await prisma.envoi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnvoiDeleteManyArgs>(args?: SelectSubset<T, EnvoiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Envois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Envois
     * const envoi = await prisma.envoi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnvoiUpdateManyArgs>(args: SelectSubset<T, EnvoiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Envois and returns the data updated in the database.
     * @param {EnvoiUpdateManyAndReturnArgs} args - Arguments to update many Envois.
     * @example
     * // Update many Envois
     * const envoi = await prisma.envoi.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Envois and only return the `id`
     * const envoiWithIdOnly = await prisma.envoi.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnvoiUpdateManyAndReturnArgs>(args: SelectSubset<T, EnvoiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Envoi.
     * @param {EnvoiUpsertArgs} args - Arguments to update or create a Envoi.
     * @example
     * // Update or create a Envoi
     * const envoi = await prisma.envoi.upsert({
     *   create: {
     *     // ... data to create a Envoi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Envoi we want to update
     *   }
     * })
     */
    upsert<T extends EnvoiUpsertArgs>(args: SelectSubset<T, EnvoiUpsertArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Envois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiCountArgs} args - Arguments to filter Envois to count.
     * @example
     * // Count the number of Envois
     * const count = await prisma.envoi.count({
     *   where: {
     *     // ... the filter for the Envois we want to count
     *   }
     * })
    **/
    count<T extends EnvoiCountArgs>(
      args?: Subset<T, EnvoiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvoiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Envoi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvoiAggregateArgs>(args: Subset<T, EnvoiAggregateArgs>): Prisma.PrismaPromise<GetEnvoiAggregateType<T>>

    /**
     * Group by Envoi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvoiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvoiGroupByArgs['orderBy'] }
        : { orderBy?: EnvoiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvoiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvoiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Envoi model
   */
  readonly fields: EnvoiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Envoi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnvoiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    arrivalAgency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    departureAgency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transport<T extends Envoi$transportArgs<ExtArgs> = {}>(args?: Subset<T, Envoi$transportArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    destinataire<T extends Envoi$destinataireArgs<ExtArgs> = {}>(args?: Subset<T, Envoi$destinataireArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends Envoi$clientArgs<ExtArgs> = {}>(args?: Subset<T, Envoi$clientArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    envoiCoupons<T extends Envoi$envoiCouponsArgs<ExtArgs> = {}>(args?: Subset<T, Envoi$envoiCouponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parcels<T extends Envoi$parcelsArgs<ExtArgs> = {}>(args?: Subset<T, Envoi$parcelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Envoi$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Envoi$appointmentsArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends Envoi$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Envoi$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends Envoi$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Envoi$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    trackingEvents<T extends Envoi$trackingEventsArgs<ExtArgs> = {}>(args?: Subset<T, Envoi$trackingEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Envoi model
   */
  interface EnvoiFieldRefs {
    readonly id: FieldRef<"Envoi", 'Int'>
    readonly trackingNumber: FieldRef<"Envoi", 'String'>
    readonly qrCodeUrl: FieldRef<"Envoi", 'String'>
    readonly userId: FieldRef<"Envoi", 'Int'>
    readonly destinataireId: FieldRef<"Envoi", 'Int'>
    readonly transportId: FieldRef<"Envoi", 'Int'>
    readonly departureAgencyId: FieldRef<"Envoi", 'Int'>
    readonly arrivalAgencyId: FieldRef<"Envoi", 'Int'>
    readonly simulationStatus: FieldRef<"Envoi", 'SimulationStatus'>
    readonly envoiStatus: FieldRef<"Envoi", 'EnvoiStatus'>
    readonly totalWeight: FieldRef<"Envoi", 'Float'>
    readonly totalVolume: FieldRef<"Envoi", 'Float'>
    readonly totalPrice: FieldRef<"Envoi", 'Float'>
    readonly paid: FieldRef<"Envoi", 'Boolean'>
    readonly departureDate: FieldRef<"Envoi", 'DateTime'>
    readonly arrivalDate: FieldRef<"Envoi", 'DateTime'>
    readonly verificationToken: FieldRef<"Envoi", 'String'>
    readonly comment: FieldRef<"Envoi", 'String'>
    readonly createdAt: FieldRef<"Envoi", 'DateTime'>
    readonly updatedAt: FieldRef<"Envoi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Envoi findUnique
   */
  export type EnvoiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    /**
     * Filter, which Envoi to fetch.
     */
    where: EnvoiWhereUniqueInput
  }

  /**
   * Envoi findUniqueOrThrow
   */
  export type EnvoiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    /**
     * Filter, which Envoi to fetch.
     */
    where: EnvoiWhereUniqueInput
  }

  /**
   * Envoi findFirst
   */
  export type EnvoiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    /**
     * Filter, which Envoi to fetch.
     */
    where?: EnvoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envois to fetch.
     */
    orderBy?: EnvoiOrderByWithRelationInput | EnvoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Envois.
     */
    cursor?: EnvoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Envois.
     */
    distinct?: EnvoiScalarFieldEnum | EnvoiScalarFieldEnum[]
  }

  /**
   * Envoi findFirstOrThrow
   */
  export type EnvoiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    /**
     * Filter, which Envoi to fetch.
     */
    where?: EnvoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envois to fetch.
     */
    orderBy?: EnvoiOrderByWithRelationInput | EnvoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Envois.
     */
    cursor?: EnvoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Envois.
     */
    distinct?: EnvoiScalarFieldEnum | EnvoiScalarFieldEnum[]
  }

  /**
   * Envoi findMany
   */
  export type EnvoiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    /**
     * Filter, which Envois to fetch.
     */
    where?: EnvoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envois to fetch.
     */
    orderBy?: EnvoiOrderByWithRelationInput | EnvoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Envois.
     */
    cursor?: EnvoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envois.
     */
    skip?: number
    distinct?: EnvoiScalarFieldEnum | EnvoiScalarFieldEnum[]
  }

  /**
   * Envoi create
   */
  export type EnvoiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    /**
     * The data needed to create a Envoi.
     */
    data: XOR<EnvoiCreateInput, EnvoiUncheckedCreateInput>
  }

  /**
   * Envoi createMany
   */
  export type EnvoiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Envois.
     */
    data: EnvoiCreateManyInput | EnvoiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Envoi createManyAndReturn
   */
  export type EnvoiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * The data used to create many Envois.
     */
    data: EnvoiCreateManyInput | EnvoiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Envoi update
   */
  export type EnvoiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    /**
     * The data needed to update a Envoi.
     */
    data: XOR<EnvoiUpdateInput, EnvoiUncheckedUpdateInput>
    /**
     * Choose, which Envoi to update.
     */
    where: EnvoiWhereUniqueInput
  }

  /**
   * Envoi updateMany
   */
  export type EnvoiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Envois.
     */
    data: XOR<EnvoiUpdateManyMutationInput, EnvoiUncheckedUpdateManyInput>
    /**
     * Filter which Envois to update
     */
    where?: EnvoiWhereInput
    /**
     * Limit how many Envois to update.
     */
    limit?: number
  }

  /**
   * Envoi updateManyAndReturn
   */
  export type EnvoiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * The data used to update Envois.
     */
    data: XOR<EnvoiUpdateManyMutationInput, EnvoiUncheckedUpdateManyInput>
    /**
     * Filter which Envois to update
     */
    where?: EnvoiWhereInput
    /**
     * Limit how many Envois to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Envoi upsert
   */
  export type EnvoiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    /**
     * The filter to search for the Envoi to update in case it exists.
     */
    where: EnvoiWhereUniqueInput
    /**
     * In case the Envoi found by the `where` argument doesn't exist, create a new Envoi with this data.
     */
    create: XOR<EnvoiCreateInput, EnvoiUncheckedCreateInput>
    /**
     * In case the Envoi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvoiUpdateInput, EnvoiUncheckedUpdateInput>
  }

  /**
   * Envoi delete
   */
  export type EnvoiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
    /**
     * Filter which Envoi to delete.
     */
    where: EnvoiWhereUniqueInput
  }

  /**
   * Envoi deleteMany
   */
  export type EnvoiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Envois to delete
     */
    where?: EnvoiWhereInput
    /**
     * Limit how many Envois to delete.
     */
    limit?: number
  }

  /**
   * Envoi.transport
   */
  export type Envoi$transportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    where?: TransportWhereInput
  }

  /**
   * Envoi.destinataire
   */
  export type Envoi$destinataireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Envoi.client
   */
  export type Envoi$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Envoi.envoiCoupons
   */
  export type Envoi$envoiCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    where?: EnvoiCouponWhereInput
    orderBy?: EnvoiCouponOrderByWithRelationInput | EnvoiCouponOrderByWithRelationInput[]
    cursor?: EnvoiCouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvoiCouponScalarFieldEnum | EnvoiCouponScalarFieldEnum[]
  }

  /**
   * Envoi.parcels
   */
  export type Envoi$parcelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    where?: ParcelWhereInput
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    cursor?: ParcelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcelScalarFieldEnum | ParcelScalarFieldEnum[]
  }

  /**
   * Envoi.appointments
   */
  export type Envoi$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Envoi.notifications
   */
  export type Envoi$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Envoi.payment
   */
  export type Envoi$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Envoi.trackingEvents
   */
  export type Envoi$trackingEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    where?: TrackingEventWhereInput
    orderBy?: TrackingEventOrderByWithRelationInput | TrackingEventOrderByWithRelationInput[]
    cursor?: TrackingEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackingEventScalarFieldEnum | TrackingEventScalarFieldEnum[]
  }

  /**
   * Envoi without action
   */
  export type EnvoiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envoi
     */
    select?: EnvoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Envoi
     */
    omit?: EnvoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiInclude<ExtArgs> | null
  }


  /**
   * Model TrackingEvent
   */

  export type AggregateTrackingEvent = {
    _count: TrackingEventCountAggregateOutputType | null
    _avg: TrackingEventAvgAggregateOutputType | null
    _sum: TrackingEventSumAggregateOutputType | null
    _min: TrackingEventMinAggregateOutputType | null
    _max: TrackingEventMaxAggregateOutputType | null
  }

  export type TrackingEventAvgAggregateOutputType = {
    id: number | null
    envoiId: number | null
  }

  export type TrackingEventSumAggregateOutputType = {
    id: number | null
    envoiId: number | null
  }

  export type TrackingEventMinAggregateOutputType = {
    id: number | null
    envoiId: number | null
    eventStatus: $Enums.TrackingEventStatus | null
    location: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TrackingEventMaxAggregateOutputType = {
    id: number | null
    envoiId: number | null
    eventStatus: $Enums.TrackingEventStatus | null
    location: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TrackingEventCountAggregateOutputType = {
    id: number
    envoiId: number
    eventStatus: number
    location: number
    description: number
    createdAt: number
    _all: number
  }


  export type TrackingEventAvgAggregateInputType = {
    id?: true
    envoiId?: true
  }

  export type TrackingEventSumAggregateInputType = {
    id?: true
    envoiId?: true
  }

  export type TrackingEventMinAggregateInputType = {
    id?: true
    envoiId?: true
    eventStatus?: true
    location?: true
    description?: true
    createdAt?: true
  }

  export type TrackingEventMaxAggregateInputType = {
    id?: true
    envoiId?: true
    eventStatus?: true
    location?: true
    description?: true
    createdAt?: true
  }

  export type TrackingEventCountAggregateInputType = {
    id?: true
    envoiId?: true
    eventStatus?: true
    location?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type TrackingEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackingEvent to aggregate.
     */
    where?: TrackingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingEvents to fetch.
     */
    orderBy?: TrackingEventOrderByWithRelationInput | TrackingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrackingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrackingEvents
    **/
    _count?: true | TrackingEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrackingEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrackingEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackingEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackingEventMaxAggregateInputType
  }

  export type GetTrackingEventAggregateType<T extends TrackingEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTrackingEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrackingEvent[P]>
      : GetScalarType<T[P], AggregateTrackingEvent[P]>
  }




  export type TrackingEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackingEventWhereInput
    orderBy?: TrackingEventOrderByWithAggregationInput | TrackingEventOrderByWithAggregationInput[]
    by: TrackingEventScalarFieldEnum[] | TrackingEventScalarFieldEnum
    having?: TrackingEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackingEventCountAggregateInputType | true
    _avg?: TrackingEventAvgAggregateInputType
    _sum?: TrackingEventSumAggregateInputType
    _min?: TrackingEventMinAggregateInputType
    _max?: TrackingEventMaxAggregateInputType
  }

  export type TrackingEventGroupByOutputType = {
    id: number
    envoiId: number
    eventStatus: $Enums.TrackingEventStatus
    location: string | null
    description: string | null
    createdAt: Date
    _count: TrackingEventCountAggregateOutputType | null
    _avg: TrackingEventAvgAggregateOutputType | null
    _sum: TrackingEventSumAggregateOutputType | null
    _min: TrackingEventMinAggregateOutputType | null
    _max: TrackingEventMaxAggregateOutputType | null
  }

  type GetTrackingEventGroupByPayload<T extends TrackingEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackingEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackingEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackingEventGroupByOutputType[P]>
            : GetScalarType<T[P], TrackingEventGroupByOutputType[P]>
        }
      >
    >


  export type TrackingEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    eventStatus?: boolean
    location?: boolean
    description?: boolean
    createdAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackingEvent"]>

  export type TrackingEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    eventStatus?: boolean
    location?: boolean
    description?: boolean
    createdAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackingEvent"]>

  export type TrackingEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    eventStatus?: boolean
    location?: boolean
    description?: boolean
    createdAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackingEvent"]>

  export type TrackingEventSelectScalar = {
    id?: boolean
    envoiId?: boolean
    eventStatus?: boolean
    location?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type TrackingEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "envoiId" | "eventStatus" | "location" | "description" | "createdAt", ExtArgs["result"]["trackingEvent"]>
  export type TrackingEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }
  export type TrackingEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }
  export type TrackingEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }

  export type $TrackingEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrackingEvent"
    objects: {
      envoi: Prisma.$EnvoiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      envoiId: number
      eventStatus: $Enums.TrackingEventStatus
      location: string | null
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["trackingEvent"]>
    composites: {}
  }

  type TrackingEventGetPayload<S extends boolean | null | undefined | TrackingEventDefaultArgs> = $Result.GetResult<Prisma.$TrackingEventPayload, S>

  type TrackingEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrackingEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrackingEventCountAggregateInputType | true
    }

  export interface TrackingEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrackingEvent'], meta: { name: 'TrackingEvent' } }
    /**
     * Find zero or one TrackingEvent that matches the filter.
     * @param {TrackingEventFindUniqueArgs} args - Arguments to find a TrackingEvent
     * @example
     * // Get one TrackingEvent
     * const trackingEvent = await prisma.trackingEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrackingEventFindUniqueArgs>(args: SelectSubset<T, TrackingEventFindUniqueArgs<ExtArgs>>): Prisma__TrackingEventClient<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrackingEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrackingEventFindUniqueOrThrowArgs} args - Arguments to find a TrackingEvent
     * @example
     * // Get one TrackingEvent
     * const trackingEvent = await prisma.trackingEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrackingEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TrackingEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrackingEventClient<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrackingEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingEventFindFirstArgs} args - Arguments to find a TrackingEvent
     * @example
     * // Get one TrackingEvent
     * const trackingEvent = await prisma.trackingEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrackingEventFindFirstArgs>(args?: SelectSubset<T, TrackingEventFindFirstArgs<ExtArgs>>): Prisma__TrackingEventClient<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrackingEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingEventFindFirstOrThrowArgs} args - Arguments to find a TrackingEvent
     * @example
     * // Get one TrackingEvent
     * const trackingEvent = await prisma.trackingEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrackingEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TrackingEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrackingEventClient<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrackingEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrackingEvents
     * const trackingEvents = await prisma.trackingEvent.findMany()
     * 
     * // Get first 10 TrackingEvents
     * const trackingEvents = await prisma.trackingEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trackingEventWithIdOnly = await prisma.trackingEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrackingEventFindManyArgs>(args?: SelectSubset<T, TrackingEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrackingEvent.
     * @param {TrackingEventCreateArgs} args - Arguments to create a TrackingEvent.
     * @example
     * // Create one TrackingEvent
     * const TrackingEvent = await prisma.trackingEvent.create({
     *   data: {
     *     // ... data to create a TrackingEvent
     *   }
     * })
     * 
     */
    create<T extends TrackingEventCreateArgs>(args: SelectSubset<T, TrackingEventCreateArgs<ExtArgs>>): Prisma__TrackingEventClient<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrackingEvents.
     * @param {TrackingEventCreateManyArgs} args - Arguments to create many TrackingEvents.
     * @example
     * // Create many TrackingEvents
     * const trackingEvent = await prisma.trackingEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrackingEventCreateManyArgs>(args?: SelectSubset<T, TrackingEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrackingEvents and returns the data saved in the database.
     * @param {TrackingEventCreateManyAndReturnArgs} args - Arguments to create many TrackingEvents.
     * @example
     * // Create many TrackingEvents
     * const trackingEvent = await prisma.trackingEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrackingEvents and only return the `id`
     * const trackingEventWithIdOnly = await prisma.trackingEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrackingEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TrackingEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrackingEvent.
     * @param {TrackingEventDeleteArgs} args - Arguments to delete one TrackingEvent.
     * @example
     * // Delete one TrackingEvent
     * const TrackingEvent = await prisma.trackingEvent.delete({
     *   where: {
     *     // ... filter to delete one TrackingEvent
     *   }
     * })
     * 
     */
    delete<T extends TrackingEventDeleteArgs>(args: SelectSubset<T, TrackingEventDeleteArgs<ExtArgs>>): Prisma__TrackingEventClient<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrackingEvent.
     * @param {TrackingEventUpdateArgs} args - Arguments to update one TrackingEvent.
     * @example
     * // Update one TrackingEvent
     * const trackingEvent = await prisma.trackingEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrackingEventUpdateArgs>(args: SelectSubset<T, TrackingEventUpdateArgs<ExtArgs>>): Prisma__TrackingEventClient<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrackingEvents.
     * @param {TrackingEventDeleteManyArgs} args - Arguments to filter TrackingEvents to delete.
     * @example
     * // Delete a few TrackingEvents
     * const { count } = await prisma.trackingEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrackingEventDeleteManyArgs>(args?: SelectSubset<T, TrackingEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrackingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrackingEvents
     * const trackingEvent = await prisma.trackingEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrackingEventUpdateManyArgs>(args: SelectSubset<T, TrackingEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrackingEvents and returns the data updated in the database.
     * @param {TrackingEventUpdateManyAndReturnArgs} args - Arguments to update many TrackingEvents.
     * @example
     * // Update many TrackingEvents
     * const trackingEvent = await prisma.trackingEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrackingEvents and only return the `id`
     * const trackingEventWithIdOnly = await prisma.trackingEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrackingEventUpdateManyAndReturnArgs>(args: SelectSubset<T, TrackingEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrackingEvent.
     * @param {TrackingEventUpsertArgs} args - Arguments to update or create a TrackingEvent.
     * @example
     * // Update or create a TrackingEvent
     * const trackingEvent = await prisma.trackingEvent.upsert({
     *   create: {
     *     // ... data to create a TrackingEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrackingEvent we want to update
     *   }
     * })
     */
    upsert<T extends TrackingEventUpsertArgs>(args: SelectSubset<T, TrackingEventUpsertArgs<ExtArgs>>): Prisma__TrackingEventClient<$Result.GetResult<Prisma.$TrackingEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrackingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingEventCountArgs} args - Arguments to filter TrackingEvents to count.
     * @example
     * // Count the number of TrackingEvents
     * const count = await prisma.trackingEvent.count({
     *   where: {
     *     // ... the filter for the TrackingEvents we want to count
     *   }
     * })
    **/
    count<T extends TrackingEventCountArgs>(
      args?: Subset<T, TrackingEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackingEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrackingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackingEventAggregateArgs>(args: Subset<T, TrackingEventAggregateArgs>): Prisma.PrismaPromise<GetTrackingEventAggregateType<T>>

    /**
     * Group by TrackingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrackingEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrackingEventGroupByArgs['orderBy'] }
        : { orderBy?: TrackingEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrackingEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackingEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrackingEvent model
   */
  readonly fields: TrackingEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrackingEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrackingEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    envoi<T extends EnvoiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvoiDefaultArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrackingEvent model
   */
  interface TrackingEventFieldRefs {
    readonly id: FieldRef<"TrackingEvent", 'Int'>
    readonly envoiId: FieldRef<"TrackingEvent", 'Int'>
    readonly eventStatus: FieldRef<"TrackingEvent", 'TrackingEventStatus'>
    readonly location: FieldRef<"TrackingEvent", 'String'>
    readonly description: FieldRef<"TrackingEvent", 'String'>
    readonly createdAt: FieldRef<"TrackingEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrackingEvent findUnique
   */
  export type TrackingEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which TrackingEvent to fetch.
     */
    where: TrackingEventWhereUniqueInput
  }

  /**
   * TrackingEvent findUniqueOrThrow
   */
  export type TrackingEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which TrackingEvent to fetch.
     */
    where: TrackingEventWhereUniqueInput
  }

  /**
   * TrackingEvent findFirst
   */
  export type TrackingEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which TrackingEvent to fetch.
     */
    where?: TrackingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingEvents to fetch.
     */
    orderBy?: TrackingEventOrderByWithRelationInput | TrackingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackingEvents.
     */
    cursor?: TrackingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackingEvents.
     */
    distinct?: TrackingEventScalarFieldEnum | TrackingEventScalarFieldEnum[]
  }

  /**
   * TrackingEvent findFirstOrThrow
   */
  export type TrackingEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which TrackingEvent to fetch.
     */
    where?: TrackingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingEvents to fetch.
     */
    orderBy?: TrackingEventOrderByWithRelationInput | TrackingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackingEvents.
     */
    cursor?: TrackingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackingEvents.
     */
    distinct?: TrackingEventScalarFieldEnum | TrackingEventScalarFieldEnum[]
  }

  /**
   * TrackingEvent findMany
   */
  export type TrackingEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which TrackingEvents to fetch.
     */
    where?: TrackingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingEvents to fetch.
     */
    orderBy?: TrackingEventOrderByWithRelationInput | TrackingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrackingEvents.
     */
    cursor?: TrackingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingEvents.
     */
    skip?: number
    distinct?: TrackingEventScalarFieldEnum | TrackingEventScalarFieldEnum[]
  }

  /**
   * TrackingEvent create
   */
  export type TrackingEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TrackingEvent.
     */
    data: XOR<TrackingEventCreateInput, TrackingEventUncheckedCreateInput>
  }

  /**
   * TrackingEvent createMany
   */
  export type TrackingEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrackingEvents.
     */
    data: TrackingEventCreateManyInput | TrackingEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrackingEvent createManyAndReturn
   */
  export type TrackingEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * The data used to create many TrackingEvents.
     */
    data: TrackingEventCreateManyInput | TrackingEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrackingEvent update
   */
  export type TrackingEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TrackingEvent.
     */
    data: XOR<TrackingEventUpdateInput, TrackingEventUncheckedUpdateInput>
    /**
     * Choose, which TrackingEvent to update.
     */
    where: TrackingEventWhereUniqueInput
  }

  /**
   * TrackingEvent updateMany
   */
  export type TrackingEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrackingEvents.
     */
    data: XOR<TrackingEventUpdateManyMutationInput, TrackingEventUncheckedUpdateManyInput>
    /**
     * Filter which TrackingEvents to update
     */
    where?: TrackingEventWhereInput
    /**
     * Limit how many TrackingEvents to update.
     */
    limit?: number
  }

  /**
   * TrackingEvent updateManyAndReturn
   */
  export type TrackingEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * The data used to update TrackingEvents.
     */
    data: XOR<TrackingEventUpdateManyMutationInput, TrackingEventUncheckedUpdateManyInput>
    /**
     * Filter which TrackingEvents to update
     */
    where?: TrackingEventWhereInput
    /**
     * Limit how many TrackingEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrackingEvent upsert
   */
  export type TrackingEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TrackingEvent to update in case it exists.
     */
    where: TrackingEventWhereUniqueInput
    /**
     * In case the TrackingEvent found by the `where` argument doesn't exist, create a new TrackingEvent with this data.
     */
    create: XOR<TrackingEventCreateInput, TrackingEventUncheckedCreateInput>
    /**
     * In case the TrackingEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrackingEventUpdateInput, TrackingEventUncheckedUpdateInput>
  }

  /**
   * TrackingEvent delete
   */
  export type TrackingEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
    /**
     * Filter which TrackingEvent to delete.
     */
    where: TrackingEventWhereUniqueInput
  }

  /**
   * TrackingEvent deleteMany
   */
  export type TrackingEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackingEvents to delete
     */
    where?: TrackingEventWhereInput
    /**
     * Limit how many TrackingEvents to delete.
     */
    limit?: number
  }

  /**
   * TrackingEvent without action
   */
  export type TrackingEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingEvent
     */
    select?: TrackingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingEvent
     */
    omit?: TrackingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingEventInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    id: number | null
    envoiId: number | null
    agencyId: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    id: number | null
    envoiId: number | null
    agencyId: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: number | null
    envoiId: number | null
    agencyId: number | null
    date: Date | null
    status: $Enums.AppointmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: number | null
    envoiId: number | null
    agencyId: number | null
    date: Date | null
    status: $Enums.AppointmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    envoiId: number
    agencyId: number
    date: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    id?: true
    envoiId?: true
    agencyId?: true
  }

  export type AppointmentSumAggregateInputType = {
    id?: true
    envoiId?: true
    agencyId?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    envoiId?: true
    agencyId?: true
    date?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    envoiId?: true
    agencyId?: true
    date?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    envoiId?: true
    agencyId?: true
    date?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: number
    envoiId: number
    agencyId: number
    date: Date
    status: $Enums.AppointmentStatus
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    agencyId?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    agencyId?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    agencyId?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    envoiId?: boolean
    agencyId?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "envoiId" | "agencyId" | "date" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      envoi: Prisma.$EnvoiPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      envoiId: number
      agencyId: number
      date: Date
      status: $Enums.AppointmentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    envoi<T extends EnvoiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvoiDefaultArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'Int'>
    readonly envoiId: FieldRef<"Appointment", 'Int'>
    readonly agencyId: FieldRef<"Appointment", 'Int'>
    readonly date: FieldRef<"Appointment", 'DateTime'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model EnvoiCoupon
   */

  export type AggregateEnvoiCoupon = {
    _count: EnvoiCouponCountAggregateOutputType | null
    _avg: EnvoiCouponAvgAggregateOutputType | null
    _sum: EnvoiCouponSumAggregateOutputType | null
    _min: EnvoiCouponMinAggregateOutputType | null
    _max: EnvoiCouponMaxAggregateOutputType | null
  }

  export type EnvoiCouponAvgAggregateOutputType = {
    envoiId: number | null
    couponId: number | null
  }

  export type EnvoiCouponSumAggregateOutputType = {
    envoiId: number | null
    couponId: number | null
  }

  export type EnvoiCouponMinAggregateOutputType = {
    envoiId: number | null
    couponId: number | null
  }

  export type EnvoiCouponMaxAggregateOutputType = {
    envoiId: number | null
    couponId: number | null
  }

  export type EnvoiCouponCountAggregateOutputType = {
    envoiId: number
    couponId: number
    _all: number
  }


  export type EnvoiCouponAvgAggregateInputType = {
    envoiId?: true
    couponId?: true
  }

  export type EnvoiCouponSumAggregateInputType = {
    envoiId?: true
    couponId?: true
  }

  export type EnvoiCouponMinAggregateInputType = {
    envoiId?: true
    couponId?: true
  }

  export type EnvoiCouponMaxAggregateInputType = {
    envoiId?: true
    couponId?: true
  }

  export type EnvoiCouponCountAggregateInputType = {
    envoiId?: true
    couponId?: true
    _all?: true
  }

  export type EnvoiCouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnvoiCoupon to aggregate.
     */
    where?: EnvoiCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvoiCoupons to fetch.
     */
    orderBy?: EnvoiCouponOrderByWithRelationInput | EnvoiCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvoiCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvoiCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvoiCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnvoiCoupons
    **/
    _count?: true | EnvoiCouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnvoiCouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnvoiCouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvoiCouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvoiCouponMaxAggregateInputType
  }

  export type GetEnvoiCouponAggregateType<T extends EnvoiCouponAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvoiCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvoiCoupon[P]>
      : GetScalarType<T[P], AggregateEnvoiCoupon[P]>
  }




  export type EnvoiCouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvoiCouponWhereInput
    orderBy?: EnvoiCouponOrderByWithAggregationInput | EnvoiCouponOrderByWithAggregationInput[]
    by: EnvoiCouponScalarFieldEnum[] | EnvoiCouponScalarFieldEnum
    having?: EnvoiCouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvoiCouponCountAggregateInputType | true
    _avg?: EnvoiCouponAvgAggregateInputType
    _sum?: EnvoiCouponSumAggregateInputType
    _min?: EnvoiCouponMinAggregateInputType
    _max?: EnvoiCouponMaxAggregateInputType
  }

  export type EnvoiCouponGroupByOutputType = {
    envoiId: number
    couponId: number
    _count: EnvoiCouponCountAggregateOutputType | null
    _avg: EnvoiCouponAvgAggregateOutputType | null
    _sum: EnvoiCouponSumAggregateOutputType | null
    _min: EnvoiCouponMinAggregateOutputType | null
    _max: EnvoiCouponMaxAggregateOutputType | null
  }

  type GetEnvoiCouponGroupByPayload<T extends EnvoiCouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvoiCouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvoiCouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvoiCouponGroupByOutputType[P]>
            : GetScalarType<T[P], EnvoiCouponGroupByOutputType[P]>
        }
      >
    >


  export type EnvoiCouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    envoiId?: boolean
    couponId?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["envoiCoupon"]>

  export type EnvoiCouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    envoiId?: boolean
    couponId?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["envoiCoupon"]>

  export type EnvoiCouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    envoiId?: boolean
    couponId?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["envoiCoupon"]>

  export type EnvoiCouponSelectScalar = {
    envoiId?: boolean
    couponId?: boolean
  }

  export type EnvoiCouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"envoiId" | "couponId", ExtArgs["result"]["envoiCoupon"]>
  export type EnvoiCouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }
  export type EnvoiCouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }
  export type EnvoiCouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }

  export type $EnvoiCouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnvoiCoupon"
    objects: {
      envoi: Prisma.$EnvoiPayload<ExtArgs>
      coupon: Prisma.$CouponPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      envoiId: number
      couponId: number
    }, ExtArgs["result"]["envoiCoupon"]>
    composites: {}
  }

  type EnvoiCouponGetPayload<S extends boolean | null | undefined | EnvoiCouponDefaultArgs> = $Result.GetResult<Prisma.$EnvoiCouponPayload, S>

  type EnvoiCouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnvoiCouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnvoiCouponCountAggregateInputType | true
    }

  export interface EnvoiCouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnvoiCoupon'], meta: { name: 'EnvoiCoupon' } }
    /**
     * Find zero or one EnvoiCoupon that matches the filter.
     * @param {EnvoiCouponFindUniqueArgs} args - Arguments to find a EnvoiCoupon
     * @example
     * // Get one EnvoiCoupon
     * const envoiCoupon = await prisma.envoiCoupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnvoiCouponFindUniqueArgs>(args: SelectSubset<T, EnvoiCouponFindUniqueArgs<ExtArgs>>): Prisma__EnvoiCouponClient<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EnvoiCoupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnvoiCouponFindUniqueOrThrowArgs} args - Arguments to find a EnvoiCoupon
     * @example
     * // Get one EnvoiCoupon
     * const envoiCoupon = await prisma.envoiCoupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnvoiCouponFindUniqueOrThrowArgs>(args: SelectSubset<T, EnvoiCouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnvoiCouponClient<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnvoiCoupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiCouponFindFirstArgs} args - Arguments to find a EnvoiCoupon
     * @example
     * // Get one EnvoiCoupon
     * const envoiCoupon = await prisma.envoiCoupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnvoiCouponFindFirstArgs>(args?: SelectSubset<T, EnvoiCouponFindFirstArgs<ExtArgs>>): Prisma__EnvoiCouponClient<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnvoiCoupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiCouponFindFirstOrThrowArgs} args - Arguments to find a EnvoiCoupon
     * @example
     * // Get one EnvoiCoupon
     * const envoiCoupon = await prisma.envoiCoupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnvoiCouponFindFirstOrThrowArgs>(args?: SelectSubset<T, EnvoiCouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnvoiCouponClient<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EnvoiCoupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiCouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnvoiCoupons
     * const envoiCoupons = await prisma.envoiCoupon.findMany()
     * 
     * // Get first 10 EnvoiCoupons
     * const envoiCoupons = await prisma.envoiCoupon.findMany({ take: 10 })
     * 
     * // Only select the `envoiId`
     * const envoiCouponWithEnvoiIdOnly = await prisma.envoiCoupon.findMany({ select: { envoiId: true } })
     * 
     */
    findMany<T extends EnvoiCouponFindManyArgs>(args?: SelectSubset<T, EnvoiCouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EnvoiCoupon.
     * @param {EnvoiCouponCreateArgs} args - Arguments to create a EnvoiCoupon.
     * @example
     * // Create one EnvoiCoupon
     * const EnvoiCoupon = await prisma.envoiCoupon.create({
     *   data: {
     *     // ... data to create a EnvoiCoupon
     *   }
     * })
     * 
     */
    create<T extends EnvoiCouponCreateArgs>(args: SelectSubset<T, EnvoiCouponCreateArgs<ExtArgs>>): Prisma__EnvoiCouponClient<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EnvoiCoupons.
     * @param {EnvoiCouponCreateManyArgs} args - Arguments to create many EnvoiCoupons.
     * @example
     * // Create many EnvoiCoupons
     * const envoiCoupon = await prisma.envoiCoupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnvoiCouponCreateManyArgs>(args?: SelectSubset<T, EnvoiCouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnvoiCoupons and returns the data saved in the database.
     * @param {EnvoiCouponCreateManyAndReturnArgs} args - Arguments to create many EnvoiCoupons.
     * @example
     * // Create many EnvoiCoupons
     * const envoiCoupon = await prisma.envoiCoupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnvoiCoupons and only return the `envoiId`
     * const envoiCouponWithEnvoiIdOnly = await prisma.envoiCoupon.createManyAndReturn({
     *   select: { envoiId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnvoiCouponCreateManyAndReturnArgs>(args?: SelectSubset<T, EnvoiCouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EnvoiCoupon.
     * @param {EnvoiCouponDeleteArgs} args - Arguments to delete one EnvoiCoupon.
     * @example
     * // Delete one EnvoiCoupon
     * const EnvoiCoupon = await prisma.envoiCoupon.delete({
     *   where: {
     *     // ... filter to delete one EnvoiCoupon
     *   }
     * })
     * 
     */
    delete<T extends EnvoiCouponDeleteArgs>(args: SelectSubset<T, EnvoiCouponDeleteArgs<ExtArgs>>): Prisma__EnvoiCouponClient<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EnvoiCoupon.
     * @param {EnvoiCouponUpdateArgs} args - Arguments to update one EnvoiCoupon.
     * @example
     * // Update one EnvoiCoupon
     * const envoiCoupon = await prisma.envoiCoupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnvoiCouponUpdateArgs>(args: SelectSubset<T, EnvoiCouponUpdateArgs<ExtArgs>>): Prisma__EnvoiCouponClient<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EnvoiCoupons.
     * @param {EnvoiCouponDeleteManyArgs} args - Arguments to filter EnvoiCoupons to delete.
     * @example
     * // Delete a few EnvoiCoupons
     * const { count } = await prisma.envoiCoupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnvoiCouponDeleteManyArgs>(args?: SelectSubset<T, EnvoiCouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnvoiCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiCouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnvoiCoupons
     * const envoiCoupon = await prisma.envoiCoupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnvoiCouponUpdateManyArgs>(args: SelectSubset<T, EnvoiCouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnvoiCoupons and returns the data updated in the database.
     * @param {EnvoiCouponUpdateManyAndReturnArgs} args - Arguments to update many EnvoiCoupons.
     * @example
     * // Update many EnvoiCoupons
     * const envoiCoupon = await prisma.envoiCoupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EnvoiCoupons and only return the `envoiId`
     * const envoiCouponWithEnvoiIdOnly = await prisma.envoiCoupon.updateManyAndReturn({
     *   select: { envoiId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnvoiCouponUpdateManyAndReturnArgs>(args: SelectSubset<T, EnvoiCouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EnvoiCoupon.
     * @param {EnvoiCouponUpsertArgs} args - Arguments to update or create a EnvoiCoupon.
     * @example
     * // Update or create a EnvoiCoupon
     * const envoiCoupon = await prisma.envoiCoupon.upsert({
     *   create: {
     *     // ... data to create a EnvoiCoupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnvoiCoupon we want to update
     *   }
     * })
     */
    upsert<T extends EnvoiCouponUpsertArgs>(args: SelectSubset<T, EnvoiCouponUpsertArgs<ExtArgs>>): Prisma__EnvoiCouponClient<$Result.GetResult<Prisma.$EnvoiCouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EnvoiCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiCouponCountArgs} args - Arguments to filter EnvoiCoupons to count.
     * @example
     * // Count the number of EnvoiCoupons
     * const count = await prisma.envoiCoupon.count({
     *   where: {
     *     // ... the filter for the EnvoiCoupons we want to count
     *   }
     * })
    **/
    count<T extends EnvoiCouponCountArgs>(
      args?: Subset<T, EnvoiCouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvoiCouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnvoiCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiCouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvoiCouponAggregateArgs>(args: Subset<T, EnvoiCouponAggregateArgs>): Prisma.PrismaPromise<GetEnvoiCouponAggregateType<T>>

    /**
     * Group by EnvoiCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvoiCouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvoiCouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvoiCouponGroupByArgs['orderBy'] }
        : { orderBy?: EnvoiCouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvoiCouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvoiCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnvoiCoupon model
   */
  readonly fields: EnvoiCouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnvoiCoupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnvoiCouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    envoi<T extends EnvoiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvoiDefaultArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coupon<T extends CouponDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CouponDefaultArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnvoiCoupon model
   */
  interface EnvoiCouponFieldRefs {
    readonly envoiId: FieldRef<"EnvoiCoupon", 'Int'>
    readonly couponId: FieldRef<"EnvoiCoupon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EnvoiCoupon findUnique
   */
  export type EnvoiCouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    /**
     * Filter, which EnvoiCoupon to fetch.
     */
    where: EnvoiCouponWhereUniqueInput
  }

  /**
   * EnvoiCoupon findUniqueOrThrow
   */
  export type EnvoiCouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    /**
     * Filter, which EnvoiCoupon to fetch.
     */
    where: EnvoiCouponWhereUniqueInput
  }

  /**
   * EnvoiCoupon findFirst
   */
  export type EnvoiCouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    /**
     * Filter, which EnvoiCoupon to fetch.
     */
    where?: EnvoiCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvoiCoupons to fetch.
     */
    orderBy?: EnvoiCouponOrderByWithRelationInput | EnvoiCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnvoiCoupons.
     */
    cursor?: EnvoiCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvoiCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvoiCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnvoiCoupons.
     */
    distinct?: EnvoiCouponScalarFieldEnum | EnvoiCouponScalarFieldEnum[]
  }

  /**
   * EnvoiCoupon findFirstOrThrow
   */
  export type EnvoiCouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    /**
     * Filter, which EnvoiCoupon to fetch.
     */
    where?: EnvoiCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvoiCoupons to fetch.
     */
    orderBy?: EnvoiCouponOrderByWithRelationInput | EnvoiCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnvoiCoupons.
     */
    cursor?: EnvoiCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvoiCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvoiCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnvoiCoupons.
     */
    distinct?: EnvoiCouponScalarFieldEnum | EnvoiCouponScalarFieldEnum[]
  }

  /**
   * EnvoiCoupon findMany
   */
  export type EnvoiCouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    /**
     * Filter, which EnvoiCoupons to fetch.
     */
    where?: EnvoiCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvoiCoupons to fetch.
     */
    orderBy?: EnvoiCouponOrderByWithRelationInput | EnvoiCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnvoiCoupons.
     */
    cursor?: EnvoiCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvoiCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvoiCoupons.
     */
    skip?: number
    distinct?: EnvoiCouponScalarFieldEnum | EnvoiCouponScalarFieldEnum[]
  }

  /**
   * EnvoiCoupon create
   */
  export type EnvoiCouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    /**
     * The data needed to create a EnvoiCoupon.
     */
    data: XOR<EnvoiCouponCreateInput, EnvoiCouponUncheckedCreateInput>
  }

  /**
   * EnvoiCoupon createMany
   */
  export type EnvoiCouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnvoiCoupons.
     */
    data: EnvoiCouponCreateManyInput | EnvoiCouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnvoiCoupon createManyAndReturn
   */
  export type EnvoiCouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * The data used to create many EnvoiCoupons.
     */
    data: EnvoiCouponCreateManyInput | EnvoiCouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnvoiCoupon update
   */
  export type EnvoiCouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    /**
     * The data needed to update a EnvoiCoupon.
     */
    data: XOR<EnvoiCouponUpdateInput, EnvoiCouponUncheckedUpdateInput>
    /**
     * Choose, which EnvoiCoupon to update.
     */
    where: EnvoiCouponWhereUniqueInput
  }

  /**
   * EnvoiCoupon updateMany
   */
  export type EnvoiCouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnvoiCoupons.
     */
    data: XOR<EnvoiCouponUpdateManyMutationInput, EnvoiCouponUncheckedUpdateManyInput>
    /**
     * Filter which EnvoiCoupons to update
     */
    where?: EnvoiCouponWhereInput
    /**
     * Limit how many EnvoiCoupons to update.
     */
    limit?: number
  }

  /**
   * EnvoiCoupon updateManyAndReturn
   */
  export type EnvoiCouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * The data used to update EnvoiCoupons.
     */
    data: XOR<EnvoiCouponUpdateManyMutationInput, EnvoiCouponUncheckedUpdateManyInput>
    /**
     * Filter which EnvoiCoupons to update
     */
    where?: EnvoiCouponWhereInput
    /**
     * Limit how many EnvoiCoupons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnvoiCoupon upsert
   */
  export type EnvoiCouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    /**
     * The filter to search for the EnvoiCoupon to update in case it exists.
     */
    where: EnvoiCouponWhereUniqueInput
    /**
     * In case the EnvoiCoupon found by the `where` argument doesn't exist, create a new EnvoiCoupon with this data.
     */
    create: XOR<EnvoiCouponCreateInput, EnvoiCouponUncheckedCreateInput>
    /**
     * In case the EnvoiCoupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvoiCouponUpdateInput, EnvoiCouponUncheckedUpdateInput>
  }

  /**
   * EnvoiCoupon delete
   */
  export type EnvoiCouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
    /**
     * Filter which EnvoiCoupon to delete.
     */
    where: EnvoiCouponWhereUniqueInput
  }

  /**
   * EnvoiCoupon deleteMany
   */
  export type EnvoiCouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnvoiCoupons to delete
     */
    where?: EnvoiCouponWhereInput
    /**
     * Limit how many EnvoiCoupons to delete.
     */
    limit?: number
  }

  /**
   * EnvoiCoupon without action
   */
  export type EnvoiCouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvoiCoupon
     */
    select?: EnvoiCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvoiCoupon
     */
    omit?: EnvoiCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvoiCouponInclude<ExtArgs> | null
  }


  /**
   * Model Parcel
   */

  export type AggregateParcel = {
    _count: ParcelCountAggregateOutputType | null
    _avg: ParcelAvgAggregateOutputType | null
    _sum: ParcelSumAggregateOutputType | null
    _min: ParcelMinAggregateOutputType | null
    _max: ParcelMaxAggregateOutputType | null
  }

  export type ParcelAvgAggregateOutputType = {
    id: number | null
    envoiId: number | null
    height: Decimal | null
    weight: Decimal | null
    width: Decimal | null
    length: Decimal | null
  }

  export type ParcelSumAggregateOutputType = {
    id: number | null
    envoiId: number | null
    height: Decimal | null
    weight: Decimal | null
    width: Decimal | null
    length: Decimal | null
  }

  export type ParcelMinAggregateOutputType = {
    id: number | null
    envoiId: number | null
    height: Decimal | null
    weight: Decimal | null
    width: Decimal | null
    length: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParcelMaxAggregateOutputType = {
    id: number | null
    envoiId: number | null
    height: Decimal | null
    weight: Decimal | null
    width: Decimal | null
    length: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParcelCountAggregateOutputType = {
    id: number
    envoiId: number
    height: number
    weight: number
    width: number
    length: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParcelAvgAggregateInputType = {
    id?: true
    envoiId?: true
    height?: true
    weight?: true
    width?: true
    length?: true
  }

  export type ParcelSumAggregateInputType = {
    id?: true
    envoiId?: true
    height?: true
    weight?: true
    width?: true
    length?: true
  }

  export type ParcelMinAggregateInputType = {
    id?: true
    envoiId?: true
    height?: true
    weight?: true
    width?: true
    length?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParcelMaxAggregateInputType = {
    id?: true
    envoiId?: true
    height?: true
    weight?: true
    width?: true
    length?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParcelCountAggregateInputType = {
    id?: true
    envoiId?: true
    height?: true
    weight?: true
    width?: true
    length?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParcelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parcel to aggregate.
     */
    where?: ParcelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parcels to fetch.
     */
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParcelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parcels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parcels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parcels
    **/
    _count?: true | ParcelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParcelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParcelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParcelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParcelMaxAggregateInputType
  }

  export type GetParcelAggregateType<T extends ParcelAggregateArgs> = {
        [P in keyof T & keyof AggregateParcel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParcel[P]>
      : GetScalarType<T[P], AggregateParcel[P]>
  }




  export type ParcelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcelWhereInput
    orderBy?: ParcelOrderByWithAggregationInput | ParcelOrderByWithAggregationInput[]
    by: ParcelScalarFieldEnum[] | ParcelScalarFieldEnum
    having?: ParcelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParcelCountAggregateInputType | true
    _avg?: ParcelAvgAggregateInputType
    _sum?: ParcelSumAggregateInputType
    _min?: ParcelMinAggregateInputType
    _max?: ParcelMaxAggregateInputType
  }

  export type ParcelGroupByOutputType = {
    id: number
    envoiId: number
    height: Decimal
    weight: Decimal
    width: Decimal
    length: Decimal
    createdAt: Date
    updatedAt: Date
    _count: ParcelCountAggregateOutputType | null
    _avg: ParcelAvgAggregateOutputType | null
    _sum: ParcelSumAggregateOutputType | null
    _min: ParcelMinAggregateOutputType | null
    _max: ParcelMaxAggregateOutputType | null
  }

  type GetParcelGroupByPayload<T extends ParcelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParcelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParcelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParcelGroupByOutputType[P]>
            : GetScalarType<T[P], ParcelGroupByOutputType[P]>
        }
      >
    >


  export type ParcelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    height?: boolean
    weight?: boolean
    width?: boolean
    length?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parcel"]>

  export type ParcelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    height?: boolean
    weight?: boolean
    width?: boolean
    length?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parcel"]>

  export type ParcelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envoiId?: boolean
    height?: boolean
    weight?: boolean
    width?: boolean
    length?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parcel"]>

  export type ParcelSelectScalar = {
    id?: boolean
    envoiId?: boolean
    height?: boolean
    weight?: boolean
    width?: boolean
    length?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParcelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "envoiId" | "height" | "weight" | "width" | "length" | "createdAt" | "updatedAt", ExtArgs["result"]["parcel"]>
  export type ParcelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }
  export type ParcelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }
  export type ParcelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envoi?: boolean | EnvoiDefaultArgs<ExtArgs>
  }

  export type $ParcelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parcel"
    objects: {
      envoi: Prisma.$EnvoiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      envoiId: number
      height: Prisma.Decimal
      weight: Prisma.Decimal
      width: Prisma.Decimal
      length: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parcel"]>
    composites: {}
  }

  type ParcelGetPayload<S extends boolean | null | undefined | ParcelDefaultArgs> = $Result.GetResult<Prisma.$ParcelPayload, S>

  type ParcelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParcelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParcelCountAggregateInputType | true
    }

  export interface ParcelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parcel'], meta: { name: 'Parcel' } }
    /**
     * Find zero or one Parcel that matches the filter.
     * @param {ParcelFindUniqueArgs} args - Arguments to find a Parcel
     * @example
     * // Get one Parcel
     * const parcel = await prisma.parcel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParcelFindUniqueArgs>(args: SelectSubset<T, ParcelFindUniqueArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parcel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParcelFindUniqueOrThrowArgs} args - Arguments to find a Parcel
     * @example
     * // Get one Parcel
     * const parcel = await prisma.parcel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParcelFindUniqueOrThrowArgs>(args: SelectSubset<T, ParcelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parcel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelFindFirstArgs} args - Arguments to find a Parcel
     * @example
     * // Get one Parcel
     * const parcel = await prisma.parcel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParcelFindFirstArgs>(args?: SelectSubset<T, ParcelFindFirstArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parcel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelFindFirstOrThrowArgs} args - Arguments to find a Parcel
     * @example
     * // Get one Parcel
     * const parcel = await prisma.parcel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParcelFindFirstOrThrowArgs>(args?: SelectSubset<T, ParcelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parcels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parcels
     * const parcels = await prisma.parcel.findMany()
     * 
     * // Get first 10 Parcels
     * const parcels = await prisma.parcel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parcelWithIdOnly = await prisma.parcel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParcelFindManyArgs>(args?: SelectSubset<T, ParcelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parcel.
     * @param {ParcelCreateArgs} args - Arguments to create a Parcel.
     * @example
     * // Create one Parcel
     * const Parcel = await prisma.parcel.create({
     *   data: {
     *     // ... data to create a Parcel
     *   }
     * })
     * 
     */
    create<T extends ParcelCreateArgs>(args: SelectSubset<T, ParcelCreateArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parcels.
     * @param {ParcelCreateManyArgs} args - Arguments to create many Parcels.
     * @example
     * // Create many Parcels
     * const parcel = await prisma.parcel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParcelCreateManyArgs>(args?: SelectSubset<T, ParcelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parcels and returns the data saved in the database.
     * @param {ParcelCreateManyAndReturnArgs} args - Arguments to create many Parcels.
     * @example
     * // Create many Parcels
     * const parcel = await prisma.parcel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parcels and only return the `id`
     * const parcelWithIdOnly = await prisma.parcel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParcelCreateManyAndReturnArgs>(args?: SelectSubset<T, ParcelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parcel.
     * @param {ParcelDeleteArgs} args - Arguments to delete one Parcel.
     * @example
     * // Delete one Parcel
     * const Parcel = await prisma.parcel.delete({
     *   where: {
     *     // ... filter to delete one Parcel
     *   }
     * })
     * 
     */
    delete<T extends ParcelDeleteArgs>(args: SelectSubset<T, ParcelDeleteArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parcel.
     * @param {ParcelUpdateArgs} args - Arguments to update one Parcel.
     * @example
     * // Update one Parcel
     * const parcel = await prisma.parcel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParcelUpdateArgs>(args: SelectSubset<T, ParcelUpdateArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parcels.
     * @param {ParcelDeleteManyArgs} args - Arguments to filter Parcels to delete.
     * @example
     * // Delete a few Parcels
     * const { count } = await prisma.parcel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParcelDeleteManyArgs>(args?: SelectSubset<T, ParcelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parcels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parcels
     * const parcel = await prisma.parcel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParcelUpdateManyArgs>(args: SelectSubset<T, ParcelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parcels and returns the data updated in the database.
     * @param {ParcelUpdateManyAndReturnArgs} args - Arguments to update many Parcels.
     * @example
     * // Update many Parcels
     * const parcel = await prisma.parcel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parcels and only return the `id`
     * const parcelWithIdOnly = await prisma.parcel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParcelUpdateManyAndReturnArgs>(args: SelectSubset<T, ParcelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parcel.
     * @param {ParcelUpsertArgs} args - Arguments to update or create a Parcel.
     * @example
     * // Update or create a Parcel
     * const parcel = await prisma.parcel.upsert({
     *   create: {
     *     // ... data to create a Parcel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parcel we want to update
     *   }
     * })
     */
    upsert<T extends ParcelUpsertArgs>(args: SelectSubset<T, ParcelUpsertArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parcels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelCountArgs} args - Arguments to filter Parcels to count.
     * @example
     * // Count the number of Parcels
     * const count = await prisma.parcel.count({
     *   where: {
     *     // ... the filter for the Parcels we want to count
     *   }
     * })
    **/
    count<T extends ParcelCountArgs>(
      args?: Subset<T, ParcelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParcelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parcel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParcelAggregateArgs>(args: Subset<T, ParcelAggregateArgs>): Prisma.PrismaPromise<GetParcelAggregateType<T>>

    /**
     * Group by Parcel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParcelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParcelGroupByArgs['orderBy'] }
        : { orderBy?: ParcelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParcelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParcelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parcel model
   */
  readonly fields: ParcelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parcel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParcelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    envoi<T extends EnvoiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvoiDefaultArgs<ExtArgs>>): Prisma__EnvoiClient<$Result.GetResult<Prisma.$EnvoiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parcel model
   */
  interface ParcelFieldRefs {
    readonly id: FieldRef<"Parcel", 'Int'>
    readonly envoiId: FieldRef<"Parcel", 'Int'>
    readonly height: FieldRef<"Parcel", 'Decimal'>
    readonly weight: FieldRef<"Parcel", 'Decimal'>
    readonly width: FieldRef<"Parcel", 'Decimal'>
    readonly length: FieldRef<"Parcel", 'Decimal'>
    readonly createdAt: FieldRef<"Parcel", 'DateTime'>
    readonly updatedAt: FieldRef<"Parcel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parcel findUnique
   */
  export type ParcelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcel to fetch.
     */
    where: ParcelWhereUniqueInput
  }

  /**
   * Parcel findUniqueOrThrow
   */
  export type ParcelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcel to fetch.
     */
    where: ParcelWhereUniqueInput
  }

  /**
   * Parcel findFirst
   */
  export type ParcelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcel to fetch.
     */
    where?: ParcelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parcels to fetch.
     */
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parcels.
     */
    cursor?: ParcelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parcels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parcels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parcels.
     */
    distinct?: ParcelScalarFieldEnum | ParcelScalarFieldEnum[]
  }

  /**
   * Parcel findFirstOrThrow
   */
  export type ParcelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcel to fetch.
     */
    where?: ParcelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parcels to fetch.
     */
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parcels.
     */
    cursor?: ParcelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parcels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parcels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parcels.
     */
    distinct?: ParcelScalarFieldEnum | ParcelScalarFieldEnum[]
  }

  /**
   * Parcel findMany
   */
  export type ParcelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcels to fetch.
     */
    where?: ParcelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parcels to fetch.
     */
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parcels.
     */
    cursor?: ParcelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parcels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parcels.
     */
    skip?: number
    distinct?: ParcelScalarFieldEnum | ParcelScalarFieldEnum[]
  }

  /**
   * Parcel create
   */
  export type ParcelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * The data needed to create a Parcel.
     */
    data: XOR<ParcelCreateInput, ParcelUncheckedCreateInput>
  }

  /**
   * Parcel createMany
   */
  export type ParcelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parcels.
     */
    data: ParcelCreateManyInput | ParcelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parcel createManyAndReturn
   */
  export type ParcelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * The data used to create many Parcels.
     */
    data: ParcelCreateManyInput | ParcelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parcel update
   */
  export type ParcelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * The data needed to update a Parcel.
     */
    data: XOR<ParcelUpdateInput, ParcelUncheckedUpdateInput>
    /**
     * Choose, which Parcel to update.
     */
    where: ParcelWhereUniqueInput
  }

  /**
   * Parcel updateMany
   */
  export type ParcelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parcels.
     */
    data: XOR<ParcelUpdateManyMutationInput, ParcelUncheckedUpdateManyInput>
    /**
     * Filter which Parcels to update
     */
    where?: ParcelWhereInput
    /**
     * Limit how many Parcels to update.
     */
    limit?: number
  }

  /**
   * Parcel updateManyAndReturn
   */
  export type ParcelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * The data used to update Parcels.
     */
    data: XOR<ParcelUpdateManyMutationInput, ParcelUncheckedUpdateManyInput>
    /**
     * Filter which Parcels to update
     */
    where?: ParcelWhereInput
    /**
     * Limit how many Parcels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parcel upsert
   */
  export type ParcelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * The filter to search for the Parcel to update in case it exists.
     */
    where: ParcelWhereUniqueInput
    /**
     * In case the Parcel found by the `where` argument doesn't exist, create a new Parcel with this data.
     */
    create: XOR<ParcelCreateInput, ParcelUncheckedCreateInput>
    /**
     * In case the Parcel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParcelUpdateInput, ParcelUncheckedUpdateInput>
  }

  /**
   * Parcel delete
   */
  export type ParcelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter which Parcel to delete.
     */
    where: ParcelWhereUniqueInput
  }

  /**
   * Parcel deleteMany
   */
  export type ParcelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parcels to delete
     */
    where?: ParcelWhereInput
    /**
     * Limit how many Parcels to delete.
     */
    limit?: number
  }

  /**
   * Parcel without action
   */
  export type ParcelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
  }


  /**
   * Model Tarifs
   */

  export type AggregateTarifs = {
    _count: TarifsCountAggregateOutputType | null
    _avg: TarifsAvgAggregateOutputType | null
    _sum: TarifsSumAggregateOutputType | null
    _min: TarifsMinAggregateOutputType | null
    _max: TarifsMaxAggregateOutputType | null
  }

  export type TarifsAvgAggregateOutputType = {
    id: number | null
    agencyId: number | null
    weightRate: Decimal | null
    volumeRate: Decimal | null
    baseRate: Decimal | null
    fixedRate: Decimal | null
  }

  export type TarifsSumAggregateOutputType = {
    id: number | null
    agencyId: number | null
    weightRate: Decimal | null
    volumeRate: Decimal | null
    baseRate: Decimal | null
    fixedRate: Decimal | null
  }

  export type TarifsMinAggregateOutputType = {
    id: number | null
    agencyId: number | null
    weightRate: Decimal | null
    volumeRate: Decimal | null
    baseRate: Decimal | null
    fixedRate: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TarifsMaxAggregateOutputType = {
    id: number | null
    agencyId: number | null
    weightRate: Decimal | null
    volumeRate: Decimal | null
    baseRate: Decimal | null
    fixedRate: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TarifsCountAggregateOutputType = {
    id: number
    agencyId: number
    weightRate: number
    volumeRate: number
    baseRate: number
    fixedRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TarifsAvgAggregateInputType = {
    id?: true
    agencyId?: true
    weightRate?: true
    volumeRate?: true
    baseRate?: true
    fixedRate?: true
  }

  export type TarifsSumAggregateInputType = {
    id?: true
    agencyId?: true
    weightRate?: true
    volumeRate?: true
    baseRate?: true
    fixedRate?: true
  }

  export type TarifsMinAggregateInputType = {
    id?: true
    agencyId?: true
    weightRate?: true
    volumeRate?: true
    baseRate?: true
    fixedRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TarifsMaxAggregateInputType = {
    id?: true
    agencyId?: true
    weightRate?: true
    volumeRate?: true
    baseRate?: true
    fixedRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TarifsCountAggregateInputType = {
    id?: true
    agencyId?: true
    weightRate?: true
    volumeRate?: true
    baseRate?: true
    fixedRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TarifsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tarifs to aggregate.
     */
    where?: TarifsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifs to fetch.
     */
    orderBy?: TarifsOrderByWithRelationInput | TarifsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TarifsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tarifs
    **/
    _count?: true | TarifsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TarifsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TarifsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TarifsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TarifsMaxAggregateInputType
  }

  export type GetTarifsAggregateType<T extends TarifsAggregateArgs> = {
        [P in keyof T & keyof AggregateTarifs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTarifs[P]>
      : GetScalarType<T[P], AggregateTarifs[P]>
  }




  export type TarifsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TarifsWhereInput
    orderBy?: TarifsOrderByWithAggregationInput | TarifsOrderByWithAggregationInput[]
    by: TarifsScalarFieldEnum[] | TarifsScalarFieldEnum
    having?: TarifsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TarifsCountAggregateInputType | true
    _avg?: TarifsAvgAggregateInputType
    _sum?: TarifsSumAggregateInputType
    _min?: TarifsMinAggregateInputType
    _max?: TarifsMaxAggregateInputType
  }

  export type TarifsGroupByOutputType = {
    id: number
    agencyId: number | null
    weightRate: Decimal
    volumeRate: Decimal
    baseRate: Decimal
    fixedRate: Decimal
    createdAt: Date
    updatedAt: Date
    _count: TarifsCountAggregateOutputType | null
    _avg: TarifsAvgAggregateOutputType | null
    _sum: TarifsSumAggregateOutputType | null
    _min: TarifsMinAggregateOutputType | null
    _max: TarifsMaxAggregateOutputType | null
  }

  type GetTarifsGroupByPayload<T extends TarifsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TarifsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TarifsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TarifsGroupByOutputType[P]>
            : GetScalarType<T[P], TarifsGroupByOutputType[P]>
        }
      >
    >


  export type TarifsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    weightRate?: boolean
    volumeRate?: boolean
    baseRate?: boolean
    fixedRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | Tarifs$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["tarifs"]>

  export type TarifsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    weightRate?: boolean
    volumeRate?: boolean
    baseRate?: boolean
    fixedRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | Tarifs$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["tarifs"]>

  export type TarifsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    weightRate?: boolean
    volumeRate?: boolean
    baseRate?: boolean
    fixedRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | Tarifs$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["tarifs"]>

  export type TarifsSelectScalar = {
    id?: boolean
    agencyId?: boolean
    weightRate?: boolean
    volumeRate?: boolean
    baseRate?: boolean
    fixedRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TarifsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agencyId" | "weightRate" | "volumeRate" | "baseRate" | "fixedRate" | "createdAt" | "updatedAt", ExtArgs["result"]["tarifs"]>
  export type TarifsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | Tarifs$agencyArgs<ExtArgs>
  }
  export type TarifsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | Tarifs$agencyArgs<ExtArgs>
  }
  export type TarifsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | Tarifs$agencyArgs<ExtArgs>
  }

  export type $TarifsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tarifs"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      agencyId: number | null
      weightRate: Prisma.Decimal
      volumeRate: Prisma.Decimal
      baseRate: Prisma.Decimal
      fixedRate: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tarifs"]>
    composites: {}
  }

  type TarifsGetPayload<S extends boolean | null | undefined | TarifsDefaultArgs> = $Result.GetResult<Prisma.$TarifsPayload, S>

  type TarifsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TarifsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TarifsCountAggregateInputType | true
    }

  export interface TarifsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tarifs'], meta: { name: 'Tarifs' } }
    /**
     * Find zero or one Tarifs that matches the filter.
     * @param {TarifsFindUniqueArgs} args - Arguments to find a Tarifs
     * @example
     * // Get one Tarifs
     * const tarifs = await prisma.tarifs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TarifsFindUniqueArgs>(args: SelectSubset<T, TarifsFindUniqueArgs<ExtArgs>>): Prisma__TarifsClient<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tarifs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TarifsFindUniqueOrThrowArgs} args - Arguments to find a Tarifs
     * @example
     * // Get one Tarifs
     * const tarifs = await prisma.tarifs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TarifsFindUniqueOrThrowArgs>(args: SelectSubset<T, TarifsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TarifsClient<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tarifs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifsFindFirstArgs} args - Arguments to find a Tarifs
     * @example
     * // Get one Tarifs
     * const tarifs = await prisma.tarifs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TarifsFindFirstArgs>(args?: SelectSubset<T, TarifsFindFirstArgs<ExtArgs>>): Prisma__TarifsClient<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tarifs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifsFindFirstOrThrowArgs} args - Arguments to find a Tarifs
     * @example
     * // Get one Tarifs
     * const tarifs = await prisma.tarifs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TarifsFindFirstOrThrowArgs>(args?: SelectSubset<T, TarifsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TarifsClient<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tarifs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tarifs
     * const tarifs = await prisma.tarifs.findMany()
     * 
     * // Get first 10 Tarifs
     * const tarifs = await prisma.tarifs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tarifsWithIdOnly = await prisma.tarifs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TarifsFindManyArgs>(args?: SelectSubset<T, TarifsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tarifs.
     * @param {TarifsCreateArgs} args - Arguments to create a Tarifs.
     * @example
     * // Create one Tarifs
     * const Tarifs = await prisma.tarifs.create({
     *   data: {
     *     // ... data to create a Tarifs
     *   }
     * })
     * 
     */
    create<T extends TarifsCreateArgs>(args: SelectSubset<T, TarifsCreateArgs<ExtArgs>>): Prisma__TarifsClient<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tarifs.
     * @param {TarifsCreateManyArgs} args - Arguments to create many Tarifs.
     * @example
     * // Create many Tarifs
     * const tarifs = await prisma.tarifs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TarifsCreateManyArgs>(args?: SelectSubset<T, TarifsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tarifs and returns the data saved in the database.
     * @param {TarifsCreateManyAndReturnArgs} args - Arguments to create many Tarifs.
     * @example
     * // Create many Tarifs
     * const tarifs = await prisma.tarifs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tarifs and only return the `id`
     * const tarifsWithIdOnly = await prisma.tarifs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TarifsCreateManyAndReturnArgs>(args?: SelectSubset<T, TarifsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tarifs.
     * @param {TarifsDeleteArgs} args - Arguments to delete one Tarifs.
     * @example
     * // Delete one Tarifs
     * const Tarifs = await prisma.tarifs.delete({
     *   where: {
     *     // ... filter to delete one Tarifs
     *   }
     * })
     * 
     */
    delete<T extends TarifsDeleteArgs>(args: SelectSubset<T, TarifsDeleteArgs<ExtArgs>>): Prisma__TarifsClient<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tarifs.
     * @param {TarifsUpdateArgs} args - Arguments to update one Tarifs.
     * @example
     * // Update one Tarifs
     * const tarifs = await prisma.tarifs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TarifsUpdateArgs>(args: SelectSubset<T, TarifsUpdateArgs<ExtArgs>>): Prisma__TarifsClient<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tarifs.
     * @param {TarifsDeleteManyArgs} args - Arguments to filter Tarifs to delete.
     * @example
     * // Delete a few Tarifs
     * const { count } = await prisma.tarifs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TarifsDeleteManyArgs>(args?: SelectSubset<T, TarifsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tarifs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tarifs
     * const tarifs = await prisma.tarifs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TarifsUpdateManyArgs>(args: SelectSubset<T, TarifsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tarifs and returns the data updated in the database.
     * @param {TarifsUpdateManyAndReturnArgs} args - Arguments to update many Tarifs.
     * @example
     * // Update many Tarifs
     * const tarifs = await prisma.tarifs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tarifs and only return the `id`
     * const tarifsWithIdOnly = await prisma.tarifs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TarifsUpdateManyAndReturnArgs>(args: SelectSubset<T, TarifsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tarifs.
     * @param {TarifsUpsertArgs} args - Arguments to update or create a Tarifs.
     * @example
     * // Update or create a Tarifs
     * const tarifs = await prisma.tarifs.upsert({
     *   create: {
     *     // ... data to create a Tarifs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tarifs we want to update
     *   }
     * })
     */
    upsert<T extends TarifsUpsertArgs>(args: SelectSubset<T, TarifsUpsertArgs<ExtArgs>>): Prisma__TarifsClient<$Result.GetResult<Prisma.$TarifsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tarifs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifsCountArgs} args - Arguments to filter Tarifs to count.
     * @example
     * // Count the number of Tarifs
     * const count = await prisma.tarifs.count({
     *   where: {
     *     // ... the filter for the Tarifs we want to count
     *   }
     * })
    **/
    count<T extends TarifsCountArgs>(
      args?: Subset<T, TarifsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TarifsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tarifs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TarifsAggregateArgs>(args: Subset<T, TarifsAggregateArgs>): Prisma.PrismaPromise<GetTarifsAggregateType<T>>

    /**
     * Group by Tarifs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TarifsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TarifsGroupByArgs['orderBy'] }
        : { orderBy?: TarifsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TarifsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTarifsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tarifs model
   */
  readonly fields: TarifsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tarifs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TarifsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends Tarifs$agencyArgs<ExtArgs> = {}>(args?: Subset<T, Tarifs$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tarifs model
   */
  interface TarifsFieldRefs {
    readonly id: FieldRef<"Tarifs", 'Int'>
    readonly agencyId: FieldRef<"Tarifs", 'Int'>
    readonly weightRate: FieldRef<"Tarifs", 'Decimal'>
    readonly volumeRate: FieldRef<"Tarifs", 'Decimal'>
    readonly baseRate: FieldRef<"Tarifs", 'Decimal'>
    readonly fixedRate: FieldRef<"Tarifs", 'Decimal'>
    readonly createdAt: FieldRef<"Tarifs", 'DateTime'>
    readonly updatedAt: FieldRef<"Tarifs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tarifs findUnique
   */
  export type TarifsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    /**
     * Filter, which Tarifs to fetch.
     */
    where: TarifsWhereUniqueInput
  }

  /**
   * Tarifs findUniqueOrThrow
   */
  export type TarifsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    /**
     * Filter, which Tarifs to fetch.
     */
    where: TarifsWhereUniqueInput
  }

  /**
   * Tarifs findFirst
   */
  export type TarifsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    /**
     * Filter, which Tarifs to fetch.
     */
    where?: TarifsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifs to fetch.
     */
    orderBy?: TarifsOrderByWithRelationInput | TarifsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tarifs.
     */
    cursor?: TarifsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tarifs.
     */
    distinct?: TarifsScalarFieldEnum | TarifsScalarFieldEnum[]
  }

  /**
   * Tarifs findFirstOrThrow
   */
  export type TarifsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    /**
     * Filter, which Tarifs to fetch.
     */
    where?: TarifsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifs to fetch.
     */
    orderBy?: TarifsOrderByWithRelationInput | TarifsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tarifs.
     */
    cursor?: TarifsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tarifs.
     */
    distinct?: TarifsScalarFieldEnum | TarifsScalarFieldEnum[]
  }

  /**
   * Tarifs findMany
   */
  export type TarifsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    /**
     * Filter, which Tarifs to fetch.
     */
    where?: TarifsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifs to fetch.
     */
    orderBy?: TarifsOrderByWithRelationInput | TarifsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tarifs.
     */
    cursor?: TarifsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifs.
     */
    skip?: number
    distinct?: TarifsScalarFieldEnum | TarifsScalarFieldEnum[]
  }

  /**
   * Tarifs create
   */
  export type TarifsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tarifs.
     */
    data: XOR<TarifsCreateInput, TarifsUncheckedCreateInput>
  }

  /**
   * Tarifs createMany
   */
  export type TarifsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tarifs.
     */
    data: TarifsCreateManyInput | TarifsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tarifs createManyAndReturn
   */
  export type TarifsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * The data used to create many Tarifs.
     */
    data: TarifsCreateManyInput | TarifsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tarifs update
   */
  export type TarifsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tarifs.
     */
    data: XOR<TarifsUpdateInput, TarifsUncheckedUpdateInput>
    /**
     * Choose, which Tarifs to update.
     */
    where: TarifsWhereUniqueInput
  }

  /**
   * Tarifs updateMany
   */
  export type TarifsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tarifs.
     */
    data: XOR<TarifsUpdateManyMutationInput, TarifsUncheckedUpdateManyInput>
    /**
     * Filter which Tarifs to update
     */
    where?: TarifsWhereInput
    /**
     * Limit how many Tarifs to update.
     */
    limit?: number
  }

  /**
   * Tarifs updateManyAndReturn
   */
  export type TarifsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * The data used to update Tarifs.
     */
    data: XOR<TarifsUpdateManyMutationInput, TarifsUncheckedUpdateManyInput>
    /**
     * Filter which Tarifs to update
     */
    where?: TarifsWhereInput
    /**
     * Limit how many Tarifs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tarifs upsert
   */
  export type TarifsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tarifs to update in case it exists.
     */
    where: TarifsWhereUniqueInput
    /**
     * In case the Tarifs found by the `where` argument doesn't exist, create a new Tarifs with this data.
     */
    create: XOR<TarifsCreateInput, TarifsUncheckedCreateInput>
    /**
     * In case the Tarifs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TarifsUpdateInput, TarifsUncheckedUpdateInput>
  }

  /**
   * Tarifs delete
   */
  export type TarifsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
    /**
     * Filter which Tarifs to delete.
     */
    where: TarifsWhereUniqueInput
  }

  /**
   * Tarifs deleteMany
   */
  export type TarifsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tarifs to delete
     */
    where?: TarifsWhereInput
    /**
     * Limit how many Tarifs to delete.
     */
    limit?: number
  }

  /**
   * Tarifs.agency
   */
  export type Tarifs$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Tarifs without action
   */
  export type TarifsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifs
     */
    select?: TarifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tarifs
     */
    omit?: TarifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifsInclude<ExtArgs> | null
  }


  /**
   * Model TransportSchedule
   */

  export type AggregateTransportSchedule = {
    _count: TransportScheduleCountAggregateOutputType | null
    _avg: TransportScheduleAvgAggregateOutputType | null
    _sum: TransportScheduleSumAggregateOutputType | null
    _min: TransportScheduleMinAggregateOutputType | null
    _max: TransportScheduleMaxAggregateOutputType | null
  }

  export type TransportScheduleAvgAggregateOutputType = {
    id: number | null
    transportId: number | null
  }

  export type TransportScheduleSumAggregateOutputType = {
    id: number | null
    transportId: number | null
  }

  export type TransportScheduleMinAggregateOutputType = {
    id: number | null
    transportId: number | null
    departureDate: Date | null
    arrivalDate: Date | null
    isHoliday: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransportScheduleMaxAggregateOutputType = {
    id: number | null
    transportId: number | null
    departureDate: Date | null
    arrivalDate: Date | null
    isHoliday: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransportScheduleCountAggregateOutputType = {
    id: number
    transportId: number
    departureDate: number
    arrivalDate: number
    isHoliday: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransportScheduleAvgAggregateInputType = {
    id?: true
    transportId?: true
  }

  export type TransportScheduleSumAggregateInputType = {
    id?: true
    transportId?: true
  }

  export type TransportScheduleMinAggregateInputType = {
    id?: true
    transportId?: true
    departureDate?: true
    arrivalDate?: true
    isHoliday?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransportScheduleMaxAggregateInputType = {
    id?: true
    transportId?: true
    departureDate?: true
    arrivalDate?: true
    isHoliday?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransportScheduleCountAggregateInputType = {
    id?: true
    transportId?: true
    departureDate?: true
    arrivalDate?: true
    isHoliday?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransportScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransportSchedule to aggregate.
     */
    where?: TransportScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportSchedules to fetch.
     */
    orderBy?: TransportScheduleOrderByWithRelationInput | TransportScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransportScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransportSchedules
    **/
    _count?: true | TransportScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransportScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransportScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransportScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransportScheduleMaxAggregateInputType
  }

  export type GetTransportScheduleAggregateType<T extends TransportScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateTransportSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransportSchedule[P]>
      : GetScalarType<T[P], AggregateTransportSchedule[P]>
  }




  export type TransportScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportScheduleWhereInput
    orderBy?: TransportScheduleOrderByWithAggregationInput | TransportScheduleOrderByWithAggregationInput[]
    by: TransportScheduleScalarFieldEnum[] | TransportScheduleScalarFieldEnum
    having?: TransportScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransportScheduleCountAggregateInputType | true
    _avg?: TransportScheduleAvgAggregateInputType
    _sum?: TransportScheduleSumAggregateInputType
    _min?: TransportScheduleMinAggregateInputType
    _max?: TransportScheduleMaxAggregateInputType
  }

  export type TransportScheduleGroupByOutputType = {
    id: number
    transportId: number
    departureDate: Date
    arrivalDate: Date
    isHoliday: boolean
    createdAt: Date
    updatedAt: Date
    _count: TransportScheduleCountAggregateOutputType | null
    _avg: TransportScheduleAvgAggregateOutputType | null
    _sum: TransportScheduleSumAggregateOutputType | null
    _min: TransportScheduleMinAggregateOutputType | null
    _max: TransportScheduleMaxAggregateOutputType | null
  }

  type GetTransportScheduleGroupByPayload<T extends TransportScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransportScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransportScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransportScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], TransportScheduleGroupByOutputType[P]>
        }
      >
    >


  export type TransportScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transportId?: boolean
    departureDate?: boolean
    arrivalDate?: boolean
    isHoliday?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transport?: boolean | TransportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transportSchedule"]>

  export type TransportScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transportId?: boolean
    departureDate?: boolean
    arrivalDate?: boolean
    isHoliday?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transport?: boolean | TransportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transportSchedule"]>

  export type TransportScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transportId?: boolean
    departureDate?: boolean
    arrivalDate?: boolean
    isHoliday?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transport?: boolean | TransportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transportSchedule"]>

  export type TransportScheduleSelectScalar = {
    id?: boolean
    transportId?: boolean
    departureDate?: boolean
    arrivalDate?: boolean
    isHoliday?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransportScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transportId" | "departureDate" | "arrivalDate" | "isHoliday" | "createdAt" | "updatedAt", ExtArgs["result"]["transportSchedule"]>
  export type TransportScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transport?: boolean | TransportDefaultArgs<ExtArgs>
  }
  export type TransportScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transport?: boolean | TransportDefaultArgs<ExtArgs>
  }
  export type TransportScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transport?: boolean | TransportDefaultArgs<ExtArgs>
  }

  export type $TransportSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransportSchedule"
    objects: {
      transport: Prisma.$TransportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transportId: number
      departureDate: Date
      arrivalDate: Date
      isHoliday: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transportSchedule"]>
    composites: {}
  }

  type TransportScheduleGetPayload<S extends boolean | null | undefined | TransportScheduleDefaultArgs> = $Result.GetResult<Prisma.$TransportSchedulePayload, S>

  type TransportScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransportScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransportScheduleCountAggregateInputType | true
    }

  export interface TransportScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransportSchedule'], meta: { name: 'TransportSchedule' } }
    /**
     * Find zero or one TransportSchedule that matches the filter.
     * @param {TransportScheduleFindUniqueArgs} args - Arguments to find a TransportSchedule
     * @example
     * // Get one TransportSchedule
     * const transportSchedule = await prisma.transportSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransportScheduleFindUniqueArgs>(args: SelectSubset<T, TransportScheduleFindUniqueArgs<ExtArgs>>): Prisma__TransportScheduleClient<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransportSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransportScheduleFindUniqueOrThrowArgs} args - Arguments to find a TransportSchedule
     * @example
     * // Get one TransportSchedule
     * const transportSchedule = await prisma.transportSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransportScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, TransportScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransportScheduleClient<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransportSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportScheduleFindFirstArgs} args - Arguments to find a TransportSchedule
     * @example
     * // Get one TransportSchedule
     * const transportSchedule = await prisma.transportSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransportScheduleFindFirstArgs>(args?: SelectSubset<T, TransportScheduleFindFirstArgs<ExtArgs>>): Prisma__TransportScheduleClient<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransportSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportScheduleFindFirstOrThrowArgs} args - Arguments to find a TransportSchedule
     * @example
     * // Get one TransportSchedule
     * const transportSchedule = await prisma.transportSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransportScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, TransportScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransportScheduleClient<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransportSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransportSchedules
     * const transportSchedules = await prisma.transportSchedule.findMany()
     * 
     * // Get first 10 TransportSchedules
     * const transportSchedules = await prisma.transportSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transportScheduleWithIdOnly = await prisma.transportSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransportScheduleFindManyArgs>(args?: SelectSubset<T, TransportScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransportSchedule.
     * @param {TransportScheduleCreateArgs} args - Arguments to create a TransportSchedule.
     * @example
     * // Create one TransportSchedule
     * const TransportSchedule = await prisma.transportSchedule.create({
     *   data: {
     *     // ... data to create a TransportSchedule
     *   }
     * })
     * 
     */
    create<T extends TransportScheduleCreateArgs>(args: SelectSubset<T, TransportScheduleCreateArgs<ExtArgs>>): Prisma__TransportScheduleClient<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransportSchedules.
     * @param {TransportScheduleCreateManyArgs} args - Arguments to create many TransportSchedules.
     * @example
     * // Create many TransportSchedules
     * const transportSchedule = await prisma.transportSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransportScheduleCreateManyArgs>(args?: SelectSubset<T, TransportScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransportSchedules and returns the data saved in the database.
     * @param {TransportScheduleCreateManyAndReturnArgs} args - Arguments to create many TransportSchedules.
     * @example
     * // Create many TransportSchedules
     * const transportSchedule = await prisma.transportSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransportSchedules and only return the `id`
     * const transportScheduleWithIdOnly = await prisma.transportSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransportScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, TransportScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransportSchedule.
     * @param {TransportScheduleDeleteArgs} args - Arguments to delete one TransportSchedule.
     * @example
     * // Delete one TransportSchedule
     * const TransportSchedule = await prisma.transportSchedule.delete({
     *   where: {
     *     // ... filter to delete one TransportSchedule
     *   }
     * })
     * 
     */
    delete<T extends TransportScheduleDeleteArgs>(args: SelectSubset<T, TransportScheduleDeleteArgs<ExtArgs>>): Prisma__TransportScheduleClient<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransportSchedule.
     * @param {TransportScheduleUpdateArgs} args - Arguments to update one TransportSchedule.
     * @example
     * // Update one TransportSchedule
     * const transportSchedule = await prisma.transportSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransportScheduleUpdateArgs>(args: SelectSubset<T, TransportScheduleUpdateArgs<ExtArgs>>): Prisma__TransportScheduleClient<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransportSchedules.
     * @param {TransportScheduleDeleteManyArgs} args - Arguments to filter TransportSchedules to delete.
     * @example
     * // Delete a few TransportSchedules
     * const { count } = await prisma.transportSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransportScheduleDeleteManyArgs>(args?: SelectSubset<T, TransportScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransportSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransportSchedules
     * const transportSchedule = await prisma.transportSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransportScheduleUpdateManyArgs>(args: SelectSubset<T, TransportScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransportSchedules and returns the data updated in the database.
     * @param {TransportScheduleUpdateManyAndReturnArgs} args - Arguments to update many TransportSchedules.
     * @example
     * // Update many TransportSchedules
     * const transportSchedule = await prisma.transportSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransportSchedules and only return the `id`
     * const transportScheduleWithIdOnly = await prisma.transportSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransportScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, TransportScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransportSchedule.
     * @param {TransportScheduleUpsertArgs} args - Arguments to update or create a TransportSchedule.
     * @example
     * // Update or create a TransportSchedule
     * const transportSchedule = await prisma.transportSchedule.upsert({
     *   create: {
     *     // ... data to create a TransportSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransportSchedule we want to update
     *   }
     * })
     */
    upsert<T extends TransportScheduleUpsertArgs>(args: SelectSubset<T, TransportScheduleUpsertArgs<ExtArgs>>): Prisma__TransportScheduleClient<$Result.GetResult<Prisma.$TransportSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransportSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportScheduleCountArgs} args - Arguments to filter TransportSchedules to count.
     * @example
     * // Count the number of TransportSchedules
     * const count = await prisma.transportSchedule.count({
     *   where: {
     *     // ... the filter for the TransportSchedules we want to count
     *   }
     * })
    **/
    count<T extends TransportScheduleCountArgs>(
      args?: Subset<T, TransportScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransportScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransportSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransportScheduleAggregateArgs>(args: Subset<T, TransportScheduleAggregateArgs>): Prisma.PrismaPromise<GetTransportScheduleAggregateType<T>>

    /**
     * Group by TransportSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransportScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransportScheduleGroupByArgs['orderBy'] }
        : { orderBy?: TransportScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransportScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransportScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransportSchedule model
   */
  readonly fields: TransportScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransportSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransportScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transport<T extends TransportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransportDefaultArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransportSchedule model
   */
  interface TransportScheduleFieldRefs {
    readonly id: FieldRef<"TransportSchedule", 'Int'>
    readonly transportId: FieldRef<"TransportSchedule", 'Int'>
    readonly departureDate: FieldRef<"TransportSchedule", 'DateTime'>
    readonly arrivalDate: FieldRef<"TransportSchedule", 'DateTime'>
    readonly isHoliday: FieldRef<"TransportSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"TransportSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"TransportSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransportSchedule findUnique
   */
  export type TransportScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TransportSchedule to fetch.
     */
    where: TransportScheduleWhereUniqueInput
  }

  /**
   * TransportSchedule findUniqueOrThrow
   */
  export type TransportScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TransportSchedule to fetch.
     */
    where: TransportScheduleWhereUniqueInput
  }

  /**
   * TransportSchedule findFirst
   */
  export type TransportScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TransportSchedule to fetch.
     */
    where?: TransportScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportSchedules to fetch.
     */
    orderBy?: TransportScheduleOrderByWithRelationInput | TransportScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransportSchedules.
     */
    cursor?: TransportScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransportSchedules.
     */
    distinct?: TransportScheduleScalarFieldEnum | TransportScheduleScalarFieldEnum[]
  }

  /**
   * TransportSchedule findFirstOrThrow
   */
  export type TransportScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TransportSchedule to fetch.
     */
    where?: TransportScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportSchedules to fetch.
     */
    orderBy?: TransportScheduleOrderByWithRelationInput | TransportScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransportSchedules.
     */
    cursor?: TransportScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransportSchedules.
     */
    distinct?: TransportScheduleScalarFieldEnum | TransportScheduleScalarFieldEnum[]
  }

  /**
   * TransportSchedule findMany
   */
  export type TransportScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TransportSchedules to fetch.
     */
    where?: TransportScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportSchedules to fetch.
     */
    orderBy?: TransportScheduleOrderByWithRelationInput | TransportScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransportSchedules.
     */
    cursor?: TransportScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportSchedules.
     */
    skip?: number
    distinct?: TransportScheduleScalarFieldEnum | TransportScheduleScalarFieldEnum[]
  }

  /**
   * TransportSchedule create
   */
  export type TransportScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a TransportSchedule.
     */
    data: XOR<TransportScheduleCreateInput, TransportScheduleUncheckedCreateInput>
  }

  /**
   * TransportSchedule createMany
   */
  export type TransportScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransportSchedules.
     */
    data: TransportScheduleCreateManyInput | TransportScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransportSchedule createManyAndReturn
   */
  export type TransportScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many TransportSchedules.
     */
    data: TransportScheduleCreateManyInput | TransportScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransportSchedule update
   */
  export type TransportScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a TransportSchedule.
     */
    data: XOR<TransportScheduleUpdateInput, TransportScheduleUncheckedUpdateInput>
    /**
     * Choose, which TransportSchedule to update.
     */
    where: TransportScheduleWhereUniqueInput
  }

  /**
   * TransportSchedule updateMany
   */
  export type TransportScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransportSchedules.
     */
    data: XOR<TransportScheduleUpdateManyMutationInput, TransportScheduleUncheckedUpdateManyInput>
    /**
     * Filter which TransportSchedules to update
     */
    where?: TransportScheduleWhereInput
    /**
     * Limit how many TransportSchedules to update.
     */
    limit?: number
  }

  /**
   * TransportSchedule updateManyAndReturn
   */
  export type TransportScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * The data used to update TransportSchedules.
     */
    data: XOR<TransportScheduleUpdateManyMutationInput, TransportScheduleUncheckedUpdateManyInput>
    /**
     * Filter which TransportSchedules to update
     */
    where?: TransportScheduleWhereInput
    /**
     * Limit how many TransportSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransportSchedule upsert
   */
  export type TransportScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the TransportSchedule to update in case it exists.
     */
    where: TransportScheduleWhereUniqueInput
    /**
     * In case the TransportSchedule found by the `where` argument doesn't exist, create a new TransportSchedule with this data.
     */
    create: XOR<TransportScheduleCreateInput, TransportScheduleUncheckedCreateInput>
    /**
     * In case the TransportSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransportScheduleUpdateInput, TransportScheduleUncheckedUpdateInput>
  }

  /**
   * TransportSchedule delete
   */
  export type TransportScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
    /**
     * Filter which TransportSchedule to delete.
     */
    where: TransportScheduleWhereUniqueInput
  }

  /**
   * TransportSchedule deleteMany
   */
  export type TransportScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransportSchedules to delete
     */
    where?: TransportScheduleWhereInput
    /**
     * Limit how many TransportSchedules to delete.
     */
    limit?: number
  }

  /**
   * TransportSchedule without action
   */
  export type TransportScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSchedule
     */
    select?: TransportScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransportSchedule
     */
    omit?: TransportScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportScheduleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    expiresAt: 'expiresAt',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    envoiId: 'envoiId',
    method: 'method',
    status: 'status',
    amount: 'amount',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    name: 'name',
    birthDate: 'birthDate',
    email: 'email',
    phoneNumber: 'phoneNumber',
    password: 'password',
    image: 'image',
    role: 'role',
    isVerified: 'isVerified',
    emailVerified: 'emailVerified',
    verificationToken: 'verificationToken',
    verificationTokenExpires: 'verificationTokenExpires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isEnterprise: 'isEnterprise',
    lastLogin: 'lastLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AgencyClientsScalarFieldEnum: {
    clientId: 'clientId',
    agencyId: 'agencyId'
  };

  export type AgencyClientsScalarFieldEnum = (typeof AgencyClientsScalarFieldEnum)[keyof typeof AgencyClientsScalarFieldEnum]


  export const AgencyStaffScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    agencyId: 'agencyId',
    staffRole: 'staffRole'
  };

  export type AgencyStaffScalarFieldEnum = (typeof AgencyStaffScalarFieldEnum)[keyof typeof AgencyStaffScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    activityType: 'activityType',
    staffId: 'staffId',
    agencyId: 'agencyId',
    details: 'details',
    staffRole: 'staffRole',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const AuthenticatorScalarFieldEnum: {
    credentialID: 'credentialID',
    userId: 'userId',
    providerAccountId: 'providerAccountId',
    credentialPublicKey: 'credentialPublicKey',
    counter: 'counter',
    credentialDeviceType: 'credentialDeviceType',
    credentialBackedUp: 'credentialBackedUp',
    transports: 'transports'
  };

  export type AuthenticatorScalarFieldEnum = (typeof AuthenticatorScalarFieldEnum)[keyof typeof AuthenticatorScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    message: 'message',
    agencyId: 'agencyId',
    destinataireId: 'destinataireId',
    clientId: 'clientId',
    envoiId: 'envoiId',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const VatRateScalarFieldEnum: {
    id: 'id',
    countryId: 'countryId',
    itemClassId: 'itemClassId',
    vatPercent: 'vatPercent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vatType: 'vatType'
  };

  export type VatRateScalarFieldEnum = (typeof VatRateScalarFieldEnum)[keyof typeof VatRateScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    latitude: 'latitude',
    longitude: 'longitude',
    countryId: 'countryId'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    iso2: 'iso2',
    iso3: 'iso3',
    phonecode: 'phonecode',
    capital: 'capital',
    currency: 'currency',
    latitude: 'latitude',
    longitude: 'longitude',
    emoji: 'emoji'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const TimezoneScalarFieldEnum: {
    id: 'id',
    zoneName: 'zoneName',
    gmtOffset: 'gmtOffset',
    abbreviation: 'abbreviation',
    countryId: 'countryId'
  };

  export type TimezoneScalarFieldEnum = (typeof TimezoneScalarFieldEnum)[keyof typeof TimezoneScalarFieldEnum]


  export const UserAddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    addressId: 'addressId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    addressType: 'addressType'
  };

  export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    street: 'street',
    complement: 'complement',
    streetNumber: 'streetNumber',
    boxNumber: 'boxNumber',
    cityId: 'cityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    phoneNumber: 'phoneNumber',
    email: 'email',
    vatNumber: 'vatNumber',
    addressId: 'addressId',
    capacity: 'capacity',
    availableSlots: 'availableSlots',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const ClientDestinataireScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    destinataireId: 'destinataireId',
    createdAt: 'createdAt'
  };

  export type ClientDestinataireScalarFieldEnum = (typeof ClientDestinataireScalarFieldEnum)[keyof typeof ClientDestinataireScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    couponCode: 'couponCode',
    discountAmount: 'discountAmount',
    discountPercentage: 'discountPercentage',
    numberOfUses: 'numberOfUses',
    startDate: 'startDate',
    expirationDate: 'expirationDate',
    termsAndConditions: 'termsAndConditions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const UserCouponScalarFieldEnum: {
    userId: 'userId',
    couponId: 'couponId'
  };

  export type UserCouponScalarFieldEnum = (typeof UserCouponScalarFieldEnum)[keyof typeof UserCouponScalarFieldEnum]


  export const TransportScalarFieldEnum: {
    id: 'id',
    number: 'number',
    baseVolume: 'baseVolume',
    baseWeight: 'baseWeight',
    currentVolume: 'currentVolume',
    currentWeight: 'currentWeight',
    isAvailable: 'isAvailable',
    agencyId: 'agencyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransportScalarFieldEnum = (typeof TransportScalarFieldEnum)[keyof typeof TransportScalarFieldEnum]


  export const EnvoiScalarFieldEnum: {
    id: 'id',
    trackingNumber: 'trackingNumber',
    qrCodeUrl: 'qrCodeUrl',
    userId: 'userId',
    destinataireId: 'destinataireId',
    transportId: 'transportId',
    departureAgencyId: 'departureAgencyId',
    arrivalAgencyId: 'arrivalAgencyId',
    simulationStatus: 'simulationStatus',
    envoiStatus: 'envoiStatus',
    totalWeight: 'totalWeight',
    totalVolume: 'totalVolume',
    totalPrice: 'totalPrice',
    paid: 'paid',
    departureDate: 'departureDate',
    arrivalDate: 'arrivalDate',
    verificationToken: 'verificationToken',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnvoiScalarFieldEnum = (typeof EnvoiScalarFieldEnum)[keyof typeof EnvoiScalarFieldEnum]


  export const TrackingEventScalarFieldEnum: {
    id: 'id',
    envoiId: 'envoiId',
    eventStatus: 'eventStatus',
    location: 'location',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type TrackingEventScalarFieldEnum = (typeof TrackingEventScalarFieldEnum)[keyof typeof TrackingEventScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    envoiId: 'envoiId',
    agencyId: 'agencyId',
    date: 'date',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const EnvoiCouponScalarFieldEnum: {
    envoiId: 'envoiId',
    couponId: 'couponId'
  };

  export type EnvoiCouponScalarFieldEnum = (typeof EnvoiCouponScalarFieldEnum)[keyof typeof EnvoiCouponScalarFieldEnum]


  export const ParcelScalarFieldEnum: {
    id: 'id',
    envoiId: 'envoiId',
    height: 'height',
    weight: 'weight',
    width: 'width',
    length: 'length',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParcelScalarFieldEnum = (typeof ParcelScalarFieldEnum)[keyof typeof ParcelScalarFieldEnum]


  export const TarifsScalarFieldEnum: {
    id: 'id',
    agencyId: 'agencyId',
    weightRate: 'weightRate',
    volumeRate: 'volumeRate',
    baseRate: 'baseRate',
    fixedRate: 'fixedRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TarifsScalarFieldEnum = (typeof TarifsScalarFieldEnum)[keyof typeof TarifsScalarFieldEnum]


  export const TransportScheduleScalarFieldEnum: {
    id: 'id',
    transportId: 'transportId',
    departureDate: 'departureDate',
    arrivalDate: 'arrivalDate',
    isHoliday: 'isHoliday',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransportScheduleScalarFieldEnum = (typeof TransportScheduleScalarFieldEnum)[keyof typeof TransportScheduleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'VatType'
   */
  export type EnumVatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VatType'>
    


  /**
   * Reference to a field of type 'VatType[]'
   */
  export type ListEnumVatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VatType[]'>
    


  /**
   * Reference to a field of type 'AddressType'
   */
  export type EnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType'>
    


  /**
   * Reference to a field of type 'AddressType[]'
   */
  export type ListEnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType[]'>
    


  /**
   * Reference to a field of type 'SimulationStatus'
   */
  export type EnumSimulationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimulationStatus'>
    


  /**
   * Reference to a field of type 'SimulationStatus[]'
   */
  export type ListEnumSimulationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimulationStatus[]'>
    


  /**
   * Reference to a field of type 'EnvoiStatus'
   */
  export type EnumEnvoiStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnvoiStatus'>
    


  /**
   * Reference to a field of type 'EnvoiStatus[]'
   */
  export type ListEnumEnvoiStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnvoiStatus[]'>
    


  /**
   * Reference to a field of type 'TrackingEventStatus'
   */
  export type EnumTrackingEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackingEventStatus'>
    


  /**
   * Reference to a field of type 'TrackingEventStatus[]'
   */
  export type ListEnumTrackingEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackingEventStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    userId?: IntFilter<"PasswordResetToken"> | number
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    userId?: IntFilter<"PasswordResetToken"> | number
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _avg?: PasswordResetTokenAvgOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
    _sum?: PasswordResetTokenSumOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    userId?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    envoiId?: IntFilter<"Payment"> | number
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatFilter<"Payment"> | number
    transactionId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    envoiId?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    envoi?: EnvoiOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    envoiId?: number
    transactionId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
  }, "id" | "envoiId" | "transactionId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    envoiId?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    envoiId?: IntWithAggregatesFilter<"Payment"> | number
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    email?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isVerified?: BoolNullableFilter<"User"> | boolean | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isEnterprise?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    authenticator?: AuthenticatorListRelationFilter
    sentEnvois?: EnvoiListRelationFilter
    receivedEnvois?: EnvoiListRelationFilter
    notificationsAsDestinataire?: NotificationListRelationFilter
    notificationAsClient?: NotificationListRelationFilter
    userCoupons?: UserCouponListRelationFilter
    clientLinks?: ClientDestinataireListRelationFilter
    destinataireLinks?: ClientDestinataireListRelationFilter
    clientAgencies?: AgencyClientsListRelationFilter
    agencyStaffs?: AgencyStaffListRelationFilter
    userAddresses?: UserAddressListRelationFilter
    createdAgencies?: AgencyListRelationFilter
    staffsActivityLogs?: ActivityLogListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    isVerified?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationTokenExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isEnterprise?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    authenticator?: AuthenticatorOrderByRelationAggregateInput
    sentEnvois?: EnvoiOrderByRelationAggregateInput
    receivedEnvois?: EnvoiOrderByRelationAggregateInput
    notificationsAsDestinataire?: NotificationOrderByRelationAggregateInput
    notificationAsClient?: NotificationOrderByRelationAggregateInput
    userCoupons?: UserCouponOrderByRelationAggregateInput
    clientLinks?: ClientDestinataireOrderByRelationAggregateInput
    destinataireLinks?: ClientDestinataireOrderByRelationAggregateInput
    clientAgencies?: AgencyClientsOrderByRelationAggregateInput
    agencyStaffs?: AgencyStaffOrderByRelationAggregateInput
    userAddresses?: UserAddressOrderByRelationAggregateInput
    createdAgencies?: AgencyOrderByRelationAggregateInput
    staffsActivityLogs?: ActivityLogOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phoneNumber?: string
    verificationToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isVerified?: BoolNullableFilter<"User"> | boolean | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    verificationTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isEnterprise?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    authenticator?: AuthenticatorListRelationFilter
    sentEnvois?: EnvoiListRelationFilter
    receivedEnvois?: EnvoiListRelationFilter
    notificationsAsDestinataire?: NotificationListRelationFilter
    notificationAsClient?: NotificationListRelationFilter
    userCoupons?: UserCouponListRelationFilter
    clientLinks?: ClientDestinataireListRelationFilter
    destinataireLinks?: ClientDestinataireListRelationFilter
    clientAgencies?: AgencyClientsListRelationFilter
    agencyStaffs?: AgencyStaffListRelationFilter
    userAddresses?: UserAddressListRelationFilter
    createdAgencies?: AgencyListRelationFilter
    staffsActivityLogs?: ActivityLogListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
  }, "id" | "email" | "phoneNumber" | "verificationToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    isVerified?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationTokenExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isEnterprise?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    verificationTokenExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    isEnterprise?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: IntFilter<"Account"> | number
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: IntFilter<"Account"> | number
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Account"> | number
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    sessionToken?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: IntWithAggregatesFilter<"Session"> | number
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AgencyClientsWhereInput = {
    AND?: AgencyClientsWhereInput | AgencyClientsWhereInput[]
    OR?: AgencyClientsWhereInput[]
    NOT?: AgencyClientsWhereInput | AgencyClientsWhereInput[]
    clientId?: IntFilter<"AgencyClients"> | number
    agencyId?: IntFilter<"AgencyClients"> | number
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }

  export type AgencyClientsOrderByWithRelationInput = {
    clientId?: SortOrder
    agencyId?: SortOrder
    client?: UserOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
  }

  export type AgencyClientsWhereUniqueInput = Prisma.AtLeast<{
    clientId_agencyId?: AgencyClientsClientIdAgencyIdCompoundUniqueInput
    AND?: AgencyClientsWhereInput | AgencyClientsWhereInput[]
    OR?: AgencyClientsWhereInput[]
    NOT?: AgencyClientsWhereInput | AgencyClientsWhereInput[]
    clientId?: IntFilter<"AgencyClients"> | number
    agencyId?: IntFilter<"AgencyClients"> | number
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }, "clientId_agencyId">

  export type AgencyClientsOrderByWithAggregationInput = {
    clientId?: SortOrder
    agencyId?: SortOrder
    _count?: AgencyClientsCountOrderByAggregateInput
    _avg?: AgencyClientsAvgOrderByAggregateInput
    _max?: AgencyClientsMaxOrderByAggregateInput
    _min?: AgencyClientsMinOrderByAggregateInput
    _sum?: AgencyClientsSumOrderByAggregateInput
  }

  export type AgencyClientsScalarWhereWithAggregatesInput = {
    AND?: AgencyClientsScalarWhereWithAggregatesInput | AgencyClientsScalarWhereWithAggregatesInput[]
    OR?: AgencyClientsScalarWhereWithAggregatesInput[]
    NOT?: AgencyClientsScalarWhereWithAggregatesInput | AgencyClientsScalarWhereWithAggregatesInput[]
    clientId?: IntWithAggregatesFilter<"AgencyClients"> | number
    agencyId?: IntWithAggregatesFilter<"AgencyClients"> | number
  }

  export type AgencyStaffWhereInput = {
    AND?: AgencyStaffWhereInput | AgencyStaffWhereInput[]
    OR?: AgencyStaffWhereInput[]
    NOT?: AgencyStaffWhereInput | AgencyStaffWhereInput[]
    id?: IntFilter<"AgencyStaff"> | number
    staffId?: IntFilter<"AgencyStaff"> | number
    agencyId?: IntFilter<"AgencyStaff"> | number
    staffRole?: EnumRoleFilter<"AgencyStaff"> | $Enums.Role
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }

  export type AgencyStaffOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
    staffRole?: SortOrder
    staff?: UserOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
  }

  export type AgencyStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    staffId_agencyId_staffRole?: AgencyStaffStaffIdAgencyIdStaffRoleCompoundUniqueInput
    AND?: AgencyStaffWhereInput | AgencyStaffWhereInput[]
    OR?: AgencyStaffWhereInput[]
    NOT?: AgencyStaffWhereInput | AgencyStaffWhereInput[]
    staffId?: IntFilter<"AgencyStaff"> | number
    agencyId?: IntFilter<"AgencyStaff"> | number
    staffRole?: EnumRoleFilter<"AgencyStaff"> | $Enums.Role
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }, "id" | "staffId_agencyId_staffRole">

  export type AgencyStaffOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
    staffRole?: SortOrder
    _count?: AgencyStaffCountOrderByAggregateInput
    _avg?: AgencyStaffAvgOrderByAggregateInput
    _max?: AgencyStaffMaxOrderByAggregateInput
    _min?: AgencyStaffMinOrderByAggregateInput
    _sum?: AgencyStaffSumOrderByAggregateInput
  }

  export type AgencyStaffScalarWhereWithAggregatesInput = {
    AND?: AgencyStaffScalarWhereWithAggregatesInput | AgencyStaffScalarWhereWithAggregatesInput[]
    OR?: AgencyStaffScalarWhereWithAggregatesInput[]
    NOT?: AgencyStaffScalarWhereWithAggregatesInput | AgencyStaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AgencyStaff"> | number
    staffId?: IntWithAggregatesFilter<"AgencyStaff"> | number
    agencyId?: IntWithAggregatesFilter<"AgencyStaff"> | number
    staffRole?: EnumRoleWithAggregatesFilter<"AgencyStaff"> | $Enums.Role
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    activityType?: EnumActivityTypeFilter<"ActivityLog"> | $Enums.ActivityType
    staffId?: IntNullableFilter<"ActivityLog"> | number | null
    agencyId?: IntNullableFilter<"ActivityLog"> | number | null
    details?: StringNullableFilter<"ActivityLog"> | string | null
    staffRole?: EnumRoleFilter<"ActivityLog"> | $Enums.Role
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    staff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    activityType?: SortOrder
    staffId?: SortOrderInput | SortOrder
    agencyId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    staffRole?: SortOrder
    createdAt?: SortOrder
    staff?: UserOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    activityType?: EnumActivityTypeFilter<"ActivityLog"> | $Enums.ActivityType
    staffId?: IntNullableFilter<"ActivityLog"> | number | null
    agencyId?: IntNullableFilter<"ActivityLog"> | number | null
    details?: StringNullableFilter<"ActivityLog"> | string | null
    staffRole?: EnumRoleFilter<"ActivityLog"> | $Enums.Role
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    staff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    activityType?: SortOrder
    staffId?: SortOrderInput | SortOrder
    agencyId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    staffRole?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityLog"> | number
    activityType?: EnumActivityTypeWithAggregatesFilter<"ActivityLog"> | $Enums.ActivityType
    staffId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    agencyId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    details?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    staffRole?: EnumRoleWithAggregatesFilter<"ActivityLog"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type AuthenticatorWhereInput = {
    AND?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    OR?: AuthenticatorWhereInput[]
    NOT?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    credentialID?: StringFilter<"Authenticator"> | string
    userId?: IntFilter<"Authenticator"> | number
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuthenticatorOrderByWithRelationInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuthenticatorWhereUniqueInput = Prisma.AtLeast<{
    credentialID?: string
    userId_credentialID?: AuthenticatorUserIdCredentialIDCompoundUniqueInput
    AND?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    OR?: AuthenticatorWhereInput[]
    NOT?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    userId?: IntFilter<"Authenticator"> | number
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_credentialID" | "credentialID">

  export type AuthenticatorOrderByWithAggregationInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrderInput | SortOrder
    _count?: AuthenticatorCountOrderByAggregateInput
    _avg?: AuthenticatorAvgOrderByAggregateInput
    _max?: AuthenticatorMaxOrderByAggregateInput
    _min?: AuthenticatorMinOrderByAggregateInput
    _sum?: AuthenticatorSumOrderByAggregateInput
  }

  export type AuthenticatorScalarWhereWithAggregatesInput = {
    AND?: AuthenticatorScalarWhereWithAggregatesInput | AuthenticatorScalarWhereWithAggregatesInput[]
    OR?: AuthenticatorScalarWhereWithAggregatesInput[]
    NOT?: AuthenticatorScalarWhereWithAggregatesInput | AuthenticatorScalarWhereWithAggregatesInput[]
    credentialID?: StringWithAggregatesFilter<"Authenticator"> | string
    userId?: IntWithAggregatesFilter<"Authenticator"> | number
    providerAccountId?: StringWithAggregatesFilter<"Authenticator"> | string
    credentialPublicKey?: StringWithAggregatesFilter<"Authenticator"> | string
    counter?: IntWithAggregatesFilter<"Authenticator"> | number
    credentialDeviceType?: StringWithAggregatesFilter<"Authenticator"> | string
    credentialBackedUp?: BoolWithAggregatesFilter<"Authenticator"> | boolean
    transports?: StringNullableWithAggregatesFilter<"Authenticator"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    message?: StringFilter<"Notification"> | string
    agencyId?: IntFilter<"Notification"> | number
    destinataireId?: IntNullableFilter<"Notification"> | number | null
    clientId?: IntNullableFilter<"Notification"> | number | null
    envoiId?: IntFilter<"Notification"> | number
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
    destinataireNotification?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clientNotification?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    agencyId?: SortOrder
    destinataireId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    envoiId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    envoi?: EnvoiOrderByWithRelationInput
    destinataireNotification?: UserOrderByWithRelationInput
    clientNotification?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    message?: StringFilter<"Notification"> | string
    agencyId?: IntFilter<"Notification"> | number
    destinataireId?: IntNullableFilter<"Notification"> | number | null
    clientId?: IntNullableFilter<"Notification"> | number | null
    envoiId?: IntFilter<"Notification"> | number
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
    destinataireNotification?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clientNotification?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    agencyId?: SortOrder
    destinataireId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    envoiId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    message?: StringWithAggregatesFilter<"Notification"> | string
    agencyId?: IntWithAggregatesFilter<"Notification"> | number
    destinataireId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    clientId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    envoiId?: IntWithAggregatesFilter<"Notification"> | number
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type VatRateWhereInput = {
    AND?: VatRateWhereInput | VatRateWhereInput[]
    OR?: VatRateWhereInput[]
    NOT?: VatRateWhereInput | VatRateWhereInput[]
    id?: IntFilter<"VatRate"> | number
    countryId?: IntFilter<"VatRate"> | number
    itemClassId?: IntFilter<"VatRate"> | number
    vatPercent?: DecimalFilter<"VatRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VatRate"> | Date | string
    updatedAt?: DateTimeFilter<"VatRate"> | Date | string
    vatType?: EnumVatTypeNullableFilter<"VatRate"> | $Enums.VatType | null
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
  }

  export type VatRateOrderByWithRelationInput = {
    id?: SortOrder
    countryId?: SortOrder
    itemClassId?: SortOrder
    vatPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vatType?: SortOrderInput | SortOrder
    country?: CountryOrderByWithRelationInput
  }

  export type VatRateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    countryId?: number
    AND?: VatRateWhereInput | VatRateWhereInput[]
    OR?: VatRateWhereInput[]
    NOT?: VatRateWhereInput | VatRateWhereInput[]
    itemClassId?: IntFilter<"VatRate"> | number
    vatPercent?: DecimalFilter<"VatRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VatRate"> | Date | string
    updatedAt?: DateTimeFilter<"VatRate"> | Date | string
    vatType?: EnumVatTypeNullableFilter<"VatRate"> | $Enums.VatType | null
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
  }, "id" | "countryId">

  export type VatRateOrderByWithAggregationInput = {
    id?: SortOrder
    countryId?: SortOrder
    itemClassId?: SortOrder
    vatPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vatType?: SortOrderInput | SortOrder
    _count?: VatRateCountOrderByAggregateInput
    _avg?: VatRateAvgOrderByAggregateInput
    _max?: VatRateMaxOrderByAggregateInput
    _min?: VatRateMinOrderByAggregateInput
    _sum?: VatRateSumOrderByAggregateInput
  }

  export type VatRateScalarWhereWithAggregatesInput = {
    AND?: VatRateScalarWhereWithAggregatesInput | VatRateScalarWhereWithAggregatesInput[]
    OR?: VatRateScalarWhereWithAggregatesInput[]
    NOT?: VatRateScalarWhereWithAggregatesInput | VatRateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VatRate"> | number
    countryId?: IntWithAggregatesFilter<"VatRate"> | number
    itemClassId?: IntWithAggregatesFilter<"VatRate"> | number
    vatPercent?: DecimalWithAggregatesFilter<"VatRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"VatRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VatRate"> | Date | string
    vatType?: EnumVatTypeNullableWithAggregatesFilter<"VatRate"> | $Enums.VatType | null
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: IntFilter<"City"> | number
    name?: StringFilter<"City"> | string
    latitude?: StringNullableFilter<"City"> | string | null
    longitude?: StringNullableFilter<"City"> | string | null
    countryId?: IntFilter<"City"> | number
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    addresses?: AddressListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    countryId?: SortOrder
    country?: CountryOrderByWithRelationInput
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_countryId?: CityNameCountryIdCompoundUniqueInput
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    latitude?: StringNullableFilter<"City"> | string | null
    longitude?: StringNullableFilter<"City"> | string | null
    countryId?: IntFilter<"City"> | number
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    addresses?: AddressListRelationFilter
  }, "id" | "name_countryId">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    countryId?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"City"> | number
    name?: StringWithAggregatesFilter<"City"> | string
    latitude?: StringNullableWithAggregatesFilter<"City"> | string | null
    longitude?: StringNullableWithAggregatesFilter<"City"> | string | null
    countryId?: IntWithAggregatesFilter<"City"> | number
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: IntFilter<"Country"> | number
    name?: StringFilter<"Country"> | string
    iso2?: StringFilter<"Country"> | string
    iso3?: StringFilter<"Country"> | string
    phonecode?: StringFilter<"Country"> | string
    capital?: StringNullableFilter<"Country"> | string | null
    currency?: StringNullableFilter<"Country"> | string | null
    latitude?: StringNullableFilter<"Country"> | string | null
    longitude?: StringNullableFilter<"Country"> | string | null
    emoji?: StringNullableFilter<"Country"> | string | null
    cities?: CityListRelationFilter
    timezones?: TimezoneListRelationFilter
    vatRates?: VatRateListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    iso2?: SortOrder
    iso3?: SortOrder
    phonecode?: SortOrder
    capital?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    cities?: CityOrderByRelationAggregateInput
    timezones?: TimezoneOrderByRelationAggregateInput
    vatRates?: VatRateOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    iso2?: string
    iso3?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    phonecode?: StringFilter<"Country"> | string
    capital?: StringNullableFilter<"Country"> | string | null
    currency?: StringNullableFilter<"Country"> | string | null
    latitude?: StringNullableFilter<"Country"> | string | null
    longitude?: StringNullableFilter<"Country"> | string | null
    emoji?: StringNullableFilter<"Country"> | string | null
    cities?: CityListRelationFilter
    timezones?: TimezoneListRelationFilter
    vatRates?: VatRateListRelationFilter
  }, "id" | "iso2" | "iso3">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    iso2?: SortOrder
    iso3?: SortOrder
    phonecode?: SortOrder
    capital?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Country"> | number
    name?: StringWithAggregatesFilter<"Country"> | string
    iso2?: StringWithAggregatesFilter<"Country"> | string
    iso3?: StringWithAggregatesFilter<"Country"> | string
    phonecode?: StringWithAggregatesFilter<"Country"> | string
    capital?: StringNullableWithAggregatesFilter<"Country"> | string | null
    currency?: StringNullableWithAggregatesFilter<"Country"> | string | null
    latitude?: StringNullableWithAggregatesFilter<"Country"> | string | null
    longitude?: StringNullableWithAggregatesFilter<"Country"> | string | null
    emoji?: StringNullableWithAggregatesFilter<"Country"> | string | null
  }

  export type TimezoneWhereInput = {
    AND?: TimezoneWhereInput | TimezoneWhereInput[]
    OR?: TimezoneWhereInput[]
    NOT?: TimezoneWhereInput | TimezoneWhereInput[]
    id?: IntFilter<"Timezone"> | number
    zoneName?: StringFilter<"Timezone"> | string
    gmtOffset?: IntFilter<"Timezone"> | number
    abbreviation?: StringFilter<"Timezone"> | string
    countryId?: IntFilter<"Timezone"> | number
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
  }

  export type TimezoneOrderByWithRelationInput = {
    id?: SortOrder
    zoneName?: SortOrder
    gmtOffset?: SortOrder
    abbreviation?: SortOrder
    countryId?: SortOrder
    country?: CountryOrderByWithRelationInput
  }

  export type TimezoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    zoneName_countryId?: TimezoneZoneNameCountryIdCompoundUniqueInput
    AND?: TimezoneWhereInput | TimezoneWhereInput[]
    OR?: TimezoneWhereInput[]
    NOT?: TimezoneWhereInput | TimezoneWhereInput[]
    zoneName?: StringFilter<"Timezone"> | string
    gmtOffset?: IntFilter<"Timezone"> | number
    abbreviation?: StringFilter<"Timezone"> | string
    countryId?: IntFilter<"Timezone"> | number
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
  }, "id" | "zoneName_countryId">

  export type TimezoneOrderByWithAggregationInput = {
    id?: SortOrder
    zoneName?: SortOrder
    gmtOffset?: SortOrder
    abbreviation?: SortOrder
    countryId?: SortOrder
    _count?: TimezoneCountOrderByAggregateInput
    _avg?: TimezoneAvgOrderByAggregateInput
    _max?: TimezoneMaxOrderByAggregateInput
    _min?: TimezoneMinOrderByAggregateInput
    _sum?: TimezoneSumOrderByAggregateInput
  }

  export type TimezoneScalarWhereWithAggregatesInput = {
    AND?: TimezoneScalarWhereWithAggregatesInput | TimezoneScalarWhereWithAggregatesInput[]
    OR?: TimezoneScalarWhereWithAggregatesInput[]
    NOT?: TimezoneScalarWhereWithAggregatesInput | TimezoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Timezone"> | number
    zoneName?: StringWithAggregatesFilter<"Timezone"> | string
    gmtOffset?: IntWithAggregatesFilter<"Timezone"> | number
    abbreviation?: StringWithAggregatesFilter<"Timezone"> | string
    countryId?: IntWithAggregatesFilter<"Timezone"> | number
  }

  export type UserAddressWhereInput = {
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    id?: IntFilter<"UserAddress"> | number
    userId?: IntFilter<"UserAddress"> | number
    addressId?: IntFilter<"UserAddress"> | number
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    addressType?: EnumAddressTypeFilter<"UserAddress"> | $Enums.AddressType
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressType?: SortOrder
    address?: AddressOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    userId?: IntFilter<"UserAddress"> | number
    addressId?: IntFilter<"UserAddress"> | number
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    addressType?: EnumAddressTypeFilter<"UserAddress"> | $Enums.AddressType
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserAddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressType?: SortOrder
    _count?: UserAddressCountOrderByAggregateInput
    _avg?: UserAddressAvgOrderByAggregateInput
    _max?: UserAddressMaxOrderByAggregateInput
    _min?: UserAddressMinOrderByAggregateInput
    _sum?: UserAddressSumOrderByAggregateInput
  }

  export type UserAddressScalarWhereWithAggregatesInput = {
    AND?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    OR?: UserAddressScalarWhereWithAggregatesInput[]
    NOT?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAddress"> | number
    userId?: IntWithAggregatesFilter<"UserAddress"> | number
    addressId?: IntWithAggregatesFilter<"UserAddress"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAddress"> | Date | string
    addressType?: EnumAddressTypeWithAggregatesFilter<"UserAddress"> | $Enums.AddressType
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    street?: StringFilter<"Address"> | string
    complement?: StringNullableFilter<"Address"> | string | null
    streetNumber?: StringNullableFilter<"Address"> | string | null
    boxNumber?: StringNullableFilter<"Address"> | string | null
    cityId?: IntFilter<"Address"> | number
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    userAddresses?: UserAddressListRelationFilter
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    street?: SortOrder
    complement?: SortOrderInput | SortOrder
    streetNumber?: SortOrderInput | SortOrder
    boxNumber?: SortOrderInput | SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
    userAddresses?: UserAddressOrderByRelationAggregateInput
    agency?: AgencyOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    street?: StringFilter<"Address"> | string
    complement?: StringNullableFilter<"Address"> | string | null
    streetNumber?: StringNullableFilter<"Address"> | string | null
    boxNumber?: StringNullableFilter<"Address"> | string | null
    cityId?: IntFilter<"Address"> | number
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    userAddresses?: UserAddressListRelationFilter
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    street?: SortOrder
    complement?: SortOrderInput | SortOrder
    streetNumber?: SortOrderInput | SortOrder
    boxNumber?: SortOrderInput | SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    street?: StringWithAggregatesFilter<"Address"> | string
    complement?: StringNullableWithAggregatesFilter<"Address"> | string | null
    streetNumber?: StringNullableWithAggregatesFilter<"Address"> | string | null
    boxNumber?: StringNullableWithAggregatesFilter<"Address"> | string | null
    cityId?: IntWithAggregatesFilter<"Address"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: IntFilter<"Agency"> | number
    name?: StringFilter<"Agency"> | string
    location?: StringNullableFilter<"Agency"> | string | null
    phoneNumber?: StringNullableFilter<"Agency"> | string | null
    email?: StringNullableFilter<"Agency"> | string | null
    vatNumber?: StringNullableFilter<"Agency"> | string | null
    addressId?: IntFilter<"Agency"> | number
    capacity?: IntNullableFilter<"Agency"> | number | null
    availableSlots?: IntNullableFilter<"Agency"> | number | null
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    createdById?: IntNullableFilter<"Agency"> | number | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    arrivalEnvoi?: EnvoiListRelationFilter
    departureEnvoi?: EnvoiListRelationFilter
    notifications?: NotificationListRelationFilter
    appointments?: AppointmentListRelationFilter
    transports?: TransportListRelationFilter
    tarifs?: TarifsListRelationFilter
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    agencyClients?: AgencyClientsListRelationFilter
    agencyStaff?: AgencyStaffListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    addressId?: SortOrder
    capacity?: SortOrderInput | SortOrder
    availableSlots?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    arrivalEnvoi?: EnvoiOrderByRelationAggregateInput
    departureEnvoi?: EnvoiOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    transports?: TransportOrderByRelationAggregateInput
    tarifs?: TarifsOrderByRelationAggregateInput
    address?: AddressOrderByWithRelationInput
    agencyClients?: AgencyClientsOrderByRelationAggregateInput
    agencyStaff?: AgencyStaffOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    addressId?: number
    name_addressId?: AgencyNameAddressIdCompoundUniqueInput
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    name?: StringFilter<"Agency"> | string
    location?: StringNullableFilter<"Agency"> | string | null
    phoneNumber?: StringNullableFilter<"Agency"> | string | null
    email?: StringNullableFilter<"Agency"> | string | null
    vatNumber?: StringNullableFilter<"Agency"> | string | null
    capacity?: IntNullableFilter<"Agency"> | number | null
    availableSlots?: IntNullableFilter<"Agency"> | number | null
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    createdById?: IntNullableFilter<"Agency"> | number | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    arrivalEnvoi?: EnvoiListRelationFilter
    departureEnvoi?: EnvoiListRelationFilter
    notifications?: NotificationListRelationFilter
    appointments?: AppointmentListRelationFilter
    transports?: TransportListRelationFilter
    tarifs?: TarifsListRelationFilter
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    agencyClients?: AgencyClientsListRelationFilter
    agencyStaff?: AgencyStaffListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
  }, "id" | "addressId" | "name_addressId">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    addressId?: SortOrder
    capacity?: SortOrderInput | SortOrder
    availableSlots?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _avg?: AgencyAvgOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
    _sum?: AgencySumOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Agency"> | number
    name?: StringWithAggregatesFilter<"Agency"> | string
    location?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    email?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    vatNumber?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    addressId?: IntWithAggregatesFilter<"Agency"> | number
    capacity?: IntNullableWithAggregatesFilter<"Agency"> | number | null
    availableSlots?: IntNullableWithAggregatesFilter<"Agency"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"Agency"> | number | null
  }

  export type ClientDestinataireWhereInput = {
    AND?: ClientDestinataireWhereInput | ClientDestinataireWhereInput[]
    OR?: ClientDestinataireWhereInput[]
    NOT?: ClientDestinataireWhereInput | ClientDestinataireWhereInput[]
    id?: IntFilter<"ClientDestinataire"> | number
    clientId?: IntFilter<"ClientDestinataire"> | number
    destinataireId?: IntFilter<"ClientDestinataire"> | number
    createdAt?: DateTimeFilter<"ClientDestinataire"> | Date | string
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    destinataire?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClientDestinataireOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    destinataireId?: SortOrder
    createdAt?: SortOrder
    client?: UserOrderByWithRelationInput
    destinataire?: UserOrderByWithRelationInput
  }

  export type ClientDestinataireWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientId_destinataireId?: ClientDestinataireClientIdDestinataireIdCompoundUniqueInput
    AND?: ClientDestinataireWhereInput | ClientDestinataireWhereInput[]
    OR?: ClientDestinataireWhereInput[]
    NOT?: ClientDestinataireWhereInput | ClientDestinataireWhereInput[]
    clientId?: IntFilter<"ClientDestinataire"> | number
    destinataireId?: IntFilter<"ClientDestinataire"> | number
    createdAt?: DateTimeFilter<"ClientDestinataire"> | Date | string
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    destinataire?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "clientId_destinataireId">

  export type ClientDestinataireOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    destinataireId?: SortOrder
    createdAt?: SortOrder
    _count?: ClientDestinataireCountOrderByAggregateInput
    _avg?: ClientDestinataireAvgOrderByAggregateInput
    _max?: ClientDestinataireMaxOrderByAggregateInput
    _min?: ClientDestinataireMinOrderByAggregateInput
    _sum?: ClientDestinataireSumOrderByAggregateInput
  }

  export type ClientDestinataireScalarWhereWithAggregatesInput = {
    AND?: ClientDestinataireScalarWhereWithAggregatesInput | ClientDestinataireScalarWhereWithAggregatesInput[]
    OR?: ClientDestinataireScalarWhereWithAggregatesInput[]
    NOT?: ClientDestinataireScalarWhereWithAggregatesInput | ClientDestinataireScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientDestinataire"> | number
    clientId?: IntWithAggregatesFilter<"ClientDestinataire"> | number
    destinataireId?: IntWithAggregatesFilter<"ClientDestinataire"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ClientDestinataire"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: IntFilter<"Coupon"> | number
    couponCode?: StringFilter<"Coupon"> | string
    discountAmount?: DecimalFilter<"Coupon"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFilter<"Coupon"> | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFilter<"Coupon"> | number
    startDate?: DateTimeFilter<"Coupon"> | Date | string
    expirationDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    termsAndConditions?: StringNullableFilter<"Coupon"> | string | null
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    userCoupon?: UserCouponListRelationFilter
    envoiCoupon?: EnvoiCouponListRelationFilter
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    couponCode?: SortOrder
    discountAmount?: SortOrder
    discountPercentage?: SortOrder
    numberOfUses?: SortOrder
    startDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    termsAndConditions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userCoupon?: UserCouponOrderByRelationAggregateInput
    envoiCoupon?: EnvoiCouponOrderByRelationAggregateInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    couponCode?: StringFilter<"Coupon"> | string
    discountAmount?: DecimalFilter<"Coupon"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFilter<"Coupon"> | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFilter<"Coupon"> | number
    startDate?: DateTimeFilter<"Coupon"> | Date | string
    expirationDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    termsAndConditions?: StringNullableFilter<"Coupon"> | string | null
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    userCoupon?: UserCouponListRelationFilter
    envoiCoupon?: EnvoiCouponListRelationFilter
  }, "id">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    couponCode?: SortOrder
    discountAmount?: SortOrder
    discountPercentage?: SortOrder
    numberOfUses?: SortOrder
    startDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    termsAndConditions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Coupon"> | number
    couponCode?: StringWithAggregatesFilter<"Coupon"> | string
    discountAmount?: DecimalWithAggregatesFilter<"Coupon"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalWithAggregatesFilter<"Coupon"> | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntWithAggregatesFilter<"Coupon"> | number
    startDate?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    expirationDate?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    termsAndConditions?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type UserCouponWhereInput = {
    AND?: UserCouponWhereInput | UserCouponWhereInput[]
    OR?: UserCouponWhereInput[]
    NOT?: UserCouponWhereInput | UserCouponWhereInput[]
    userId?: IntFilter<"UserCoupon"> | number
    couponId?: IntFilter<"UserCoupon"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>
  }

  export type UserCouponOrderByWithRelationInput = {
    userId?: SortOrder
    couponId?: SortOrder
    user?: UserOrderByWithRelationInput
    coupon?: CouponOrderByWithRelationInput
  }

  export type UserCouponWhereUniqueInput = Prisma.AtLeast<{
    userId_couponId?: UserCouponUserIdCouponIdCompoundUniqueInput
    AND?: UserCouponWhereInput | UserCouponWhereInput[]
    OR?: UserCouponWhereInput[]
    NOT?: UserCouponWhereInput | UserCouponWhereInput[]
    userId?: IntFilter<"UserCoupon"> | number
    couponId?: IntFilter<"UserCoupon"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>
  }, "userId_couponId">

  export type UserCouponOrderByWithAggregationInput = {
    userId?: SortOrder
    couponId?: SortOrder
    _count?: UserCouponCountOrderByAggregateInput
    _avg?: UserCouponAvgOrderByAggregateInput
    _max?: UserCouponMaxOrderByAggregateInput
    _min?: UserCouponMinOrderByAggregateInput
    _sum?: UserCouponSumOrderByAggregateInput
  }

  export type UserCouponScalarWhereWithAggregatesInput = {
    AND?: UserCouponScalarWhereWithAggregatesInput | UserCouponScalarWhereWithAggregatesInput[]
    OR?: UserCouponScalarWhereWithAggregatesInput[]
    NOT?: UserCouponScalarWhereWithAggregatesInput | UserCouponScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserCoupon"> | number
    couponId?: IntWithAggregatesFilter<"UserCoupon"> | number
  }

  export type TransportWhereInput = {
    AND?: TransportWhereInput | TransportWhereInput[]
    OR?: TransportWhereInput[]
    NOT?: TransportWhereInput | TransportWhereInput[]
    id?: IntFilter<"Transport"> | number
    number?: StringFilter<"Transport"> | string
    baseVolume?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFilter<"Transport"> | boolean
    agencyId?: IntNullableFilter<"Transport"> | number | null
    createdAt?: DateTimeFilter<"Transport"> | Date | string
    updatedAt?: DateTimeFilter<"Transport"> | Date | string
    envois?: EnvoiListRelationFilter
    transportSchedules?: TransportScheduleListRelationFilter
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type TransportOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    baseVolume?: SortOrder
    baseWeight?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    isAvailable?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    envois?: EnvoiOrderByRelationAggregateInput
    transportSchedules?: TransportScheduleOrderByRelationAggregateInput
    agency?: AgencyOrderByWithRelationInput
  }

  export type TransportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransportWhereInput | TransportWhereInput[]
    OR?: TransportWhereInput[]
    NOT?: TransportWhereInput | TransportWhereInput[]
    number?: StringFilter<"Transport"> | string
    baseVolume?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFilter<"Transport"> | boolean
    agencyId?: IntNullableFilter<"Transport"> | number | null
    createdAt?: DateTimeFilter<"Transport"> | Date | string
    updatedAt?: DateTimeFilter<"Transport"> | Date | string
    envois?: EnvoiListRelationFilter
    transportSchedules?: TransportScheduleListRelationFilter
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id">

  export type TransportOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    baseVolume?: SortOrder
    baseWeight?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    isAvailable?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransportCountOrderByAggregateInput
    _avg?: TransportAvgOrderByAggregateInput
    _max?: TransportMaxOrderByAggregateInput
    _min?: TransportMinOrderByAggregateInput
    _sum?: TransportSumOrderByAggregateInput
  }

  export type TransportScalarWhereWithAggregatesInput = {
    AND?: TransportScalarWhereWithAggregatesInput | TransportScalarWhereWithAggregatesInput[]
    OR?: TransportScalarWhereWithAggregatesInput[]
    NOT?: TransportScalarWhereWithAggregatesInput | TransportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transport"> | number
    number?: StringWithAggregatesFilter<"Transport"> | string
    baseVolume?: DecimalWithAggregatesFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalWithAggregatesFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalWithAggregatesFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalWithAggregatesFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolWithAggregatesFilter<"Transport"> | boolean
    agencyId?: IntNullableWithAggregatesFilter<"Transport"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Transport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transport"> | Date | string
  }

  export type EnvoiWhereInput = {
    AND?: EnvoiWhereInput | EnvoiWhereInput[]
    OR?: EnvoiWhereInput[]
    NOT?: EnvoiWhereInput | EnvoiWhereInput[]
    id?: IntFilter<"Envoi"> | number
    trackingNumber?: StringNullableFilter<"Envoi"> | string | null
    qrCodeUrl?: StringNullableFilter<"Envoi"> | string | null
    userId?: IntNullableFilter<"Envoi"> | number | null
    destinataireId?: IntNullableFilter<"Envoi"> | number | null
    transportId?: IntNullableFilter<"Envoi"> | number | null
    departureAgencyId?: IntFilter<"Envoi"> | number
    arrivalAgencyId?: IntFilter<"Envoi"> | number
    simulationStatus?: EnumSimulationStatusFilter<"Envoi"> | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFilter<"Envoi"> | $Enums.EnvoiStatus
    totalWeight?: FloatFilter<"Envoi"> | number
    totalVolume?: FloatFilter<"Envoi"> | number
    totalPrice?: FloatFilter<"Envoi"> | number
    paid?: BoolFilter<"Envoi"> | boolean
    departureDate?: DateTimeFilter<"Envoi"> | Date | string
    arrivalDate?: DateTimeFilter<"Envoi"> | Date | string
    verificationToken?: UuidFilter<"Envoi"> | string
    comment?: StringNullableFilter<"Envoi"> | string | null
    createdAt?: DateTimeFilter<"Envoi"> | Date | string
    updatedAt?: DateTimeFilter<"Envoi"> | Date | string
    arrivalAgency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    departureAgency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    transport?: XOR<TransportNullableScalarRelationFilter, TransportWhereInput> | null
    destinataire?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    client?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    envoiCoupons?: EnvoiCouponListRelationFilter
    parcels?: ParcelListRelationFilter
    appointments?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    notifications?: NotificationListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    trackingEvents?: TrackingEventListRelationFilter
  }

  export type EnvoiOrderByWithRelationInput = {
    id?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    qrCodeUrl?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    destinataireId?: SortOrderInput | SortOrder
    transportId?: SortOrderInput | SortOrder
    departureAgencyId?: SortOrder
    arrivalAgencyId?: SortOrder
    simulationStatus?: SortOrder
    envoiStatus?: SortOrder
    totalWeight?: SortOrder
    totalVolume?: SortOrder
    totalPrice?: SortOrder
    paid?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    verificationToken?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    arrivalAgency?: AgencyOrderByWithRelationInput
    departureAgency?: AgencyOrderByWithRelationInput
    transport?: TransportOrderByWithRelationInput
    destinataire?: UserOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
    envoiCoupons?: EnvoiCouponOrderByRelationAggregateInput
    parcels?: ParcelOrderByRelationAggregateInput
    appointments?: AppointmentOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    payment?: PaymentOrderByWithRelationInput
    trackingEvents?: TrackingEventOrderByRelationAggregateInput
  }

  export type EnvoiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    trackingNumber?: string
    verificationToken?: string
    AND?: EnvoiWhereInput | EnvoiWhereInput[]
    OR?: EnvoiWhereInput[]
    NOT?: EnvoiWhereInput | EnvoiWhereInput[]
    qrCodeUrl?: StringNullableFilter<"Envoi"> | string | null
    userId?: IntNullableFilter<"Envoi"> | number | null
    destinataireId?: IntNullableFilter<"Envoi"> | number | null
    transportId?: IntNullableFilter<"Envoi"> | number | null
    departureAgencyId?: IntFilter<"Envoi"> | number
    arrivalAgencyId?: IntFilter<"Envoi"> | number
    simulationStatus?: EnumSimulationStatusFilter<"Envoi"> | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFilter<"Envoi"> | $Enums.EnvoiStatus
    totalWeight?: FloatFilter<"Envoi"> | number
    totalVolume?: FloatFilter<"Envoi"> | number
    totalPrice?: FloatFilter<"Envoi"> | number
    paid?: BoolFilter<"Envoi"> | boolean
    departureDate?: DateTimeFilter<"Envoi"> | Date | string
    arrivalDate?: DateTimeFilter<"Envoi"> | Date | string
    comment?: StringNullableFilter<"Envoi"> | string | null
    createdAt?: DateTimeFilter<"Envoi"> | Date | string
    updatedAt?: DateTimeFilter<"Envoi"> | Date | string
    arrivalAgency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    departureAgency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    transport?: XOR<TransportNullableScalarRelationFilter, TransportWhereInput> | null
    destinataire?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    client?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    envoiCoupons?: EnvoiCouponListRelationFilter
    parcels?: ParcelListRelationFilter
    appointments?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    notifications?: NotificationListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    trackingEvents?: TrackingEventListRelationFilter
  }, "id" | "trackingNumber" | "verificationToken">

  export type EnvoiOrderByWithAggregationInput = {
    id?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    qrCodeUrl?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    destinataireId?: SortOrderInput | SortOrder
    transportId?: SortOrderInput | SortOrder
    departureAgencyId?: SortOrder
    arrivalAgencyId?: SortOrder
    simulationStatus?: SortOrder
    envoiStatus?: SortOrder
    totalWeight?: SortOrder
    totalVolume?: SortOrder
    totalPrice?: SortOrder
    paid?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    verificationToken?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnvoiCountOrderByAggregateInput
    _avg?: EnvoiAvgOrderByAggregateInput
    _max?: EnvoiMaxOrderByAggregateInput
    _min?: EnvoiMinOrderByAggregateInput
    _sum?: EnvoiSumOrderByAggregateInput
  }

  export type EnvoiScalarWhereWithAggregatesInput = {
    AND?: EnvoiScalarWhereWithAggregatesInput | EnvoiScalarWhereWithAggregatesInput[]
    OR?: EnvoiScalarWhereWithAggregatesInput[]
    NOT?: EnvoiScalarWhereWithAggregatesInput | EnvoiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Envoi"> | number
    trackingNumber?: StringNullableWithAggregatesFilter<"Envoi"> | string | null
    qrCodeUrl?: StringNullableWithAggregatesFilter<"Envoi"> | string | null
    userId?: IntNullableWithAggregatesFilter<"Envoi"> | number | null
    destinataireId?: IntNullableWithAggregatesFilter<"Envoi"> | number | null
    transportId?: IntNullableWithAggregatesFilter<"Envoi"> | number | null
    departureAgencyId?: IntWithAggregatesFilter<"Envoi"> | number
    arrivalAgencyId?: IntWithAggregatesFilter<"Envoi"> | number
    simulationStatus?: EnumSimulationStatusWithAggregatesFilter<"Envoi"> | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusWithAggregatesFilter<"Envoi"> | $Enums.EnvoiStatus
    totalWeight?: FloatWithAggregatesFilter<"Envoi"> | number
    totalVolume?: FloatWithAggregatesFilter<"Envoi"> | number
    totalPrice?: FloatWithAggregatesFilter<"Envoi"> | number
    paid?: BoolWithAggregatesFilter<"Envoi"> | boolean
    departureDate?: DateTimeWithAggregatesFilter<"Envoi"> | Date | string
    arrivalDate?: DateTimeWithAggregatesFilter<"Envoi"> | Date | string
    verificationToken?: UuidWithAggregatesFilter<"Envoi"> | string
    comment?: StringNullableWithAggregatesFilter<"Envoi"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Envoi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Envoi"> | Date | string
  }

  export type TrackingEventWhereInput = {
    AND?: TrackingEventWhereInput | TrackingEventWhereInput[]
    OR?: TrackingEventWhereInput[]
    NOT?: TrackingEventWhereInput | TrackingEventWhereInput[]
    id?: IntFilter<"TrackingEvent"> | number
    envoiId?: IntFilter<"TrackingEvent"> | number
    eventStatus?: EnumTrackingEventStatusFilter<"TrackingEvent"> | $Enums.TrackingEventStatus
    location?: StringNullableFilter<"TrackingEvent"> | string | null
    description?: StringNullableFilter<"TrackingEvent"> | string | null
    createdAt?: DateTimeFilter<"TrackingEvent"> | Date | string
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
  }

  export type TrackingEventOrderByWithRelationInput = {
    id?: SortOrder
    envoiId?: SortOrder
    eventStatus?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    envoi?: EnvoiOrderByWithRelationInput
  }

  export type TrackingEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TrackingEventWhereInput | TrackingEventWhereInput[]
    OR?: TrackingEventWhereInput[]
    NOT?: TrackingEventWhereInput | TrackingEventWhereInput[]
    envoiId?: IntFilter<"TrackingEvent"> | number
    eventStatus?: EnumTrackingEventStatusFilter<"TrackingEvent"> | $Enums.TrackingEventStatus
    location?: StringNullableFilter<"TrackingEvent"> | string | null
    description?: StringNullableFilter<"TrackingEvent"> | string | null
    createdAt?: DateTimeFilter<"TrackingEvent"> | Date | string
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
  }, "id">

  export type TrackingEventOrderByWithAggregationInput = {
    id?: SortOrder
    envoiId?: SortOrder
    eventStatus?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TrackingEventCountOrderByAggregateInput
    _avg?: TrackingEventAvgOrderByAggregateInput
    _max?: TrackingEventMaxOrderByAggregateInput
    _min?: TrackingEventMinOrderByAggregateInput
    _sum?: TrackingEventSumOrderByAggregateInput
  }

  export type TrackingEventScalarWhereWithAggregatesInput = {
    AND?: TrackingEventScalarWhereWithAggregatesInput | TrackingEventScalarWhereWithAggregatesInput[]
    OR?: TrackingEventScalarWhereWithAggregatesInput[]
    NOT?: TrackingEventScalarWhereWithAggregatesInput | TrackingEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TrackingEvent"> | number
    envoiId?: IntWithAggregatesFilter<"TrackingEvent"> | number
    eventStatus?: EnumTrackingEventStatusWithAggregatesFilter<"TrackingEvent"> | $Enums.TrackingEventStatus
    location?: StringNullableWithAggregatesFilter<"TrackingEvent"> | string | null
    description?: StringNullableWithAggregatesFilter<"TrackingEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrackingEvent"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: IntFilter<"Appointment"> | number
    envoiId?: IntFilter<"Appointment"> | number
    agencyId?: IntFilter<"Appointment"> | number
    date?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    envoiId?: SortOrder
    agencyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    envoi?: EnvoiOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    envoiId?: number
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    agencyId?: IntFilter<"Appointment"> | number
    date?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }, "id" | "envoiId">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    envoiId?: SortOrder
    agencyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Appointment"> | number
    envoiId?: IntWithAggregatesFilter<"Appointment"> | number
    agencyId?: IntWithAggregatesFilter<"Appointment"> | number
    date?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type EnvoiCouponWhereInput = {
    AND?: EnvoiCouponWhereInput | EnvoiCouponWhereInput[]
    OR?: EnvoiCouponWhereInput[]
    NOT?: EnvoiCouponWhereInput | EnvoiCouponWhereInput[]
    envoiId?: IntFilter<"EnvoiCoupon"> | number
    couponId?: IntFilter<"EnvoiCoupon"> | number
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
    coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>
  }

  export type EnvoiCouponOrderByWithRelationInput = {
    envoiId?: SortOrder
    couponId?: SortOrder
    envoi?: EnvoiOrderByWithRelationInput
    coupon?: CouponOrderByWithRelationInput
  }

  export type EnvoiCouponWhereUniqueInput = Prisma.AtLeast<{
    envoiId_couponId?: EnvoiCouponEnvoiIdCouponIdCompoundUniqueInput
    AND?: EnvoiCouponWhereInput | EnvoiCouponWhereInput[]
    OR?: EnvoiCouponWhereInput[]
    NOT?: EnvoiCouponWhereInput | EnvoiCouponWhereInput[]
    envoiId?: IntFilter<"EnvoiCoupon"> | number
    couponId?: IntFilter<"EnvoiCoupon"> | number
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
    coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>
  }, "envoiId_couponId">

  export type EnvoiCouponOrderByWithAggregationInput = {
    envoiId?: SortOrder
    couponId?: SortOrder
    _count?: EnvoiCouponCountOrderByAggregateInput
    _avg?: EnvoiCouponAvgOrderByAggregateInput
    _max?: EnvoiCouponMaxOrderByAggregateInput
    _min?: EnvoiCouponMinOrderByAggregateInput
    _sum?: EnvoiCouponSumOrderByAggregateInput
  }

  export type EnvoiCouponScalarWhereWithAggregatesInput = {
    AND?: EnvoiCouponScalarWhereWithAggregatesInput | EnvoiCouponScalarWhereWithAggregatesInput[]
    OR?: EnvoiCouponScalarWhereWithAggregatesInput[]
    NOT?: EnvoiCouponScalarWhereWithAggregatesInput | EnvoiCouponScalarWhereWithAggregatesInput[]
    envoiId?: IntWithAggregatesFilter<"EnvoiCoupon"> | number
    couponId?: IntWithAggregatesFilter<"EnvoiCoupon"> | number
  }

  export type ParcelWhereInput = {
    AND?: ParcelWhereInput | ParcelWhereInput[]
    OR?: ParcelWhereInput[]
    NOT?: ParcelWhereInput | ParcelWhereInput[]
    id?: IntFilter<"Parcel"> | number
    envoiId?: IntFilter<"Parcel"> | number
    height?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    weight?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    width?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    length?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Parcel"> | Date | string
    updatedAt?: DateTimeFilter<"Parcel"> | Date | string
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
  }

  export type ParcelOrderByWithRelationInput = {
    id?: SortOrder
    envoiId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    length?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    envoi?: EnvoiOrderByWithRelationInput
  }

  export type ParcelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParcelWhereInput | ParcelWhereInput[]
    OR?: ParcelWhereInput[]
    NOT?: ParcelWhereInput | ParcelWhereInput[]
    envoiId?: IntFilter<"Parcel"> | number
    height?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    weight?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    width?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    length?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Parcel"> | Date | string
    updatedAt?: DateTimeFilter<"Parcel"> | Date | string
    envoi?: XOR<EnvoiScalarRelationFilter, EnvoiWhereInput>
  }, "id">

  export type ParcelOrderByWithAggregationInput = {
    id?: SortOrder
    envoiId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    length?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParcelCountOrderByAggregateInput
    _avg?: ParcelAvgOrderByAggregateInput
    _max?: ParcelMaxOrderByAggregateInput
    _min?: ParcelMinOrderByAggregateInput
    _sum?: ParcelSumOrderByAggregateInput
  }

  export type ParcelScalarWhereWithAggregatesInput = {
    AND?: ParcelScalarWhereWithAggregatesInput | ParcelScalarWhereWithAggregatesInput[]
    OR?: ParcelScalarWhereWithAggregatesInput[]
    NOT?: ParcelScalarWhereWithAggregatesInput | ParcelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Parcel"> | number
    envoiId?: IntWithAggregatesFilter<"Parcel"> | number
    height?: DecimalWithAggregatesFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    weight?: DecimalWithAggregatesFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    width?: DecimalWithAggregatesFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    length?: DecimalWithAggregatesFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Parcel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parcel"> | Date | string
  }

  export type TarifsWhereInput = {
    AND?: TarifsWhereInput | TarifsWhereInput[]
    OR?: TarifsWhereInput[]
    NOT?: TarifsWhereInput | TarifsWhereInput[]
    id?: IntFilter<"Tarifs"> | number
    agencyId?: IntNullableFilter<"Tarifs"> | number | null
    weightRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Tarifs"> | Date | string
    updatedAt?: DateTimeFilter<"Tarifs"> | Date | string
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type TarifsOrderByWithRelationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    weightRate?: SortOrder
    volumeRate?: SortOrder
    baseRate?: SortOrder
    fixedRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agency?: AgencyOrderByWithRelationInput
  }

  export type TarifsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TarifsWhereInput | TarifsWhereInput[]
    OR?: TarifsWhereInput[]
    NOT?: TarifsWhereInput | TarifsWhereInput[]
    agencyId?: IntNullableFilter<"Tarifs"> | number | null
    weightRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Tarifs"> | Date | string
    updatedAt?: DateTimeFilter<"Tarifs"> | Date | string
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id">

  export type TarifsOrderByWithAggregationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    weightRate?: SortOrder
    volumeRate?: SortOrder
    baseRate?: SortOrder
    fixedRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TarifsCountOrderByAggregateInput
    _avg?: TarifsAvgOrderByAggregateInput
    _max?: TarifsMaxOrderByAggregateInput
    _min?: TarifsMinOrderByAggregateInput
    _sum?: TarifsSumOrderByAggregateInput
  }

  export type TarifsScalarWhereWithAggregatesInput = {
    AND?: TarifsScalarWhereWithAggregatesInput | TarifsScalarWhereWithAggregatesInput[]
    OR?: TarifsScalarWhereWithAggregatesInput[]
    NOT?: TarifsScalarWhereWithAggregatesInput | TarifsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tarifs"> | number
    agencyId?: IntNullableWithAggregatesFilter<"Tarifs"> | number | null
    weightRate?: DecimalWithAggregatesFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalWithAggregatesFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalWithAggregatesFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalWithAggregatesFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Tarifs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tarifs"> | Date | string
  }

  export type TransportScheduleWhereInput = {
    AND?: TransportScheduleWhereInput | TransportScheduleWhereInput[]
    OR?: TransportScheduleWhereInput[]
    NOT?: TransportScheduleWhereInput | TransportScheduleWhereInput[]
    id?: IntFilter<"TransportSchedule"> | number
    transportId?: IntFilter<"TransportSchedule"> | number
    departureDate?: DateTimeFilter<"TransportSchedule"> | Date | string
    arrivalDate?: DateTimeFilter<"TransportSchedule"> | Date | string
    isHoliday?: BoolFilter<"TransportSchedule"> | boolean
    createdAt?: DateTimeFilter<"TransportSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"TransportSchedule"> | Date | string
    transport?: XOR<TransportScalarRelationFilter, TransportWhereInput>
  }

  export type TransportScheduleOrderByWithRelationInput = {
    id?: SortOrder
    transportId?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    isHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transport?: TransportOrderByWithRelationInput
  }

  export type TransportScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransportScheduleWhereInput | TransportScheduleWhereInput[]
    OR?: TransportScheduleWhereInput[]
    NOT?: TransportScheduleWhereInput | TransportScheduleWhereInput[]
    transportId?: IntFilter<"TransportSchedule"> | number
    departureDate?: DateTimeFilter<"TransportSchedule"> | Date | string
    arrivalDate?: DateTimeFilter<"TransportSchedule"> | Date | string
    isHoliday?: BoolFilter<"TransportSchedule"> | boolean
    createdAt?: DateTimeFilter<"TransportSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"TransportSchedule"> | Date | string
    transport?: XOR<TransportScalarRelationFilter, TransportWhereInput>
  }, "id">

  export type TransportScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    transportId?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    isHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransportScheduleCountOrderByAggregateInput
    _avg?: TransportScheduleAvgOrderByAggregateInput
    _max?: TransportScheduleMaxOrderByAggregateInput
    _min?: TransportScheduleMinOrderByAggregateInput
    _sum?: TransportScheduleSumOrderByAggregateInput
  }

  export type TransportScheduleScalarWhereWithAggregatesInput = {
    AND?: TransportScheduleScalarWhereWithAggregatesInput | TransportScheduleScalarWhereWithAggregatesInput[]
    OR?: TransportScheduleScalarWhereWithAggregatesInput[]
    NOT?: TransportScheduleScalarWhereWithAggregatesInput | TransportScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransportSchedule"> | number
    transportId?: IntWithAggregatesFilter<"TransportSchedule"> | number
    departureDate?: DateTimeWithAggregatesFilter<"TransportSchedule"> | Date | string
    arrivalDate?: DateTimeWithAggregatesFilter<"TransportSchedule"> | Date | string
    isHoliday?: BoolWithAggregatesFilter<"TransportSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TransportSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransportSchedule"> | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: number
    token: string
    expiresAt: Date | string
    userId: number
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: number
    token: string
    expiresAt: Date | string
    userId: number
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoi: EnvoiCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    envoiId: number
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoi?: EnvoiUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    envoiId: number
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    userId: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    userId: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    sessionToken: string
    userId: number
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    sessionToken: string
    userId: number
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientsCreateInput = {
    client: UserCreateNestedOneWithoutClientAgenciesInput
    agency: AgencyCreateNestedOneWithoutAgencyClientsInput
  }

  export type AgencyClientsUncheckedCreateInput = {
    clientId: number
    agencyId: number
  }

  export type AgencyClientsUpdateInput = {
    client?: UserUpdateOneRequiredWithoutClientAgenciesNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyClientsNestedInput
  }

  export type AgencyClientsUncheckedUpdateInput = {
    clientId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyClientsCreateManyInput = {
    clientId: number
    agencyId: number
  }

  export type AgencyClientsUpdateManyMutationInput = {

  }

  export type AgencyClientsUncheckedUpdateManyInput = {
    clientId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyStaffCreateInput = {
    staffRole: $Enums.Role
    staff: UserCreateNestedOneWithoutAgencyStaffsInput
    agency: AgencyCreateNestedOneWithoutAgencyStaffInput
  }

  export type AgencyStaffUncheckedCreateInput = {
    id?: number
    staffId: number
    agencyId: number
    staffRole: $Enums.Role
  }

  export type AgencyStaffUpdateInput = {
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    staff?: UserUpdateOneRequiredWithoutAgencyStaffsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyStaffNestedInput
  }

  export type AgencyStaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AgencyStaffCreateManyInput = {
    id?: number
    staffId: number
    agencyId: number
    staffRole: $Enums.Role
  }

  export type AgencyStaffUpdateManyMutationInput = {
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AgencyStaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type ActivityLogCreateInput = {
    activityType: $Enums.ActivityType
    details?: string | null
    staffRole: $Enums.Role
    createdAt?: Date | string
    staff?: UserCreateNestedOneWithoutStaffsActivityLogsInput
    agency?: AgencyCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    activityType: $Enums.ActivityType
    staffId?: number | null
    agencyId?: number | null
    details?: string | null
    staffRole: $Enums.Role
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: UserUpdateOneWithoutStaffsActivityLogsNestedInput
    agency?: AgencyUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    activityType: $Enums.ActivityType
    staffId?: number | null
    agencyId?: number | null
    details?: string | null
    staffRole: $Enums.Role
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthenticatorCreateInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
    user: UserCreateNestedOneWithoutAuthenticatorInput
  }

  export type AuthenticatorUncheckedCreateInput = {
    credentialID: string
    userId: number
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUpdateInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAuthenticatorNestedInput
  }

  export type AuthenticatorUncheckedUpdateInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorCreateManyInput = {
    credentialID: string
    userId: number
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUpdateManyMutationInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateManyInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutNotificationsInput
    envoi: EnvoiCreateNestedOneWithoutNotificationsInput
    destinataireNotification?: UserCreateNestedOneWithoutNotificationsAsDestinataireInput
    clientNotification?: UserCreateNestedOneWithoutNotificationAsClientInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    message: string
    agencyId: number
    destinataireId?: number | null
    clientId?: number | null
    envoiId: number
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutNotificationsNestedInput
    envoi?: EnvoiUpdateOneRequiredWithoutNotificationsNestedInput
    destinataireNotification?: UserUpdateOneWithoutNotificationsAsDestinataireNestedInput
    clientNotification?: UserUpdateOneWithoutNotificationAsClientNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    agencyId?: IntFieldUpdateOperationsInput | number
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    envoiId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    message: string
    agencyId: number
    destinataireId?: number | null
    clientId?: number | null
    envoiId: number
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    agencyId?: IntFieldUpdateOperationsInput | number
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    envoiId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VatRateCreateInput = {
    itemClassId: number
    vatPercent: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vatType?: $Enums.VatType | null
    country: CountryCreateNestedOneWithoutVatRatesInput
  }

  export type VatRateUncheckedCreateInput = {
    id?: number
    countryId: number
    itemClassId: number
    vatPercent: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vatType?: $Enums.VatType | null
  }

  export type VatRateUpdateInput = {
    itemClassId?: IntFieldUpdateOperationsInput | number
    vatPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vatType?: NullableEnumVatTypeFieldUpdateOperationsInput | $Enums.VatType | null
    country?: CountryUpdateOneRequiredWithoutVatRatesNestedInput
  }

  export type VatRateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    itemClassId?: IntFieldUpdateOperationsInput | number
    vatPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vatType?: NullableEnumVatTypeFieldUpdateOperationsInput | $Enums.VatType | null
  }

  export type VatRateCreateManyInput = {
    id?: number
    countryId: number
    itemClassId: number
    vatPercent: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vatType?: $Enums.VatType | null
  }

  export type VatRateUpdateManyMutationInput = {
    itemClassId?: IntFieldUpdateOperationsInput | number
    vatPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vatType?: NullableEnumVatTypeFieldUpdateOperationsInput | $Enums.VatType | null
  }

  export type VatRateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    itemClassId?: IntFieldUpdateOperationsInput | number
    vatPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vatType?: NullableEnumVatTypeFieldUpdateOperationsInput | $Enums.VatType | null
  }

  export type CityCreateInput = {
    name: string
    latitude?: string | null
    longitude?: string | null
    country: CountryCreateNestedOneWithoutCitiesInput
    addresses?: AddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: number
    name: string
    latitude?: string | null
    longitude?: string | null
    countryId: number
    addresses?: AddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    addresses?: AddressUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: IntFieldUpdateOperationsInput | number
    addresses?: AddressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: number
    name: string
    latitude?: string | null
    longitude?: string | null
    countryId: number
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type CountryCreateInput = {
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital?: string | null
    currency?: string | null
    latitude?: string | null
    longitude?: string | null
    emoji?: string | null
    cities?: CityCreateNestedManyWithoutCountryInput
    timezones?: TimezoneCreateNestedManyWithoutCountryInput
    vatRates?: VatRateCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital?: string | null
    currency?: string | null
    latitude?: string | null
    longitude?: string | null
    emoji?: string | null
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    timezones?: TimezoneUncheckedCreateNestedManyWithoutCountryInput
    vatRates?: VatRateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: CityUpdateManyWithoutCountryNestedInput
    timezones?: TimezoneUpdateManyWithoutCountryNestedInput
    vatRates?: VatRateUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    timezones?: TimezoneUncheckedUpdateManyWithoutCountryNestedInput
    vatRates?: VatRateUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital?: string | null
    currency?: string | null
    latitude?: string | null
    longitude?: string | null
    emoji?: string | null
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimezoneCreateInput = {
    zoneName: string
    gmtOffset: number
    abbreviation: string
    country: CountryCreateNestedOneWithoutTimezonesInput
  }

  export type TimezoneUncheckedCreateInput = {
    id?: number
    zoneName: string
    gmtOffset: number
    abbreviation: string
    countryId: number
  }

  export type TimezoneUpdateInput = {
    zoneName?: StringFieldUpdateOperationsInput | string
    gmtOffset?: IntFieldUpdateOperationsInput | number
    abbreviation?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutTimezonesNestedInput
  }

  export type TimezoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneName?: StringFieldUpdateOperationsInput | string
    gmtOffset?: IntFieldUpdateOperationsInput | number
    abbreviation?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type TimezoneCreateManyInput = {
    id?: number
    zoneName: string
    gmtOffset: number
    abbreviation: string
    countryId: number
  }

  export type TimezoneUpdateManyMutationInput = {
    zoneName?: StringFieldUpdateOperationsInput | string
    gmtOffset?: IntFieldUpdateOperationsInput | number
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type TimezoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneName?: StringFieldUpdateOperationsInput | string
    gmtOffset?: IntFieldUpdateOperationsInput | number
    abbreviation?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type UserAddressCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    addressType: $Enums.AddressType
    address: AddressCreateNestedOneWithoutUserAddressesInput
    user: UserCreateNestedOneWithoutUserAddressesInput
  }

  export type UserAddressUncheckedCreateInput = {
    id?: number
    userId: number
    addressId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addressType: $Enums.AddressType
  }

  export type UserAddressUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    address?: AddressUpdateOneRequiredWithoutUserAddressesNestedInput
    user?: UserUpdateOneRequiredWithoutUserAddressesNestedInput
  }

  export type UserAddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
  }

  export type UserAddressCreateManyInput = {
    id?: number
    userId: number
    addressId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addressType: $Enums.AddressType
  }

  export type UserAddressUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
  }

  export type UserAddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
  }

  export type AddressCreateInput = {
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAddressesInput
    userAddresses?: UserAddressCreateNestedManyWithoutAddressInput
    agency?: AgencyCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    cityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutAddressInput
    agency?: AgencyUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressUpdateInput = {
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAddressesNestedInput
    userAddresses?: UserAddressUpdateManyWithoutAddressNestedInput
    agency?: AgencyUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAddresses?: UserAddressUncheckedUpdateManyWithoutAddressNestedInput
    agency?: AgencyUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: number
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    cityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyCreateInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
  }

  export type AgencyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientDestinataireCreateInput = {
    createdAt?: Date | string
    client: UserCreateNestedOneWithoutClientLinksInput
    destinataire: UserCreateNestedOneWithoutDestinataireLinksInput
  }

  export type ClientDestinataireUncheckedCreateInput = {
    id?: number
    clientId: number
    destinataireId: number
    createdAt?: Date | string
  }

  export type ClientDestinataireUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutClientLinksNestedInput
    destinataire?: UserUpdateOneRequiredWithoutDestinataireLinksNestedInput
  }

  export type ClientDestinataireUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    destinataireId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDestinataireCreateManyInput = {
    id?: number
    clientId: number
    destinataireId: number
    createdAt?: Date | string
  }

  export type ClientDestinataireUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDestinataireUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    destinataireId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    couponCode: string
    discountAmount: Decimal | DecimalJsLike | number | string
    discountPercentage: Decimal | DecimalJsLike | number | string
    numberOfUses: number
    startDate: Date | string
    expirationDate?: Date | string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCoupon?: UserCouponCreateNestedManyWithoutCouponInput
    envoiCoupon?: EnvoiCouponCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: number
    couponCode: string
    discountAmount: Decimal | DecimalJsLike | number | string
    discountPercentage: Decimal | DecimalJsLike | number | string
    numberOfUses: number
    startDate: Date | string
    expirationDate?: Date | string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCoupon?: UserCouponUncheckedCreateNestedManyWithoutCouponInput
    envoiCoupon?: EnvoiCouponUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponUpdateInput = {
    couponCode?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCoupon?: UserCouponUpdateManyWithoutCouponNestedInput
    envoiCoupon?: EnvoiCouponUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    couponCode?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCoupon?: UserCouponUncheckedUpdateManyWithoutCouponNestedInput
    envoiCoupon?: EnvoiCouponUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponCreateManyInput = {
    id?: number
    couponCode: string
    discountAmount: Decimal | DecimalJsLike | number | string
    discountPercentage: Decimal | DecimalJsLike | number | string
    numberOfUses: number
    startDate: Date | string
    expirationDate?: Date | string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    couponCode?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    couponCode?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponCreateInput = {
    user: UserCreateNestedOneWithoutUserCouponsInput
    coupon: CouponCreateNestedOneWithoutUserCouponInput
  }

  export type UserCouponUncheckedCreateInput = {
    userId: number
    couponId: number
  }

  export type UserCouponUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUserCouponsNestedInput
    coupon?: CouponUpdateOneRequiredWithoutUserCouponNestedInput
  }

  export type UserCouponUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCouponCreateManyInput = {
    userId: number
    couponId: number
  }

  export type UserCouponUpdateManyMutationInput = {

  }

  export type UserCouponUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
  }

  export type TransportCreateInput = {
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    envois?: EnvoiCreateNestedManyWithoutTransportInput
    transportSchedules?: TransportScheduleCreateNestedManyWithoutTransportInput
    agency?: AgencyCreateNestedOneWithoutTransportsInput
  }

  export type TransportUncheckedCreateInput = {
    id?: number
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    agencyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envois?: EnvoiUncheckedCreateNestedManyWithoutTransportInput
    transportSchedules?: TransportScheduleUncheckedCreateNestedManyWithoutTransportInput
  }

  export type TransportUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envois?: EnvoiUpdateManyWithoutTransportNestedInput
    transportSchedules?: TransportScheduleUpdateManyWithoutTransportNestedInput
    agency?: AgencyUpdateOneWithoutTransportsNestedInput
  }

  export type TransportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envois?: EnvoiUncheckedUpdateManyWithoutTransportNestedInput
    transportSchedules?: TransportScheduleUncheckedUpdateManyWithoutTransportNestedInput
  }

  export type TransportCreateManyInput = {
    id?: number
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    agencyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvoiCreateInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUpdateInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiCreateManyInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnvoiUpdateManyMutationInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvoiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingEventCreateInput = {
    eventStatus: $Enums.TrackingEventStatus
    location?: string | null
    description?: string | null
    createdAt?: Date | string
    envoi: EnvoiCreateNestedOneWithoutTrackingEventsInput
  }

  export type TrackingEventUncheckedCreateInput = {
    id?: number
    envoiId: number
    eventStatus: $Enums.TrackingEventStatus
    location?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type TrackingEventUpdateInput = {
    eventStatus?: EnumTrackingEventStatusFieldUpdateOperationsInput | $Enums.TrackingEventStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoi?: EnvoiUpdateOneRequiredWithoutTrackingEventsNestedInput
  }

  export type TrackingEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    eventStatus?: EnumTrackingEventStatusFieldUpdateOperationsInput | $Enums.TrackingEventStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingEventCreateManyInput = {
    id?: number
    envoiId: number
    eventStatus: $Enums.TrackingEventStatus
    location?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type TrackingEventUpdateManyMutationInput = {
    eventStatus?: EnumTrackingEventStatusFieldUpdateOperationsInput | $Enums.TrackingEventStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    eventStatus?: EnumTrackingEventStatusFieldUpdateOperationsInput | $Enums.TrackingEventStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    date: Date | string
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    envoi: EnvoiCreateNestedOneWithoutAppointmentsInput
    agency: AgencyCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: number
    envoiId: number
    agencyId: number
    date: Date | string
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoi?: EnvoiUpdateOneRequiredWithoutAppointmentsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyInput = {
    id?: number
    envoiId: number
    agencyId: number
    date: Date | string
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvoiCouponCreateInput = {
    envoi: EnvoiCreateNestedOneWithoutEnvoiCouponsInput
    coupon: CouponCreateNestedOneWithoutEnvoiCouponInput
  }

  export type EnvoiCouponUncheckedCreateInput = {
    envoiId: number
    couponId: number
  }

  export type EnvoiCouponUpdateInput = {
    envoi?: EnvoiUpdateOneRequiredWithoutEnvoiCouponsNestedInput
    coupon?: CouponUpdateOneRequiredWithoutEnvoiCouponNestedInput
  }

  export type EnvoiCouponUncheckedUpdateInput = {
    envoiId?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
  }

  export type EnvoiCouponCreateManyInput = {
    envoiId: number
    couponId: number
  }

  export type EnvoiCouponUpdateManyMutationInput = {

  }

  export type EnvoiCouponUncheckedUpdateManyInput = {
    envoiId?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
  }

  export type ParcelCreateInput = {
    height: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    length: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    envoi: EnvoiCreateNestedOneWithoutParcelsInput
  }

  export type ParcelUncheckedCreateInput = {
    id?: number
    envoiId: number
    height: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    length: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParcelUpdateInput = {
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    length?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoi?: EnvoiUpdateOneRequiredWithoutParcelsNestedInput
  }

  export type ParcelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    length?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelCreateManyInput = {
    id?: number
    envoiId: number
    height: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    length: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParcelUpdateManyMutationInput = {
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    length?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    length?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TarifsCreateInput = {
    weightRate: Decimal | DecimalJsLike | number | string
    volumeRate: Decimal | DecimalJsLike | number | string
    baseRate: Decimal | DecimalJsLike | number | string
    fixedRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    agency?: AgencyCreateNestedOneWithoutTarifsInput
  }

  export type TarifsUncheckedCreateInput = {
    id?: number
    agencyId?: number | null
    weightRate: Decimal | DecimalJsLike | number | string
    volumeRate: Decimal | DecimalJsLike | number | string
    baseRate: Decimal | DecimalJsLike | number | string
    fixedRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TarifsUpdateInput = {
    weightRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneWithoutTarifsNestedInput
  }

  export type TarifsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    weightRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TarifsCreateManyInput = {
    id?: number
    agencyId?: number | null
    weightRate: Decimal | DecimalJsLike | number | string
    volumeRate: Decimal | DecimalJsLike | number | string
    baseRate: Decimal | DecimalJsLike | number | string
    fixedRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TarifsUpdateManyMutationInput = {
    weightRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TarifsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    weightRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportScheduleCreateInput = {
    departureDate: Date | string
    arrivalDate: Date | string
    isHoliday?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transport: TransportCreateNestedOneWithoutTransportSchedulesInput
  }

  export type TransportScheduleUncheckedCreateInput = {
    id?: number
    transportId: number
    departureDate: Date | string
    arrivalDate: Date | string
    isHoliday?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportScheduleUpdateInput = {
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transport?: TransportUpdateOneRequiredWithoutTransportSchedulesNestedInput
  }

  export type TransportScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transportId?: IntFieldUpdateOperationsInput | number
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportScheduleCreateManyInput = {
    id?: number
    transportId: number
    departureDate: Date | string
    arrivalDate: Date | string
    isHoliday?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportScheduleUpdateManyMutationInput = {
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transportId?: IntFieldUpdateOperationsInput | number
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnvoiScalarRelationFilter = {
    is?: EnvoiWhereInput
    isNot?: EnvoiWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuthenticatorListRelationFilter = {
    every?: AuthenticatorWhereInput
    some?: AuthenticatorWhereInput
    none?: AuthenticatorWhereInput
  }

  export type EnvoiListRelationFilter = {
    every?: EnvoiWhereInput
    some?: EnvoiWhereInput
    none?: EnvoiWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserCouponListRelationFilter = {
    every?: UserCouponWhereInput
    some?: UserCouponWhereInput
    none?: UserCouponWhereInput
  }

  export type ClientDestinataireListRelationFilter = {
    every?: ClientDestinataireWhereInput
    some?: ClientDestinataireWhereInput
    none?: ClientDestinataireWhereInput
  }

  export type AgencyClientsListRelationFilter = {
    every?: AgencyClientsWhereInput
    some?: AgencyClientsWhereInput
    none?: AgencyClientsWhereInput
  }

  export type AgencyStaffListRelationFilter = {
    every?: AgencyStaffWhereInput
    some?: AgencyStaffWhereInput
    none?: AgencyStaffWhereInput
  }

  export type UserAddressListRelationFilter = {
    every?: UserAddressWhereInput
    some?: UserAddressWhereInput
    none?: UserAddressWhereInput
  }

  export type AgencyListRelationFilter = {
    every?: AgencyWhereInput
    some?: AgencyWhereInput
    none?: AgencyWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthenticatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnvoiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientDestinataireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyClientsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isEnterprise?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isEnterprise?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isEnterprise?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type AgencyScalarRelationFilter = {
    is?: AgencyWhereInput
    isNot?: AgencyWhereInput
  }

  export type AgencyClientsClientIdAgencyIdCompoundUniqueInput = {
    clientId: number
    agencyId: number
  }

  export type AgencyClientsCountOrderByAggregateInput = {
    clientId?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyClientsAvgOrderByAggregateInput = {
    clientId?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyClientsMaxOrderByAggregateInput = {
    clientId?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyClientsMinOrderByAggregateInput = {
    clientId?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyClientsSumOrderByAggregateInput = {
    clientId?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyStaffStaffIdAgencyIdStaffRoleCompoundUniqueInput = {
    staffId: number
    agencyId: number
    staffRole: $Enums.Role
  }

  export type AgencyStaffCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
    staffRole?: SortOrder
  }

  export type AgencyStaffAvgOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
    staffRole?: SortOrder
  }

  export type AgencyStaffMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
    staffRole?: SortOrder
  }

  export type AgencyStaffSumOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AgencyNullableScalarRelationFilter = {
    is?: AgencyWhereInput | null
    isNot?: AgencyWhereInput | null
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    activityType?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
    details?: SortOrder
    staffRole?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    activityType?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
    details?: SortOrder
    staffRole?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    activityType?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
    details?: SortOrder
    staffRole?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    agencyId?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type AuthenticatorUserIdCredentialIDCompoundUniqueInput = {
    userId: number
    credentialID: string
  }

  export type AuthenticatorCountOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorAvgOrderByAggregateInput = {
    userId?: SortOrder
    counter?: SortOrder
  }

  export type AuthenticatorMaxOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorMinOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorSumOrderByAggregateInput = {
    userId?: SortOrder
    counter?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    agencyId?: SortOrder
    destinataireId?: SortOrder
    clientId?: SortOrder
    envoiId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    destinataireId?: SortOrder
    clientId?: SortOrder
    envoiId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    agencyId?: SortOrder
    destinataireId?: SortOrder
    clientId?: SortOrder
    envoiId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    agencyId?: SortOrder
    destinataireId?: SortOrder
    clientId?: SortOrder
    envoiId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    destinataireId?: SortOrder
    clientId?: SortOrder
    envoiId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumVatTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VatType | EnumVatTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VatType[] | ListEnumVatTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VatType[] | ListEnumVatTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVatTypeNullableFilter<$PrismaModel> | $Enums.VatType | null
  }

  export type CountryScalarRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type VatRateCountOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    itemClassId?: SortOrder
    vatPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vatType?: SortOrder
  }

  export type VatRateAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    itemClassId?: SortOrder
    vatPercent?: SortOrder
  }

  export type VatRateMaxOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    itemClassId?: SortOrder
    vatPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vatType?: SortOrder
  }

  export type VatRateMinOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    itemClassId?: SortOrder
    vatPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vatType?: SortOrder
  }

  export type VatRateSumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    itemClassId?: SortOrder
    vatPercent?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumVatTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VatType | EnumVatTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VatType[] | ListEnumVatTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VatType[] | ListEnumVatTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVatTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VatType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVatTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVatTypeNullableFilter<$PrismaModel>
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityNameCountryIdCompoundUniqueInput = {
    name: string
    countryId: number
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    countryId?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    countryId?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    countryId?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type TimezoneListRelationFilter = {
    every?: TimezoneWhereInput
    some?: TimezoneWhereInput
    none?: TimezoneWhereInput
  }

  export type VatRateListRelationFilter = {
    every?: VatRateWhereInput
    some?: VatRateWhereInput
    none?: VatRateWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimezoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VatRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso2?: SortOrder
    iso3?: SortOrder
    phonecode?: SortOrder
    capital?: SortOrder
    currency?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    emoji?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso2?: SortOrder
    iso3?: SortOrder
    phonecode?: SortOrder
    capital?: SortOrder
    currency?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    emoji?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso2?: SortOrder
    iso3?: SortOrder
    phonecode?: SortOrder
    capital?: SortOrder
    currency?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    emoji?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TimezoneZoneNameCountryIdCompoundUniqueInput = {
    zoneName: string
    countryId: number
  }

  export type TimezoneCountOrderByAggregateInput = {
    id?: SortOrder
    zoneName?: SortOrder
    gmtOffset?: SortOrder
    abbreviation?: SortOrder
    countryId?: SortOrder
  }

  export type TimezoneAvgOrderByAggregateInput = {
    id?: SortOrder
    gmtOffset?: SortOrder
    countryId?: SortOrder
  }

  export type TimezoneMaxOrderByAggregateInput = {
    id?: SortOrder
    zoneName?: SortOrder
    gmtOffset?: SortOrder
    abbreviation?: SortOrder
    countryId?: SortOrder
  }

  export type TimezoneMinOrderByAggregateInput = {
    id?: SortOrder
    zoneName?: SortOrder
    gmtOffset?: SortOrder
    abbreviation?: SortOrder
    countryId?: SortOrder
  }

  export type TimezoneSumOrderByAggregateInput = {
    id?: SortOrder
    gmtOffset?: SortOrder
    countryId?: SortOrder
  }

  export type EnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type AddressScalarRelationFilter = {
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type UserAddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressType?: SortOrder
  }

  export type UserAddressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressId?: SortOrder
  }

  export type UserAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressType?: SortOrder
  }

  export type UserAddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressType?: SortOrder
  }

  export type UserAddressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressId?: SortOrder
  }

  export type EnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    complement?: SortOrder
    streetNumber?: SortOrder
    boxNumber?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    complement?: SortOrder
    streetNumber?: SortOrder
    boxNumber?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    complement?: SortOrder
    streetNumber?: SortOrder
    boxNumber?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type TransportListRelationFilter = {
    every?: TransportWhereInput
    some?: TransportWhereInput
    none?: TransportWhereInput
  }

  export type TarifsListRelationFilter = {
    every?: TarifsWhereInput
    some?: TarifsWhereInput
    none?: TarifsWhereInput
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TarifsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyNameAddressIdCompoundUniqueInput = {
    name: string
    addressId: number
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    vatNumber?: SortOrder
    addressId?: SortOrder
    capacity?: SortOrder
    availableSlots?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type AgencyAvgOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    capacity?: SortOrder
    availableSlots?: SortOrder
    createdById?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    vatNumber?: SortOrder
    addressId?: SortOrder
    capacity?: SortOrder
    availableSlots?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    vatNumber?: SortOrder
    addressId?: SortOrder
    capacity?: SortOrder
    availableSlots?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type AgencySumOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    capacity?: SortOrder
    availableSlots?: SortOrder
    createdById?: SortOrder
  }

  export type ClientDestinataireClientIdDestinataireIdCompoundUniqueInput = {
    clientId: number
    destinataireId: number
  }

  export type ClientDestinataireCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    destinataireId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientDestinataireAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    destinataireId?: SortOrder
  }

  export type ClientDestinataireMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    destinataireId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientDestinataireMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    destinataireId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientDestinataireSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    destinataireId?: SortOrder
  }

  export type EnvoiCouponListRelationFilter = {
    every?: EnvoiCouponWhereInput
    some?: EnvoiCouponWhereInput
    none?: EnvoiCouponWhereInput
  }

  export type EnvoiCouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    couponCode?: SortOrder
    discountAmount?: SortOrder
    discountPercentage?: SortOrder
    numberOfUses?: SortOrder
    startDate?: SortOrder
    expirationDate?: SortOrder
    termsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    id?: SortOrder
    discountAmount?: SortOrder
    discountPercentage?: SortOrder
    numberOfUses?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    couponCode?: SortOrder
    discountAmount?: SortOrder
    discountPercentage?: SortOrder
    numberOfUses?: SortOrder
    startDate?: SortOrder
    expirationDate?: SortOrder
    termsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    couponCode?: SortOrder
    discountAmount?: SortOrder
    discountPercentage?: SortOrder
    numberOfUses?: SortOrder
    startDate?: SortOrder
    expirationDate?: SortOrder
    termsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    id?: SortOrder
    discountAmount?: SortOrder
    discountPercentage?: SortOrder
    numberOfUses?: SortOrder
  }

  export type CouponScalarRelationFilter = {
    is?: CouponWhereInput
    isNot?: CouponWhereInput
  }

  export type UserCouponUserIdCouponIdCompoundUniqueInput = {
    userId: number
    couponId: number
  }

  export type UserCouponCountOrderByAggregateInput = {
    userId?: SortOrder
    couponId?: SortOrder
  }

  export type UserCouponAvgOrderByAggregateInput = {
    userId?: SortOrder
    couponId?: SortOrder
  }

  export type UserCouponMaxOrderByAggregateInput = {
    userId?: SortOrder
    couponId?: SortOrder
  }

  export type UserCouponMinOrderByAggregateInput = {
    userId?: SortOrder
    couponId?: SortOrder
  }

  export type UserCouponSumOrderByAggregateInput = {
    userId?: SortOrder
    couponId?: SortOrder
  }

  export type TransportScheduleListRelationFilter = {
    every?: TransportScheduleWhereInput
    some?: TransportScheduleWhereInput
    none?: TransportScheduleWhereInput
  }

  export type TransportScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransportCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    baseVolume?: SortOrder
    baseWeight?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    isAvailable?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransportAvgOrderByAggregateInput = {
    id?: SortOrder
    baseVolume?: SortOrder
    baseWeight?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    agencyId?: SortOrder
  }

  export type TransportMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    baseVolume?: SortOrder
    baseWeight?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    isAvailable?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransportMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    baseVolume?: SortOrder
    baseWeight?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    isAvailable?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransportSumOrderByAggregateInput = {
    id?: SortOrder
    baseVolume?: SortOrder
    baseWeight?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    agencyId?: SortOrder
  }

  export type EnumSimulationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusFilter<$PrismaModel> | $Enums.SimulationStatus
  }

  export type EnumEnvoiStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnvoiStatus | EnumEnvoiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnvoiStatus[] | ListEnumEnvoiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnvoiStatus[] | ListEnumEnvoiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnvoiStatusFilter<$PrismaModel> | $Enums.EnvoiStatus
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type TransportNullableScalarRelationFilter = {
    is?: TransportWhereInput | null
    isNot?: TransportWhereInput | null
  }

  export type ParcelListRelationFilter = {
    every?: ParcelWhereInput
    some?: ParcelWhereInput
    none?: ParcelWhereInput
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type TrackingEventListRelationFilter = {
    every?: TrackingEventWhereInput
    some?: TrackingEventWhereInput
    none?: TrackingEventWhereInput
  }

  export type ParcelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrackingEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnvoiCountOrderByAggregateInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    qrCodeUrl?: SortOrder
    userId?: SortOrder
    destinataireId?: SortOrder
    transportId?: SortOrder
    departureAgencyId?: SortOrder
    arrivalAgencyId?: SortOrder
    simulationStatus?: SortOrder
    envoiStatus?: SortOrder
    totalWeight?: SortOrder
    totalVolume?: SortOrder
    totalPrice?: SortOrder
    paid?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    verificationToken?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnvoiAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    destinataireId?: SortOrder
    transportId?: SortOrder
    departureAgencyId?: SortOrder
    arrivalAgencyId?: SortOrder
    totalWeight?: SortOrder
    totalVolume?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnvoiMaxOrderByAggregateInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    qrCodeUrl?: SortOrder
    userId?: SortOrder
    destinataireId?: SortOrder
    transportId?: SortOrder
    departureAgencyId?: SortOrder
    arrivalAgencyId?: SortOrder
    simulationStatus?: SortOrder
    envoiStatus?: SortOrder
    totalWeight?: SortOrder
    totalVolume?: SortOrder
    totalPrice?: SortOrder
    paid?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    verificationToken?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnvoiMinOrderByAggregateInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    qrCodeUrl?: SortOrder
    userId?: SortOrder
    destinataireId?: SortOrder
    transportId?: SortOrder
    departureAgencyId?: SortOrder
    arrivalAgencyId?: SortOrder
    simulationStatus?: SortOrder
    envoiStatus?: SortOrder
    totalWeight?: SortOrder
    totalVolume?: SortOrder
    totalPrice?: SortOrder
    paid?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    verificationToken?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnvoiSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    destinataireId?: SortOrder
    transportId?: SortOrder
    departureAgencyId?: SortOrder
    arrivalAgencyId?: SortOrder
    totalWeight?: SortOrder
    totalVolume?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumSimulationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimulationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimulationStatusFilter<$PrismaModel>
    _max?: NestedEnumSimulationStatusFilter<$PrismaModel>
  }

  export type EnumEnvoiStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnvoiStatus | EnumEnvoiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnvoiStatus[] | ListEnumEnvoiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnvoiStatus[] | ListEnumEnvoiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnvoiStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnvoiStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnvoiStatusFilter<$PrismaModel>
    _max?: NestedEnumEnvoiStatusFilter<$PrismaModel>
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumTrackingEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingEventStatus | EnumTrackingEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingEventStatus[] | ListEnumTrackingEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingEventStatus[] | ListEnumTrackingEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingEventStatusFilter<$PrismaModel> | $Enums.TrackingEventStatus
  }

  export type TrackingEventCountOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    eventStatus?: SortOrder
    location?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackingEventAvgOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
  }

  export type TrackingEventMaxOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    eventStatus?: SortOrder
    location?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackingEventMinOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    eventStatus?: SortOrder
    location?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackingEventSumOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
  }

  export type EnumTrackingEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingEventStatus | EnumTrackingEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingEventStatus[] | ListEnumTrackingEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingEventStatus[] | ListEnumTrackingEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrackingEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackingEventStatusFilter<$PrismaModel>
    _max?: NestedEnumTrackingEventStatusFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    agencyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    agencyId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    agencyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    agencyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    agencyId?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type EnvoiCouponEnvoiIdCouponIdCompoundUniqueInput = {
    envoiId: number
    couponId: number
  }

  export type EnvoiCouponCountOrderByAggregateInput = {
    envoiId?: SortOrder
    couponId?: SortOrder
  }

  export type EnvoiCouponAvgOrderByAggregateInput = {
    envoiId?: SortOrder
    couponId?: SortOrder
  }

  export type EnvoiCouponMaxOrderByAggregateInput = {
    envoiId?: SortOrder
    couponId?: SortOrder
  }

  export type EnvoiCouponMinOrderByAggregateInput = {
    envoiId?: SortOrder
    couponId?: SortOrder
  }

  export type EnvoiCouponSumOrderByAggregateInput = {
    envoiId?: SortOrder
    couponId?: SortOrder
  }

  export type ParcelCountOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    length?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParcelAvgOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    length?: SortOrder
  }

  export type ParcelMaxOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    length?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParcelMinOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    length?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParcelSumOrderByAggregateInput = {
    id?: SortOrder
    envoiId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    length?: SortOrder
  }

  export type TarifsCountOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    weightRate?: SortOrder
    volumeRate?: SortOrder
    baseRate?: SortOrder
    fixedRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TarifsAvgOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    weightRate?: SortOrder
    volumeRate?: SortOrder
    baseRate?: SortOrder
    fixedRate?: SortOrder
  }

  export type TarifsMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    weightRate?: SortOrder
    volumeRate?: SortOrder
    baseRate?: SortOrder
    fixedRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TarifsMinOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    weightRate?: SortOrder
    volumeRate?: SortOrder
    baseRate?: SortOrder
    fixedRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TarifsSumOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    weightRate?: SortOrder
    volumeRate?: SortOrder
    baseRate?: SortOrder
    fixedRate?: SortOrder
  }

  export type TransportScalarRelationFilter = {
    is?: TransportWhereInput
    isNot?: TransportWhereInput
  }

  export type TransportScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    transportId?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    isHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransportScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    transportId?: SortOrder
  }

  export type TransportScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    transportId?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    isHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransportScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    transportId?: SortOrder
    departureDate?: SortOrder
    arrivalDate?: SortOrder
    isHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransportScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    transportId?: SortOrder
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnvoiCreateNestedOneWithoutPaymentInput = {
    create?: XOR<EnvoiCreateWithoutPaymentInput, EnvoiUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutPaymentInput
    connect?: EnvoiWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnvoiUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<EnvoiCreateWithoutPaymentInput, EnvoiUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutPaymentInput
    upsert?: EnvoiUpsertWithoutPaymentInput
    connect?: EnvoiWhereUniqueInput
    update?: XOR<XOR<EnvoiUpdateToOneWithWhereWithoutPaymentInput, EnvoiUpdateWithoutPaymentInput>, EnvoiUncheckedUpdateWithoutPaymentInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuthenticatorCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
  }

  export type EnvoiCreateNestedManyWithoutClientInput = {
    create?: XOR<EnvoiCreateWithoutClientInput, EnvoiUncheckedCreateWithoutClientInput> | EnvoiCreateWithoutClientInput[] | EnvoiUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutClientInput | EnvoiCreateOrConnectWithoutClientInput[]
    createMany?: EnvoiCreateManyClientInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type EnvoiCreateNestedManyWithoutDestinataireInput = {
    create?: XOR<EnvoiCreateWithoutDestinataireInput, EnvoiUncheckedCreateWithoutDestinataireInput> | EnvoiCreateWithoutDestinataireInput[] | EnvoiUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutDestinataireInput | EnvoiCreateOrConnectWithoutDestinataireInput[]
    createMany?: EnvoiCreateManyDestinataireInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutDestinataireNotificationInput = {
    create?: XOR<NotificationCreateWithoutDestinataireNotificationInput, NotificationUncheckedCreateWithoutDestinataireNotificationInput> | NotificationCreateWithoutDestinataireNotificationInput[] | NotificationUncheckedCreateWithoutDestinataireNotificationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDestinataireNotificationInput | NotificationCreateOrConnectWithoutDestinataireNotificationInput[]
    createMany?: NotificationCreateManyDestinataireNotificationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutClientNotificationInput = {
    create?: XOR<NotificationCreateWithoutClientNotificationInput, NotificationUncheckedCreateWithoutClientNotificationInput> | NotificationCreateWithoutClientNotificationInput[] | NotificationUncheckedCreateWithoutClientNotificationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientNotificationInput | NotificationCreateOrConnectWithoutClientNotificationInput[]
    createMany?: NotificationCreateManyClientNotificationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserCouponCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput> | UserCouponCreateWithoutUserInput[] | UserCouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutUserInput | UserCouponCreateOrConnectWithoutUserInput[]
    createMany?: UserCouponCreateManyUserInputEnvelope
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
  }

  export type ClientDestinataireCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientDestinataireCreateWithoutClientInput, ClientDestinataireUncheckedCreateWithoutClientInput> | ClientDestinataireCreateWithoutClientInput[] | ClientDestinataireUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientDestinataireCreateOrConnectWithoutClientInput | ClientDestinataireCreateOrConnectWithoutClientInput[]
    createMany?: ClientDestinataireCreateManyClientInputEnvelope
    connect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
  }

  export type ClientDestinataireCreateNestedManyWithoutDestinataireInput = {
    create?: XOR<ClientDestinataireCreateWithoutDestinataireInput, ClientDestinataireUncheckedCreateWithoutDestinataireInput> | ClientDestinataireCreateWithoutDestinataireInput[] | ClientDestinataireUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: ClientDestinataireCreateOrConnectWithoutDestinataireInput | ClientDestinataireCreateOrConnectWithoutDestinataireInput[]
    createMany?: ClientDestinataireCreateManyDestinataireInputEnvelope
    connect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
  }

  export type AgencyClientsCreateNestedManyWithoutClientInput = {
    create?: XOR<AgencyClientsCreateWithoutClientInput, AgencyClientsUncheckedCreateWithoutClientInput> | AgencyClientsCreateWithoutClientInput[] | AgencyClientsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyClientsCreateOrConnectWithoutClientInput | AgencyClientsCreateOrConnectWithoutClientInput[]
    createMany?: AgencyClientsCreateManyClientInputEnvelope
    connect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
  }

  export type AgencyStaffCreateNestedManyWithoutStaffInput = {
    create?: XOR<AgencyStaffCreateWithoutStaffInput, AgencyStaffUncheckedCreateWithoutStaffInput> | AgencyStaffCreateWithoutStaffInput[] | AgencyStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AgencyStaffCreateOrConnectWithoutStaffInput | AgencyStaffCreateOrConnectWithoutStaffInput[]
    createMany?: AgencyStaffCreateManyStaffInputEnvelope
    connect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
  }

  export type UserAddressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type AgencyCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AgencyCreateWithoutCreatedByInput, AgencyUncheckedCreateWithoutCreatedByInput> | AgencyCreateWithoutCreatedByInput[] | AgencyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyCreateOrConnectWithoutCreatedByInput | AgencyCreateOrConnectWithoutCreatedByInput[]
    createMany?: AgencyCreateManyCreatedByInputEnvelope
    connect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutStaffInput = {
    create?: XOR<ActivityLogCreateWithoutStaffInput, ActivityLogUncheckedCreateWithoutStaffInput> | ActivityLogCreateWithoutStaffInput[] | ActivityLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutStaffInput | ActivityLogCreateOrConnectWithoutStaffInput[]
    createMany?: ActivityLogCreateManyStaffInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuthenticatorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
  }

  export type EnvoiUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<EnvoiCreateWithoutClientInput, EnvoiUncheckedCreateWithoutClientInput> | EnvoiCreateWithoutClientInput[] | EnvoiUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutClientInput | EnvoiCreateOrConnectWithoutClientInput[]
    createMany?: EnvoiCreateManyClientInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type EnvoiUncheckedCreateNestedManyWithoutDestinataireInput = {
    create?: XOR<EnvoiCreateWithoutDestinataireInput, EnvoiUncheckedCreateWithoutDestinataireInput> | EnvoiCreateWithoutDestinataireInput[] | EnvoiUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutDestinataireInput | EnvoiCreateOrConnectWithoutDestinataireInput[]
    createMany?: EnvoiCreateManyDestinataireInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput = {
    create?: XOR<NotificationCreateWithoutDestinataireNotificationInput, NotificationUncheckedCreateWithoutDestinataireNotificationInput> | NotificationCreateWithoutDestinataireNotificationInput[] | NotificationUncheckedCreateWithoutDestinataireNotificationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDestinataireNotificationInput | NotificationCreateOrConnectWithoutDestinataireNotificationInput[]
    createMany?: NotificationCreateManyDestinataireNotificationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutClientNotificationInput = {
    create?: XOR<NotificationCreateWithoutClientNotificationInput, NotificationUncheckedCreateWithoutClientNotificationInput> | NotificationCreateWithoutClientNotificationInput[] | NotificationUncheckedCreateWithoutClientNotificationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientNotificationInput | NotificationCreateOrConnectWithoutClientNotificationInput[]
    createMany?: NotificationCreateManyClientNotificationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserCouponUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput> | UserCouponCreateWithoutUserInput[] | UserCouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutUserInput | UserCouponCreateOrConnectWithoutUserInput[]
    createMany?: UserCouponCreateManyUserInputEnvelope
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
  }

  export type ClientDestinataireUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientDestinataireCreateWithoutClientInput, ClientDestinataireUncheckedCreateWithoutClientInput> | ClientDestinataireCreateWithoutClientInput[] | ClientDestinataireUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientDestinataireCreateOrConnectWithoutClientInput | ClientDestinataireCreateOrConnectWithoutClientInput[]
    createMany?: ClientDestinataireCreateManyClientInputEnvelope
    connect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
  }

  export type ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput = {
    create?: XOR<ClientDestinataireCreateWithoutDestinataireInput, ClientDestinataireUncheckedCreateWithoutDestinataireInput> | ClientDestinataireCreateWithoutDestinataireInput[] | ClientDestinataireUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: ClientDestinataireCreateOrConnectWithoutDestinataireInput | ClientDestinataireCreateOrConnectWithoutDestinataireInput[]
    createMany?: ClientDestinataireCreateManyDestinataireInputEnvelope
    connect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
  }

  export type AgencyClientsUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AgencyClientsCreateWithoutClientInput, AgencyClientsUncheckedCreateWithoutClientInput> | AgencyClientsCreateWithoutClientInput[] | AgencyClientsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyClientsCreateOrConnectWithoutClientInput | AgencyClientsCreateOrConnectWithoutClientInput[]
    createMany?: AgencyClientsCreateManyClientInputEnvelope
    connect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
  }

  export type AgencyStaffUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<AgencyStaffCreateWithoutStaffInput, AgencyStaffUncheckedCreateWithoutStaffInput> | AgencyStaffCreateWithoutStaffInput[] | AgencyStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AgencyStaffCreateOrConnectWithoutStaffInput | AgencyStaffCreateOrConnectWithoutStaffInput[]
    createMany?: AgencyStaffCreateManyStaffInputEnvelope
    connect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
  }

  export type UserAddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type AgencyUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AgencyCreateWithoutCreatedByInput, AgencyUncheckedCreateWithoutCreatedByInput> | AgencyCreateWithoutCreatedByInput[] | AgencyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyCreateOrConnectWithoutCreatedByInput | AgencyCreateOrConnectWithoutCreatedByInput[]
    createMany?: AgencyCreateManyCreatedByInputEnvelope
    connect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ActivityLogCreateWithoutStaffInput, ActivityLogUncheckedCreateWithoutStaffInput> | ActivityLogCreateWithoutStaffInput[] | ActivityLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutStaffInput | ActivityLogCreateOrConnectWithoutStaffInput[]
    createMany?: ActivityLogCreateManyStaffInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuthenticatorUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    upsert?: AuthenticatorUpsertWithWhereUniqueWithoutUserInput | AuthenticatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    set?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    disconnect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    delete?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    update?: AuthenticatorUpdateWithWhereUniqueWithoutUserInput | AuthenticatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthenticatorUpdateManyWithWhereWithoutUserInput | AuthenticatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
  }

  export type EnvoiUpdateManyWithoutClientNestedInput = {
    create?: XOR<EnvoiCreateWithoutClientInput, EnvoiUncheckedCreateWithoutClientInput> | EnvoiCreateWithoutClientInput[] | EnvoiUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutClientInput | EnvoiCreateOrConnectWithoutClientInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutClientInput | EnvoiUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: EnvoiCreateManyClientInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutClientInput | EnvoiUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutClientInput | EnvoiUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type EnvoiUpdateManyWithoutDestinataireNestedInput = {
    create?: XOR<EnvoiCreateWithoutDestinataireInput, EnvoiUncheckedCreateWithoutDestinataireInput> | EnvoiCreateWithoutDestinataireInput[] | EnvoiUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutDestinataireInput | EnvoiCreateOrConnectWithoutDestinataireInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutDestinataireInput | EnvoiUpsertWithWhereUniqueWithoutDestinataireInput[]
    createMany?: EnvoiCreateManyDestinataireInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutDestinataireInput | EnvoiUpdateWithWhereUniqueWithoutDestinataireInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutDestinataireInput | EnvoiUpdateManyWithWhereWithoutDestinataireInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutDestinataireNotificationNestedInput = {
    create?: XOR<NotificationCreateWithoutDestinataireNotificationInput, NotificationUncheckedCreateWithoutDestinataireNotificationInput> | NotificationCreateWithoutDestinataireNotificationInput[] | NotificationUncheckedCreateWithoutDestinataireNotificationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDestinataireNotificationInput | NotificationCreateOrConnectWithoutDestinataireNotificationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDestinataireNotificationInput | NotificationUpsertWithWhereUniqueWithoutDestinataireNotificationInput[]
    createMany?: NotificationCreateManyDestinataireNotificationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDestinataireNotificationInput | NotificationUpdateWithWhereUniqueWithoutDestinataireNotificationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDestinataireNotificationInput | NotificationUpdateManyWithWhereWithoutDestinataireNotificationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutClientNotificationNestedInput = {
    create?: XOR<NotificationCreateWithoutClientNotificationInput, NotificationUncheckedCreateWithoutClientNotificationInput> | NotificationCreateWithoutClientNotificationInput[] | NotificationUncheckedCreateWithoutClientNotificationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientNotificationInput | NotificationCreateOrConnectWithoutClientNotificationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutClientNotificationInput | NotificationUpsertWithWhereUniqueWithoutClientNotificationInput[]
    createMany?: NotificationCreateManyClientNotificationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutClientNotificationInput | NotificationUpdateWithWhereUniqueWithoutClientNotificationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutClientNotificationInput | NotificationUpdateManyWithWhereWithoutClientNotificationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCouponUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput> | UserCouponCreateWithoutUserInput[] | UserCouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutUserInput | UserCouponCreateOrConnectWithoutUserInput[]
    upsert?: UserCouponUpsertWithWhereUniqueWithoutUserInput | UserCouponUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCouponCreateManyUserInputEnvelope
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    update?: UserCouponUpdateWithWhereUniqueWithoutUserInput | UserCouponUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCouponUpdateManyWithWhereWithoutUserInput | UserCouponUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
  }

  export type ClientDestinataireUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientDestinataireCreateWithoutClientInput, ClientDestinataireUncheckedCreateWithoutClientInput> | ClientDestinataireCreateWithoutClientInput[] | ClientDestinataireUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientDestinataireCreateOrConnectWithoutClientInput | ClientDestinataireCreateOrConnectWithoutClientInput[]
    upsert?: ClientDestinataireUpsertWithWhereUniqueWithoutClientInput | ClientDestinataireUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientDestinataireCreateManyClientInputEnvelope
    set?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    disconnect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    delete?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    connect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    update?: ClientDestinataireUpdateWithWhereUniqueWithoutClientInput | ClientDestinataireUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientDestinataireUpdateManyWithWhereWithoutClientInput | ClientDestinataireUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientDestinataireScalarWhereInput | ClientDestinataireScalarWhereInput[]
  }

  export type ClientDestinataireUpdateManyWithoutDestinataireNestedInput = {
    create?: XOR<ClientDestinataireCreateWithoutDestinataireInput, ClientDestinataireUncheckedCreateWithoutDestinataireInput> | ClientDestinataireCreateWithoutDestinataireInput[] | ClientDestinataireUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: ClientDestinataireCreateOrConnectWithoutDestinataireInput | ClientDestinataireCreateOrConnectWithoutDestinataireInput[]
    upsert?: ClientDestinataireUpsertWithWhereUniqueWithoutDestinataireInput | ClientDestinataireUpsertWithWhereUniqueWithoutDestinataireInput[]
    createMany?: ClientDestinataireCreateManyDestinataireInputEnvelope
    set?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    disconnect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    delete?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    connect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    update?: ClientDestinataireUpdateWithWhereUniqueWithoutDestinataireInput | ClientDestinataireUpdateWithWhereUniqueWithoutDestinataireInput[]
    updateMany?: ClientDestinataireUpdateManyWithWhereWithoutDestinataireInput | ClientDestinataireUpdateManyWithWhereWithoutDestinataireInput[]
    deleteMany?: ClientDestinataireScalarWhereInput | ClientDestinataireScalarWhereInput[]
  }

  export type AgencyClientsUpdateManyWithoutClientNestedInput = {
    create?: XOR<AgencyClientsCreateWithoutClientInput, AgencyClientsUncheckedCreateWithoutClientInput> | AgencyClientsCreateWithoutClientInput[] | AgencyClientsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyClientsCreateOrConnectWithoutClientInput | AgencyClientsCreateOrConnectWithoutClientInput[]
    upsert?: AgencyClientsUpsertWithWhereUniqueWithoutClientInput | AgencyClientsUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AgencyClientsCreateManyClientInputEnvelope
    set?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    disconnect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    delete?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    connect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    update?: AgencyClientsUpdateWithWhereUniqueWithoutClientInput | AgencyClientsUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AgencyClientsUpdateManyWithWhereWithoutClientInput | AgencyClientsUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AgencyClientsScalarWhereInput | AgencyClientsScalarWhereInput[]
  }

  export type AgencyStaffUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AgencyStaffCreateWithoutStaffInput, AgencyStaffUncheckedCreateWithoutStaffInput> | AgencyStaffCreateWithoutStaffInput[] | AgencyStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AgencyStaffCreateOrConnectWithoutStaffInput | AgencyStaffCreateOrConnectWithoutStaffInput[]
    upsert?: AgencyStaffUpsertWithWhereUniqueWithoutStaffInput | AgencyStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AgencyStaffCreateManyStaffInputEnvelope
    set?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    disconnect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    delete?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    connect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    update?: AgencyStaffUpdateWithWhereUniqueWithoutStaffInput | AgencyStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AgencyStaffUpdateManyWithWhereWithoutStaffInput | AgencyStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AgencyStaffScalarWhereInput | AgencyStaffScalarWhereInput[]
  }

  export type UserAddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutUserInput | UserAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutUserInput | UserAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutUserInput | UserAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type AgencyUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AgencyCreateWithoutCreatedByInput, AgencyUncheckedCreateWithoutCreatedByInput> | AgencyCreateWithoutCreatedByInput[] | AgencyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyCreateOrConnectWithoutCreatedByInput | AgencyCreateOrConnectWithoutCreatedByInput[]
    upsert?: AgencyUpsertWithWhereUniqueWithoutCreatedByInput | AgencyUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AgencyCreateManyCreatedByInputEnvelope
    set?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    disconnect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    delete?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    connect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    update?: AgencyUpdateWithWhereUniqueWithoutCreatedByInput | AgencyUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AgencyUpdateManyWithWhereWithoutCreatedByInput | AgencyUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AgencyScalarWhereInput | AgencyScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ActivityLogCreateWithoutStaffInput, ActivityLogUncheckedCreateWithoutStaffInput> | ActivityLogCreateWithoutStaffInput[] | ActivityLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutStaffInput | ActivityLogCreateOrConnectWithoutStaffInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutStaffInput | ActivityLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ActivityLogCreateManyStaffInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutStaffInput | ActivityLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutStaffInput | ActivityLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuthenticatorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    upsert?: AuthenticatorUpsertWithWhereUniqueWithoutUserInput | AuthenticatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    set?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    disconnect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    delete?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    update?: AuthenticatorUpdateWithWhereUniqueWithoutUserInput | AuthenticatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthenticatorUpdateManyWithWhereWithoutUserInput | AuthenticatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
  }

  export type EnvoiUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<EnvoiCreateWithoutClientInput, EnvoiUncheckedCreateWithoutClientInput> | EnvoiCreateWithoutClientInput[] | EnvoiUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutClientInput | EnvoiCreateOrConnectWithoutClientInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutClientInput | EnvoiUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: EnvoiCreateManyClientInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutClientInput | EnvoiUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutClientInput | EnvoiUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput = {
    create?: XOR<EnvoiCreateWithoutDestinataireInput, EnvoiUncheckedCreateWithoutDestinataireInput> | EnvoiCreateWithoutDestinataireInput[] | EnvoiUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutDestinataireInput | EnvoiCreateOrConnectWithoutDestinataireInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutDestinataireInput | EnvoiUpsertWithWhereUniqueWithoutDestinataireInput[]
    createMany?: EnvoiCreateManyDestinataireInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutDestinataireInput | EnvoiUpdateWithWhereUniqueWithoutDestinataireInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutDestinataireInput | EnvoiUpdateManyWithWhereWithoutDestinataireInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput = {
    create?: XOR<NotificationCreateWithoutDestinataireNotificationInput, NotificationUncheckedCreateWithoutDestinataireNotificationInput> | NotificationCreateWithoutDestinataireNotificationInput[] | NotificationUncheckedCreateWithoutDestinataireNotificationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDestinataireNotificationInput | NotificationCreateOrConnectWithoutDestinataireNotificationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDestinataireNotificationInput | NotificationUpsertWithWhereUniqueWithoutDestinataireNotificationInput[]
    createMany?: NotificationCreateManyDestinataireNotificationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDestinataireNotificationInput | NotificationUpdateWithWhereUniqueWithoutDestinataireNotificationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDestinataireNotificationInput | NotificationUpdateManyWithWhereWithoutDestinataireNotificationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput = {
    create?: XOR<NotificationCreateWithoutClientNotificationInput, NotificationUncheckedCreateWithoutClientNotificationInput> | NotificationCreateWithoutClientNotificationInput[] | NotificationUncheckedCreateWithoutClientNotificationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientNotificationInput | NotificationCreateOrConnectWithoutClientNotificationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutClientNotificationInput | NotificationUpsertWithWhereUniqueWithoutClientNotificationInput[]
    createMany?: NotificationCreateManyClientNotificationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutClientNotificationInput | NotificationUpdateWithWhereUniqueWithoutClientNotificationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutClientNotificationInput | NotificationUpdateManyWithWhereWithoutClientNotificationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCouponUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput> | UserCouponCreateWithoutUserInput[] | UserCouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutUserInput | UserCouponCreateOrConnectWithoutUserInput[]
    upsert?: UserCouponUpsertWithWhereUniqueWithoutUserInput | UserCouponUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCouponCreateManyUserInputEnvelope
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    update?: UserCouponUpdateWithWhereUniqueWithoutUserInput | UserCouponUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCouponUpdateManyWithWhereWithoutUserInput | UserCouponUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
  }

  export type ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientDestinataireCreateWithoutClientInput, ClientDestinataireUncheckedCreateWithoutClientInput> | ClientDestinataireCreateWithoutClientInput[] | ClientDestinataireUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientDestinataireCreateOrConnectWithoutClientInput | ClientDestinataireCreateOrConnectWithoutClientInput[]
    upsert?: ClientDestinataireUpsertWithWhereUniqueWithoutClientInput | ClientDestinataireUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientDestinataireCreateManyClientInputEnvelope
    set?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    disconnect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    delete?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    connect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    update?: ClientDestinataireUpdateWithWhereUniqueWithoutClientInput | ClientDestinataireUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientDestinataireUpdateManyWithWhereWithoutClientInput | ClientDestinataireUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientDestinataireScalarWhereInput | ClientDestinataireScalarWhereInput[]
  }

  export type ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput = {
    create?: XOR<ClientDestinataireCreateWithoutDestinataireInput, ClientDestinataireUncheckedCreateWithoutDestinataireInput> | ClientDestinataireCreateWithoutDestinataireInput[] | ClientDestinataireUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: ClientDestinataireCreateOrConnectWithoutDestinataireInput | ClientDestinataireCreateOrConnectWithoutDestinataireInput[]
    upsert?: ClientDestinataireUpsertWithWhereUniqueWithoutDestinataireInput | ClientDestinataireUpsertWithWhereUniqueWithoutDestinataireInput[]
    createMany?: ClientDestinataireCreateManyDestinataireInputEnvelope
    set?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    disconnect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    delete?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    connect?: ClientDestinataireWhereUniqueInput | ClientDestinataireWhereUniqueInput[]
    update?: ClientDestinataireUpdateWithWhereUniqueWithoutDestinataireInput | ClientDestinataireUpdateWithWhereUniqueWithoutDestinataireInput[]
    updateMany?: ClientDestinataireUpdateManyWithWhereWithoutDestinataireInput | ClientDestinataireUpdateManyWithWhereWithoutDestinataireInput[]
    deleteMany?: ClientDestinataireScalarWhereInput | ClientDestinataireScalarWhereInput[]
  }

  export type AgencyClientsUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AgencyClientsCreateWithoutClientInput, AgencyClientsUncheckedCreateWithoutClientInput> | AgencyClientsCreateWithoutClientInput[] | AgencyClientsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyClientsCreateOrConnectWithoutClientInput | AgencyClientsCreateOrConnectWithoutClientInput[]
    upsert?: AgencyClientsUpsertWithWhereUniqueWithoutClientInput | AgencyClientsUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AgencyClientsCreateManyClientInputEnvelope
    set?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    disconnect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    delete?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    connect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    update?: AgencyClientsUpdateWithWhereUniqueWithoutClientInput | AgencyClientsUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AgencyClientsUpdateManyWithWhereWithoutClientInput | AgencyClientsUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AgencyClientsScalarWhereInput | AgencyClientsScalarWhereInput[]
  }

  export type AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AgencyStaffCreateWithoutStaffInput, AgencyStaffUncheckedCreateWithoutStaffInput> | AgencyStaffCreateWithoutStaffInput[] | AgencyStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AgencyStaffCreateOrConnectWithoutStaffInput | AgencyStaffCreateOrConnectWithoutStaffInput[]
    upsert?: AgencyStaffUpsertWithWhereUniqueWithoutStaffInput | AgencyStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AgencyStaffCreateManyStaffInputEnvelope
    set?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    disconnect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    delete?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    connect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    update?: AgencyStaffUpdateWithWhereUniqueWithoutStaffInput | AgencyStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AgencyStaffUpdateManyWithWhereWithoutStaffInput | AgencyStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AgencyStaffScalarWhereInput | AgencyStaffScalarWhereInput[]
  }

  export type UserAddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutUserInput | UserAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutUserInput | UserAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutUserInput | UserAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type AgencyUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AgencyCreateWithoutCreatedByInput, AgencyUncheckedCreateWithoutCreatedByInput> | AgencyCreateWithoutCreatedByInput[] | AgencyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyCreateOrConnectWithoutCreatedByInput | AgencyCreateOrConnectWithoutCreatedByInput[]
    upsert?: AgencyUpsertWithWhereUniqueWithoutCreatedByInput | AgencyUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AgencyCreateManyCreatedByInputEnvelope
    set?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    disconnect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    delete?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    connect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    update?: AgencyUpdateWithWhereUniqueWithoutCreatedByInput | AgencyUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AgencyUpdateManyWithWhereWithoutCreatedByInput | AgencyUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AgencyScalarWhereInput | AgencyScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ActivityLogCreateWithoutStaffInput, ActivityLogUncheckedCreateWithoutStaffInput> | ActivityLogCreateWithoutStaffInput[] | ActivityLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutStaffInput | ActivityLogCreateOrConnectWithoutStaffInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutStaffInput | ActivityLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ActivityLogCreateManyStaffInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutStaffInput | ActivityLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutStaffInput | ActivityLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutClientAgenciesInput = {
    create?: XOR<UserCreateWithoutClientAgenciesInput, UserUncheckedCreateWithoutClientAgenciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientAgenciesInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutAgencyClientsInput = {
    create?: XOR<AgencyCreateWithoutAgencyClientsInput, AgencyUncheckedCreateWithoutAgencyClientsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyClientsInput
    connect?: AgencyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutClientAgenciesNestedInput = {
    create?: XOR<UserCreateWithoutClientAgenciesInput, UserUncheckedCreateWithoutClientAgenciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientAgenciesInput
    upsert?: UserUpsertWithoutClientAgenciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientAgenciesInput, UserUpdateWithoutClientAgenciesInput>, UserUncheckedUpdateWithoutClientAgenciesInput>
  }

  export type AgencyUpdateOneRequiredWithoutAgencyClientsNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyClientsInput, AgencyUncheckedCreateWithoutAgencyClientsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyClientsInput
    upsert?: AgencyUpsertWithoutAgencyClientsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyClientsInput, AgencyUpdateWithoutAgencyClientsInput>, AgencyUncheckedUpdateWithoutAgencyClientsInput>
  }

  export type UserCreateNestedOneWithoutAgencyStaffsInput = {
    create?: XOR<UserCreateWithoutAgencyStaffsInput, UserUncheckedCreateWithoutAgencyStaffsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyStaffsInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutAgencyStaffInput = {
    create?: XOR<AgencyCreateWithoutAgencyStaffInput, AgencyUncheckedCreateWithoutAgencyStaffInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyStaffInput
    connect?: AgencyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAgencyStaffsNestedInput = {
    create?: XOR<UserCreateWithoutAgencyStaffsInput, UserUncheckedCreateWithoutAgencyStaffsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyStaffsInput
    upsert?: UserUpsertWithoutAgencyStaffsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgencyStaffsInput, UserUpdateWithoutAgencyStaffsInput>, UserUncheckedUpdateWithoutAgencyStaffsInput>
  }

  export type AgencyUpdateOneRequiredWithoutAgencyStaffNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyStaffInput, AgencyUncheckedCreateWithoutAgencyStaffInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyStaffInput
    upsert?: AgencyUpsertWithoutAgencyStaffInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyStaffInput, AgencyUpdateWithoutAgencyStaffInput>, AgencyUncheckedUpdateWithoutAgencyStaffInput>
  }

  export type UserCreateNestedOneWithoutStaffsActivityLogsInput = {
    create?: XOR<UserCreateWithoutStaffsActivityLogsInput, UserUncheckedCreateWithoutStaffsActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffsActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<AgencyCreateWithoutActivityLogsInput, AgencyUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutActivityLogsInput
    connect?: AgencyWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type UserUpdateOneWithoutStaffsActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutStaffsActivityLogsInput, UserUncheckedCreateWithoutStaffsActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffsActivityLogsInput
    upsert?: UserUpsertWithoutStaffsActivityLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffsActivityLogsInput, UserUpdateWithoutStaffsActivityLogsInput>, UserUncheckedUpdateWithoutStaffsActivityLogsInput>
  }

  export type AgencyUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<AgencyCreateWithoutActivityLogsInput, AgencyUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutActivityLogsInput
    upsert?: AgencyUpsertWithoutActivityLogsInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutActivityLogsInput, AgencyUpdateWithoutActivityLogsInput>, AgencyUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserCreateNestedOneWithoutAuthenticatorInput = {
    create?: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthenticatorInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthenticatorNestedInput = {
    create?: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthenticatorInput
    upsert?: UserUpsertWithoutAuthenticatorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthenticatorInput, UserUpdateWithoutAuthenticatorInput>, UserUncheckedUpdateWithoutAuthenticatorInput>
  }

  export type AgencyCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AgencyCreateWithoutNotificationsInput, AgencyUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutNotificationsInput
    connect?: AgencyWhereUniqueInput
  }

  export type EnvoiCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<EnvoiCreateWithoutNotificationsInput, EnvoiUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutNotificationsInput
    connect?: EnvoiWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsAsDestinataireInput = {
    create?: XOR<UserCreateWithoutNotificationsAsDestinataireInput, UserUncheckedCreateWithoutNotificationsAsDestinataireInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsAsDestinataireInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationAsClientInput = {
    create?: XOR<UserCreateWithoutNotificationAsClientInput, UserUncheckedCreateWithoutNotificationAsClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationAsClientInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<AgencyCreateWithoutNotificationsInput, AgencyUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutNotificationsInput
    upsert?: AgencyUpsertWithoutNotificationsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutNotificationsInput, AgencyUpdateWithoutNotificationsInput>, AgencyUncheckedUpdateWithoutNotificationsInput>
  }

  export type EnvoiUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<EnvoiCreateWithoutNotificationsInput, EnvoiUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutNotificationsInput
    upsert?: EnvoiUpsertWithoutNotificationsInput
    connect?: EnvoiWhereUniqueInput
    update?: XOR<XOR<EnvoiUpdateToOneWithWhereWithoutNotificationsInput, EnvoiUpdateWithoutNotificationsInput>, EnvoiUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneWithoutNotificationsAsDestinataireNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsAsDestinataireInput, UserUncheckedCreateWithoutNotificationsAsDestinataireInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsAsDestinataireInput
    upsert?: UserUpsertWithoutNotificationsAsDestinataireInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsAsDestinataireInput, UserUpdateWithoutNotificationsAsDestinataireInput>, UserUncheckedUpdateWithoutNotificationsAsDestinataireInput>
  }

  export type UserUpdateOneWithoutNotificationAsClientNestedInput = {
    create?: XOR<UserCreateWithoutNotificationAsClientInput, UserUncheckedCreateWithoutNotificationAsClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationAsClientInput
    upsert?: UserUpsertWithoutNotificationAsClientInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationAsClientInput, UserUpdateWithoutNotificationAsClientInput>, UserUncheckedUpdateWithoutNotificationAsClientInput>
  }

  export type CountryCreateNestedOneWithoutVatRatesInput = {
    create?: XOR<CountryCreateWithoutVatRatesInput, CountryUncheckedCreateWithoutVatRatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutVatRatesInput
    connect?: CountryWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumVatTypeFieldUpdateOperationsInput = {
    set?: $Enums.VatType | null
  }

  export type CountryUpdateOneRequiredWithoutVatRatesNestedInput = {
    create?: XOR<CountryCreateWithoutVatRatesInput, CountryUncheckedCreateWithoutVatRatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutVatRatesInput
    upsert?: CountryUpsertWithoutVatRatesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutVatRatesInput, CountryUpdateWithoutVatRatesInput>, CountryUncheckedUpdateWithoutVatRatesInput>
  }

  export type CountryCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    connect?: CountryWhereUniqueInput
  }

  export type AddressCreateNestedManyWithoutCityInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    upsert?: CountryUpsertWithoutCitiesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCitiesInput, CountryUpdateWithoutCitiesInput>, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type AddressUpdateManyWithoutCityNestedInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCityInput | AddressUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCityInput | AddressUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCityInput | AddressUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCityInput | AddressUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCityInput | AddressUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCityInput | AddressUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type CityCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type TimezoneCreateNestedManyWithoutCountryInput = {
    create?: XOR<TimezoneCreateWithoutCountryInput, TimezoneUncheckedCreateWithoutCountryInput> | TimezoneCreateWithoutCountryInput[] | TimezoneUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: TimezoneCreateOrConnectWithoutCountryInput | TimezoneCreateOrConnectWithoutCountryInput[]
    createMany?: TimezoneCreateManyCountryInputEnvelope
    connect?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
  }

  export type VatRateCreateNestedManyWithoutCountryInput = {
    create?: XOR<VatRateCreateWithoutCountryInput, VatRateUncheckedCreateWithoutCountryInput> | VatRateCreateWithoutCountryInput[] | VatRateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: VatRateCreateOrConnectWithoutCountryInput | VatRateCreateOrConnectWithoutCountryInput[]
    createMany?: VatRateCreateManyCountryInputEnvelope
    connect?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type TimezoneUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<TimezoneCreateWithoutCountryInput, TimezoneUncheckedCreateWithoutCountryInput> | TimezoneCreateWithoutCountryInput[] | TimezoneUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: TimezoneCreateOrConnectWithoutCountryInput | TimezoneCreateOrConnectWithoutCountryInput[]
    createMany?: TimezoneCreateManyCountryInputEnvelope
    connect?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
  }

  export type VatRateUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<VatRateCreateWithoutCountryInput, VatRateUncheckedCreateWithoutCountryInput> | VatRateCreateWithoutCountryInput[] | VatRateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: VatRateCreateOrConnectWithoutCountryInput | VatRateCreateOrConnectWithoutCountryInput[]
    createMany?: VatRateCreateManyCountryInputEnvelope
    connect?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
  }

  export type CityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type TimezoneUpdateManyWithoutCountryNestedInput = {
    create?: XOR<TimezoneCreateWithoutCountryInput, TimezoneUncheckedCreateWithoutCountryInput> | TimezoneCreateWithoutCountryInput[] | TimezoneUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: TimezoneCreateOrConnectWithoutCountryInput | TimezoneCreateOrConnectWithoutCountryInput[]
    upsert?: TimezoneUpsertWithWhereUniqueWithoutCountryInput | TimezoneUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: TimezoneCreateManyCountryInputEnvelope
    set?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
    disconnect?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
    delete?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
    connect?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
    update?: TimezoneUpdateWithWhereUniqueWithoutCountryInput | TimezoneUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: TimezoneUpdateManyWithWhereWithoutCountryInput | TimezoneUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: TimezoneScalarWhereInput | TimezoneScalarWhereInput[]
  }

  export type VatRateUpdateManyWithoutCountryNestedInput = {
    create?: XOR<VatRateCreateWithoutCountryInput, VatRateUncheckedCreateWithoutCountryInput> | VatRateCreateWithoutCountryInput[] | VatRateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: VatRateCreateOrConnectWithoutCountryInput | VatRateCreateOrConnectWithoutCountryInput[]
    upsert?: VatRateUpsertWithWhereUniqueWithoutCountryInput | VatRateUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: VatRateCreateManyCountryInputEnvelope
    set?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
    disconnect?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
    delete?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
    connect?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
    update?: VatRateUpdateWithWhereUniqueWithoutCountryInput | VatRateUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: VatRateUpdateManyWithWhereWithoutCountryInput | VatRateUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: VatRateScalarWhereInput | VatRateScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type TimezoneUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<TimezoneCreateWithoutCountryInput, TimezoneUncheckedCreateWithoutCountryInput> | TimezoneCreateWithoutCountryInput[] | TimezoneUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: TimezoneCreateOrConnectWithoutCountryInput | TimezoneCreateOrConnectWithoutCountryInput[]
    upsert?: TimezoneUpsertWithWhereUniqueWithoutCountryInput | TimezoneUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: TimezoneCreateManyCountryInputEnvelope
    set?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
    disconnect?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
    delete?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
    connect?: TimezoneWhereUniqueInput | TimezoneWhereUniqueInput[]
    update?: TimezoneUpdateWithWhereUniqueWithoutCountryInput | TimezoneUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: TimezoneUpdateManyWithWhereWithoutCountryInput | TimezoneUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: TimezoneScalarWhereInput | TimezoneScalarWhereInput[]
  }

  export type VatRateUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<VatRateCreateWithoutCountryInput, VatRateUncheckedCreateWithoutCountryInput> | VatRateCreateWithoutCountryInput[] | VatRateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: VatRateCreateOrConnectWithoutCountryInput | VatRateCreateOrConnectWithoutCountryInput[]
    upsert?: VatRateUpsertWithWhereUniqueWithoutCountryInput | VatRateUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: VatRateCreateManyCountryInputEnvelope
    set?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
    disconnect?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
    delete?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
    connect?: VatRateWhereUniqueInput | VatRateWhereUniqueInput[]
    update?: VatRateUpdateWithWhereUniqueWithoutCountryInput | VatRateUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: VatRateUpdateManyWithWhereWithoutCountryInput | VatRateUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: VatRateScalarWhereInput | VatRateScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutTimezonesInput = {
    create?: XOR<CountryCreateWithoutTimezonesInput, CountryUncheckedCreateWithoutTimezonesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutTimezonesInput
    connect?: CountryWhereUniqueInput
  }

  export type CountryUpdateOneRequiredWithoutTimezonesNestedInput = {
    create?: XOR<CountryCreateWithoutTimezonesInput, CountryUncheckedCreateWithoutTimezonesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutTimezonesInput
    upsert?: CountryUpsertWithoutTimezonesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutTimezonesInput, CountryUpdateWithoutTimezonesInput>, CountryUncheckedUpdateWithoutTimezonesInput>
  }

  export type AddressCreateNestedOneWithoutUserAddressesInput = {
    create?: XOR<AddressCreateWithoutUserAddressesInput, AddressUncheckedCreateWithoutUserAddressesInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserAddressesInput
    connect?: AddressWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserAddressesInput = {
    create?: XOR<UserCreateWithoutUserAddressesInput, UserUncheckedCreateWithoutUserAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAddressTypeFieldUpdateOperationsInput = {
    set?: $Enums.AddressType
  }

  export type AddressUpdateOneRequiredWithoutUserAddressesNestedInput = {
    create?: XOR<AddressCreateWithoutUserAddressesInput, AddressUncheckedCreateWithoutUserAddressesInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserAddressesInput
    upsert?: AddressUpsertWithoutUserAddressesInput
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutUserAddressesInput, AddressUpdateWithoutUserAddressesInput>, AddressUncheckedUpdateWithoutUserAddressesInput>
  }

  export type UserUpdateOneRequiredWithoutUserAddressesNestedInput = {
    create?: XOR<UserCreateWithoutUserAddressesInput, UserUncheckedCreateWithoutUserAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAddressesInput
    upsert?: UserUpsertWithoutUserAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserAddressesInput, UserUpdateWithoutUserAddressesInput>, UserUncheckedUpdateWithoutUserAddressesInput>
  }

  export type CityCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressesInput
    connect?: CityWhereUniqueInput
  }

  export type UserAddressCreateNestedManyWithoutAddressInput = {
    create?: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput> | UserAddressCreateWithoutAddressInput[] | UserAddressUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutAddressInput | UserAddressCreateOrConnectWithoutAddressInput[]
    createMany?: UserAddressCreateManyAddressInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type AgencyCreateNestedOneWithoutAddressInput = {
    create?: XOR<AgencyCreateWithoutAddressInput, AgencyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddressInput
    connect?: AgencyWhereUniqueInput
  }

  export type UserAddressUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput> | UserAddressCreateWithoutAddressInput[] | UserAddressUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutAddressInput | UserAddressCreateOrConnectWithoutAddressInput[]
    createMany?: UserAddressCreateManyAddressInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type AgencyUncheckedCreateNestedOneWithoutAddressInput = {
    create?: XOR<AgencyCreateWithoutAddressInput, AgencyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddressInput
    connect?: AgencyWhereUniqueInput
  }

  export type CityUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressesInput
    upsert?: CityUpsertWithoutAddressesInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutAddressesInput, CityUpdateWithoutAddressesInput>, CityUncheckedUpdateWithoutAddressesInput>
  }

  export type UserAddressUpdateManyWithoutAddressNestedInput = {
    create?: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput> | UserAddressCreateWithoutAddressInput[] | UserAddressUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutAddressInput | UserAddressCreateOrConnectWithoutAddressInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutAddressInput | UserAddressUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: UserAddressCreateManyAddressInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutAddressInput | UserAddressUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutAddressInput | UserAddressUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type AgencyUpdateOneWithoutAddressNestedInput = {
    create?: XOR<AgencyCreateWithoutAddressInput, AgencyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddressInput
    upsert?: AgencyUpsertWithoutAddressInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAddressInput, AgencyUpdateWithoutAddressInput>, AgencyUncheckedUpdateWithoutAddressInput>
  }

  export type UserAddressUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput> | UserAddressCreateWithoutAddressInput[] | UserAddressUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutAddressInput | UserAddressCreateOrConnectWithoutAddressInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutAddressInput | UserAddressUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: UserAddressCreateManyAddressInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutAddressInput | UserAddressUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutAddressInput | UserAddressUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type AgencyUncheckedUpdateOneWithoutAddressNestedInput = {
    create?: XOR<AgencyCreateWithoutAddressInput, AgencyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddressInput
    upsert?: AgencyUpsertWithoutAddressInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAddressInput, AgencyUpdateWithoutAddressInput>, AgencyUncheckedUpdateWithoutAddressInput>
  }

  export type UserCreateNestedOneWithoutCreatedAgenciesInput = {
    create?: XOR<UserCreateWithoutCreatedAgenciesInput, UserUncheckedCreateWithoutCreatedAgenciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAgenciesInput
    connect?: UserWhereUniqueInput
  }

  export type EnvoiCreateNestedManyWithoutArrivalAgencyInput = {
    create?: XOR<EnvoiCreateWithoutArrivalAgencyInput, EnvoiUncheckedCreateWithoutArrivalAgencyInput> | EnvoiCreateWithoutArrivalAgencyInput[] | EnvoiUncheckedCreateWithoutArrivalAgencyInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutArrivalAgencyInput | EnvoiCreateOrConnectWithoutArrivalAgencyInput[]
    createMany?: EnvoiCreateManyArrivalAgencyInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type EnvoiCreateNestedManyWithoutDepartureAgencyInput = {
    create?: XOR<EnvoiCreateWithoutDepartureAgencyInput, EnvoiUncheckedCreateWithoutDepartureAgencyInput> | EnvoiCreateWithoutDepartureAgencyInput[] | EnvoiUncheckedCreateWithoutDepartureAgencyInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutDepartureAgencyInput | EnvoiCreateOrConnectWithoutDepartureAgencyInput[]
    createMany?: EnvoiCreateManyDepartureAgencyInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutAgencyInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AppointmentCreateWithoutAgencyInput, AppointmentUncheckedCreateWithoutAgencyInput> | AppointmentCreateWithoutAgencyInput[] | AppointmentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAgencyInput | AppointmentCreateOrConnectWithoutAgencyInput[]
    createMany?: AppointmentCreateManyAgencyInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type TransportCreateNestedManyWithoutAgencyInput = {
    create?: XOR<TransportCreateWithoutAgencyInput, TransportUncheckedCreateWithoutAgencyInput> | TransportCreateWithoutAgencyInput[] | TransportUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutAgencyInput | TransportCreateOrConnectWithoutAgencyInput[]
    createMany?: TransportCreateManyAgencyInputEnvelope
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
  }

  export type TarifsCreateNestedManyWithoutAgencyInput = {
    create?: XOR<TarifsCreateWithoutAgencyInput, TarifsUncheckedCreateWithoutAgencyInput> | TarifsCreateWithoutAgencyInput[] | TarifsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: TarifsCreateOrConnectWithoutAgencyInput | TarifsCreateOrConnectWithoutAgencyInput[]
    createMany?: TarifsCreateManyAgencyInputEnvelope
    connect?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
  }

  export type AddressCreateNestedOneWithoutAgencyInput = {
    create?: XOR<AddressCreateWithoutAgencyInput, AddressUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutAgencyInput
    connect?: AddressWhereUniqueInput
  }

  export type AgencyClientsCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyClientsCreateWithoutAgencyInput, AgencyClientsUncheckedCreateWithoutAgencyInput> | AgencyClientsCreateWithoutAgencyInput[] | AgencyClientsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyClientsCreateOrConnectWithoutAgencyInput | AgencyClientsCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyClientsCreateManyAgencyInputEnvelope
    connect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
  }

  export type AgencyStaffCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyStaffCreateWithoutAgencyInput, AgencyStaffUncheckedCreateWithoutAgencyInput> | AgencyStaffCreateWithoutAgencyInput[] | AgencyStaffUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyStaffCreateOrConnectWithoutAgencyInput | AgencyStaffCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyStaffCreateManyAgencyInputEnvelope
    connect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutAgencyInput = {
    create?: XOR<ActivityLogCreateWithoutAgencyInput, ActivityLogUncheckedCreateWithoutAgencyInput> | ActivityLogCreateWithoutAgencyInput[] | ActivityLogUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAgencyInput | ActivityLogCreateOrConnectWithoutAgencyInput[]
    createMany?: ActivityLogCreateManyAgencyInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput = {
    create?: XOR<EnvoiCreateWithoutArrivalAgencyInput, EnvoiUncheckedCreateWithoutArrivalAgencyInput> | EnvoiCreateWithoutArrivalAgencyInput[] | EnvoiUncheckedCreateWithoutArrivalAgencyInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutArrivalAgencyInput | EnvoiCreateOrConnectWithoutArrivalAgencyInput[]
    createMany?: EnvoiCreateManyArrivalAgencyInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput = {
    create?: XOR<EnvoiCreateWithoutDepartureAgencyInput, EnvoiUncheckedCreateWithoutDepartureAgencyInput> | EnvoiCreateWithoutDepartureAgencyInput[] | EnvoiUncheckedCreateWithoutDepartureAgencyInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutDepartureAgencyInput | EnvoiCreateOrConnectWithoutDepartureAgencyInput[]
    createMany?: EnvoiCreateManyDepartureAgencyInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AppointmentCreateWithoutAgencyInput, AppointmentUncheckedCreateWithoutAgencyInput> | AppointmentCreateWithoutAgencyInput[] | AppointmentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAgencyInput | AppointmentCreateOrConnectWithoutAgencyInput[]
    createMany?: AppointmentCreateManyAgencyInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type TransportUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<TransportCreateWithoutAgencyInput, TransportUncheckedCreateWithoutAgencyInput> | TransportCreateWithoutAgencyInput[] | TransportUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutAgencyInput | TransportCreateOrConnectWithoutAgencyInput[]
    createMany?: TransportCreateManyAgencyInputEnvelope
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
  }

  export type TarifsUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<TarifsCreateWithoutAgencyInput, TarifsUncheckedCreateWithoutAgencyInput> | TarifsCreateWithoutAgencyInput[] | TarifsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: TarifsCreateOrConnectWithoutAgencyInput | TarifsCreateOrConnectWithoutAgencyInput[]
    createMany?: TarifsCreateManyAgencyInputEnvelope
    connect?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
  }

  export type AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyClientsCreateWithoutAgencyInput, AgencyClientsUncheckedCreateWithoutAgencyInput> | AgencyClientsCreateWithoutAgencyInput[] | AgencyClientsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyClientsCreateOrConnectWithoutAgencyInput | AgencyClientsCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyClientsCreateManyAgencyInputEnvelope
    connect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
  }

  export type AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyStaffCreateWithoutAgencyInput, AgencyStaffUncheckedCreateWithoutAgencyInput> | AgencyStaffCreateWithoutAgencyInput[] | AgencyStaffUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyStaffCreateOrConnectWithoutAgencyInput | AgencyStaffCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyStaffCreateManyAgencyInputEnvelope
    connect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<ActivityLogCreateWithoutAgencyInput, ActivityLogUncheckedCreateWithoutAgencyInput> | ActivityLogCreateWithoutAgencyInput[] | ActivityLogUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAgencyInput | ActivityLogCreateOrConnectWithoutAgencyInput[]
    createMany?: ActivityLogCreateManyAgencyInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreatedAgenciesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAgenciesInput, UserUncheckedCreateWithoutCreatedAgenciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAgenciesInput
    upsert?: UserUpsertWithoutCreatedAgenciesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAgenciesInput, UserUpdateWithoutCreatedAgenciesInput>, UserUncheckedUpdateWithoutCreatedAgenciesInput>
  }

  export type EnvoiUpdateManyWithoutArrivalAgencyNestedInput = {
    create?: XOR<EnvoiCreateWithoutArrivalAgencyInput, EnvoiUncheckedCreateWithoutArrivalAgencyInput> | EnvoiCreateWithoutArrivalAgencyInput[] | EnvoiUncheckedCreateWithoutArrivalAgencyInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutArrivalAgencyInput | EnvoiCreateOrConnectWithoutArrivalAgencyInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutArrivalAgencyInput | EnvoiUpsertWithWhereUniqueWithoutArrivalAgencyInput[]
    createMany?: EnvoiCreateManyArrivalAgencyInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutArrivalAgencyInput | EnvoiUpdateWithWhereUniqueWithoutArrivalAgencyInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutArrivalAgencyInput | EnvoiUpdateManyWithWhereWithoutArrivalAgencyInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type EnvoiUpdateManyWithoutDepartureAgencyNestedInput = {
    create?: XOR<EnvoiCreateWithoutDepartureAgencyInput, EnvoiUncheckedCreateWithoutDepartureAgencyInput> | EnvoiCreateWithoutDepartureAgencyInput[] | EnvoiUncheckedCreateWithoutDepartureAgencyInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutDepartureAgencyInput | EnvoiCreateOrConnectWithoutDepartureAgencyInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutDepartureAgencyInput | EnvoiUpsertWithWhereUniqueWithoutDepartureAgencyInput[]
    createMany?: EnvoiCreateManyDepartureAgencyInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutDepartureAgencyInput | EnvoiUpdateWithWhereUniqueWithoutDepartureAgencyInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutDepartureAgencyInput | EnvoiUpdateManyWithWhereWithoutDepartureAgencyInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAgencyInput | NotificationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAgencyInput | NotificationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAgencyInput | NotificationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AppointmentCreateWithoutAgencyInput, AppointmentUncheckedCreateWithoutAgencyInput> | AppointmentCreateWithoutAgencyInput[] | AppointmentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAgencyInput | AppointmentCreateOrConnectWithoutAgencyInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAgencyInput | AppointmentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AppointmentCreateManyAgencyInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAgencyInput | AppointmentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAgencyInput | AppointmentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type TransportUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<TransportCreateWithoutAgencyInput, TransportUncheckedCreateWithoutAgencyInput> | TransportCreateWithoutAgencyInput[] | TransportUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutAgencyInput | TransportCreateOrConnectWithoutAgencyInput[]
    upsert?: TransportUpsertWithWhereUniqueWithoutAgencyInput | TransportUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: TransportCreateManyAgencyInputEnvelope
    set?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    disconnect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    delete?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    update?: TransportUpdateWithWhereUniqueWithoutAgencyInput | TransportUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: TransportUpdateManyWithWhereWithoutAgencyInput | TransportUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: TransportScalarWhereInput | TransportScalarWhereInput[]
  }

  export type TarifsUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<TarifsCreateWithoutAgencyInput, TarifsUncheckedCreateWithoutAgencyInput> | TarifsCreateWithoutAgencyInput[] | TarifsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: TarifsCreateOrConnectWithoutAgencyInput | TarifsCreateOrConnectWithoutAgencyInput[]
    upsert?: TarifsUpsertWithWhereUniqueWithoutAgencyInput | TarifsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: TarifsCreateManyAgencyInputEnvelope
    set?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
    disconnect?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
    delete?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
    connect?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
    update?: TarifsUpdateWithWhereUniqueWithoutAgencyInput | TarifsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: TarifsUpdateManyWithWhereWithoutAgencyInput | TarifsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: TarifsScalarWhereInput | TarifsScalarWhereInput[]
  }

  export type AddressUpdateOneRequiredWithoutAgencyNestedInput = {
    create?: XOR<AddressCreateWithoutAgencyInput, AddressUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutAgencyInput
    upsert?: AddressUpsertWithoutAgencyInput
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutAgencyInput, AddressUpdateWithoutAgencyInput>, AddressUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyClientsUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyClientsCreateWithoutAgencyInput, AgencyClientsUncheckedCreateWithoutAgencyInput> | AgencyClientsCreateWithoutAgencyInput[] | AgencyClientsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyClientsCreateOrConnectWithoutAgencyInput | AgencyClientsCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyClientsUpsertWithWhereUniqueWithoutAgencyInput | AgencyClientsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyClientsCreateManyAgencyInputEnvelope
    set?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    disconnect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    delete?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    connect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    update?: AgencyClientsUpdateWithWhereUniqueWithoutAgencyInput | AgencyClientsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyClientsUpdateManyWithWhereWithoutAgencyInput | AgencyClientsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyClientsScalarWhereInput | AgencyClientsScalarWhereInput[]
  }

  export type AgencyStaffUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyStaffCreateWithoutAgencyInput, AgencyStaffUncheckedCreateWithoutAgencyInput> | AgencyStaffCreateWithoutAgencyInput[] | AgencyStaffUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyStaffCreateOrConnectWithoutAgencyInput | AgencyStaffCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyStaffUpsertWithWhereUniqueWithoutAgencyInput | AgencyStaffUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyStaffCreateManyAgencyInputEnvelope
    set?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    disconnect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    delete?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    connect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    update?: AgencyStaffUpdateWithWhereUniqueWithoutAgencyInput | AgencyStaffUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyStaffUpdateManyWithWhereWithoutAgencyInput | AgencyStaffUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyStaffScalarWhereInput | AgencyStaffScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAgencyInput, ActivityLogUncheckedCreateWithoutAgencyInput> | ActivityLogCreateWithoutAgencyInput[] | ActivityLogUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAgencyInput | ActivityLogCreateOrConnectWithoutAgencyInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAgencyInput | ActivityLogUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: ActivityLogCreateManyAgencyInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAgencyInput | ActivityLogUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAgencyInput | ActivityLogUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput = {
    create?: XOR<EnvoiCreateWithoutArrivalAgencyInput, EnvoiUncheckedCreateWithoutArrivalAgencyInput> | EnvoiCreateWithoutArrivalAgencyInput[] | EnvoiUncheckedCreateWithoutArrivalAgencyInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutArrivalAgencyInput | EnvoiCreateOrConnectWithoutArrivalAgencyInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutArrivalAgencyInput | EnvoiUpsertWithWhereUniqueWithoutArrivalAgencyInput[]
    createMany?: EnvoiCreateManyArrivalAgencyInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutArrivalAgencyInput | EnvoiUpdateWithWhereUniqueWithoutArrivalAgencyInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutArrivalAgencyInput | EnvoiUpdateManyWithWhereWithoutArrivalAgencyInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput = {
    create?: XOR<EnvoiCreateWithoutDepartureAgencyInput, EnvoiUncheckedCreateWithoutDepartureAgencyInput> | EnvoiCreateWithoutDepartureAgencyInput[] | EnvoiUncheckedCreateWithoutDepartureAgencyInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutDepartureAgencyInput | EnvoiCreateOrConnectWithoutDepartureAgencyInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutDepartureAgencyInput | EnvoiUpsertWithWhereUniqueWithoutDepartureAgencyInput[]
    createMany?: EnvoiCreateManyDepartureAgencyInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutDepartureAgencyInput | EnvoiUpdateWithWhereUniqueWithoutDepartureAgencyInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutDepartureAgencyInput | EnvoiUpdateManyWithWhereWithoutDepartureAgencyInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAgencyInput | NotificationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAgencyInput | NotificationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAgencyInput | NotificationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AppointmentCreateWithoutAgencyInput, AppointmentUncheckedCreateWithoutAgencyInput> | AppointmentCreateWithoutAgencyInput[] | AppointmentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAgencyInput | AppointmentCreateOrConnectWithoutAgencyInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAgencyInput | AppointmentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AppointmentCreateManyAgencyInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAgencyInput | AppointmentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAgencyInput | AppointmentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type TransportUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<TransportCreateWithoutAgencyInput, TransportUncheckedCreateWithoutAgencyInput> | TransportCreateWithoutAgencyInput[] | TransportUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutAgencyInput | TransportCreateOrConnectWithoutAgencyInput[]
    upsert?: TransportUpsertWithWhereUniqueWithoutAgencyInput | TransportUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: TransportCreateManyAgencyInputEnvelope
    set?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    disconnect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    delete?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    update?: TransportUpdateWithWhereUniqueWithoutAgencyInput | TransportUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: TransportUpdateManyWithWhereWithoutAgencyInput | TransportUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: TransportScalarWhereInput | TransportScalarWhereInput[]
  }

  export type TarifsUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<TarifsCreateWithoutAgencyInput, TarifsUncheckedCreateWithoutAgencyInput> | TarifsCreateWithoutAgencyInput[] | TarifsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: TarifsCreateOrConnectWithoutAgencyInput | TarifsCreateOrConnectWithoutAgencyInput[]
    upsert?: TarifsUpsertWithWhereUniqueWithoutAgencyInput | TarifsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: TarifsCreateManyAgencyInputEnvelope
    set?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
    disconnect?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
    delete?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
    connect?: TarifsWhereUniqueInput | TarifsWhereUniqueInput[]
    update?: TarifsUpdateWithWhereUniqueWithoutAgencyInput | TarifsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: TarifsUpdateManyWithWhereWithoutAgencyInput | TarifsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: TarifsScalarWhereInput | TarifsScalarWhereInput[]
  }

  export type AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyClientsCreateWithoutAgencyInput, AgencyClientsUncheckedCreateWithoutAgencyInput> | AgencyClientsCreateWithoutAgencyInput[] | AgencyClientsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyClientsCreateOrConnectWithoutAgencyInput | AgencyClientsCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyClientsUpsertWithWhereUniqueWithoutAgencyInput | AgencyClientsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyClientsCreateManyAgencyInputEnvelope
    set?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    disconnect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    delete?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    connect?: AgencyClientsWhereUniqueInput | AgencyClientsWhereUniqueInput[]
    update?: AgencyClientsUpdateWithWhereUniqueWithoutAgencyInput | AgencyClientsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyClientsUpdateManyWithWhereWithoutAgencyInput | AgencyClientsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyClientsScalarWhereInput | AgencyClientsScalarWhereInput[]
  }

  export type AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyStaffCreateWithoutAgencyInput, AgencyStaffUncheckedCreateWithoutAgencyInput> | AgencyStaffCreateWithoutAgencyInput[] | AgencyStaffUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyStaffCreateOrConnectWithoutAgencyInput | AgencyStaffCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyStaffUpsertWithWhereUniqueWithoutAgencyInput | AgencyStaffUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyStaffCreateManyAgencyInputEnvelope
    set?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    disconnect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    delete?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    connect?: AgencyStaffWhereUniqueInput | AgencyStaffWhereUniqueInput[]
    update?: AgencyStaffUpdateWithWhereUniqueWithoutAgencyInput | AgencyStaffUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyStaffUpdateManyWithWhereWithoutAgencyInput | AgencyStaffUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyStaffScalarWhereInput | AgencyStaffScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAgencyInput, ActivityLogUncheckedCreateWithoutAgencyInput> | ActivityLogCreateWithoutAgencyInput[] | ActivityLogUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAgencyInput | ActivityLogCreateOrConnectWithoutAgencyInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAgencyInput | ActivityLogUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: ActivityLogCreateManyAgencyInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAgencyInput | ActivityLogUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAgencyInput | ActivityLogUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientLinksInput = {
    create?: XOR<UserCreateWithoutClientLinksInput, UserUncheckedCreateWithoutClientLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientLinksInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDestinataireLinksInput = {
    create?: XOR<UserCreateWithoutDestinataireLinksInput, UserUncheckedCreateWithoutDestinataireLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutDestinataireLinksInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutClientLinksNestedInput = {
    create?: XOR<UserCreateWithoutClientLinksInput, UserUncheckedCreateWithoutClientLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientLinksInput
    upsert?: UserUpsertWithoutClientLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientLinksInput, UserUpdateWithoutClientLinksInput>, UserUncheckedUpdateWithoutClientLinksInput>
  }

  export type UserUpdateOneRequiredWithoutDestinataireLinksNestedInput = {
    create?: XOR<UserCreateWithoutDestinataireLinksInput, UserUncheckedCreateWithoutDestinataireLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutDestinataireLinksInput
    upsert?: UserUpsertWithoutDestinataireLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDestinataireLinksInput, UserUpdateWithoutDestinataireLinksInput>, UserUncheckedUpdateWithoutDestinataireLinksInput>
  }

  export type UserCouponCreateNestedManyWithoutCouponInput = {
    create?: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput> | UserCouponCreateWithoutCouponInput[] | UserCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutCouponInput | UserCouponCreateOrConnectWithoutCouponInput[]
    createMany?: UserCouponCreateManyCouponInputEnvelope
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
  }

  export type EnvoiCouponCreateNestedManyWithoutCouponInput = {
    create?: XOR<EnvoiCouponCreateWithoutCouponInput, EnvoiCouponUncheckedCreateWithoutCouponInput> | EnvoiCouponCreateWithoutCouponInput[] | EnvoiCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: EnvoiCouponCreateOrConnectWithoutCouponInput | EnvoiCouponCreateOrConnectWithoutCouponInput[]
    createMany?: EnvoiCouponCreateManyCouponInputEnvelope
    connect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
  }

  export type UserCouponUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput> | UserCouponCreateWithoutCouponInput[] | UserCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutCouponInput | UserCouponCreateOrConnectWithoutCouponInput[]
    createMany?: UserCouponCreateManyCouponInputEnvelope
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
  }

  export type EnvoiCouponUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<EnvoiCouponCreateWithoutCouponInput, EnvoiCouponUncheckedCreateWithoutCouponInput> | EnvoiCouponCreateWithoutCouponInput[] | EnvoiCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: EnvoiCouponCreateOrConnectWithoutCouponInput | EnvoiCouponCreateOrConnectWithoutCouponInput[]
    createMany?: EnvoiCouponCreateManyCouponInputEnvelope
    connect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
  }

  export type UserCouponUpdateManyWithoutCouponNestedInput = {
    create?: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput> | UserCouponCreateWithoutCouponInput[] | UserCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutCouponInput | UserCouponCreateOrConnectWithoutCouponInput[]
    upsert?: UserCouponUpsertWithWhereUniqueWithoutCouponInput | UserCouponUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: UserCouponCreateManyCouponInputEnvelope
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    update?: UserCouponUpdateWithWhereUniqueWithoutCouponInput | UserCouponUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: UserCouponUpdateManyWithWhereWithoutCouponInput | UserCouponUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
  }

  export type EnvoiCouponUpdateManyWithoutCouponNestedInput = {
    create?: XOR<EnvoiCouponCreateWithoutCouponInput, EnvoiCouponUncheckedCreateWithoutCouponInput> | EnvoiCouponCreateWithoutCouponInput[] | EnvoiCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: EnvoiCouponCreateOrConnectWithoutCouponInput | EnvoiCouponCreateOrConnectWithoutCouponInput[]
    upsert?: EnvoiCouponUpsertWithWhereUniqueWithoutCouponInput | EnvoiCouponUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: EnvoiCouponCreateManyCouponInputEnvelope
    set?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    disconnect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    delete?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    connect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    update?: EnvoiCouponUpdateWithWhereUniqueWithoutCouponInput | EnvoiCouponUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: EnvoiCouponUpdateManyWithWhereWithoutCouponInput | EnvoiCouponUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: EnvoiCouponScalarWhereInput | EnvoiCouponScalarWhereInput[]
  }

  export type UserCouponUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput> | UserCouponCreateWithoutCouponInput[] | UserCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutCouponInput | UserCouponCreateOrConnectWithoutCouponInput[]
    upsert?: UserCouponUpsertWithWhereUniqueWithoutCouponInput | UserCouponUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: UserCouponCreateManyCouponInputEnvelope
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    update?: UserCouponUpdateWithWhereUniqueWithoutCouponInput | UserCouponUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: UserCouponUpdateManyWithWhereWithoutCouponInput | UserCouponUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
  }

  export type EnvoiCouponUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<EnvoiCouponCreateWithoutCouponInput, EnvoiCouponUncheckedCreateWithoutCouponInput> | EnvoiCouponCreateWithoutCouponInput[] | EnvoiCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: EnvoiCouponCreateOrConnectWithoutCouponInput | EnvoiCouponCreateOrConnectWithoutCouponInput[]
    upsert?: EnvoiCouponUpsertWithWhereUniqueWithoutCouponInput | EnvoiCouponUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: EnvoiCouponCreateManyCouponInputEnvelope
    set?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    disconnect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    delete?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    connect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    update?: EnvoiCouponUpdateWithWhereUniqueWithoutCouponInput | EnvoiCouponUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: EnvoiCouponUpdateManyWithWhereWithoutCouponInput | EnvoiCouponUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: EnvoiCouponScalarWhereInput | EnvoiCouponScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserCouponsInput = {
    create?: XOR<UserCreateWithoutUserCouponsInput, UserUncheckedCreateWithoutUserCouponsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCouponsInput
    connect?: UserWhereUniqueInput
  }

  export type CouponCreateNestedOneWithoutUserCouponInput = {
    create?: XOR<CouponCreateWithoutUserCouponInput, CouponUncheckedCreateWithoutUserCouponInput>
    connectOrCreate?: CouponCreateOrConnectWithoutUserCouponInput
    connect?: CouponWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserCouponsNestedInput = {
    create?: XOR<UserCreateWithoutUserCouponsInput, UserUncheckedCreateWithoutUserCouponsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCouponsInput
    upsert?: UserUpsertWithoutUserCouponsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserCouponsInput, UserUpdateWithoutUserCouponsInput>, UserUncheckedUpdateWithoutUserCouponsInput>
  }

  export type CouponUpdateOneRequiredWithoutUserCouponNestedInput = {
    create?: XOR<CouponCreateWithoutUserCouponInput, CouponUncheckedCreateWithoutUserCouponInput>
    connectOrCreate?: CouponCreateOrConnectWithoutUserCouponInput
    upsert?: CouponUpsertWithoutUserCouponInput
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutUserCouponInput, CouponUpdateWithoutUserCouponInput>, CouponUncheckedUpdateWithoutUserCouponInput>
  }

  export type EnvoiCreateNestedManyWithoutTransportInput = {
    create?: XOR<EnvoiCreateWithoutTransportInput, EnvoiUncheckedCreateWithoutTransportInput> | EnvoiCreateWithoutTransportInput[] | EnvoiUncheckedCreateWithoutTransportInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutTransportInput | EnvoiCreateOrConnectWithoutTransportInput[]
    createMany?: EnvoiCreateManyTransportInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type TransportScheduleCreateNestedManyWithoutTransportInput = {
    create?: XOR<TransportScheduleCreateWithoutTransportInput, TransportScheduleUncheckedCreateWithoutTransportInput> | TransportScheduleCreateWithoutTransportInput[] | TransportScheduleUncheckedCreateWithoutTransportInput[]
    connectOrCreate?: TransportScheduleCreateOrConnectWithoutTransportInput | TransportScheduleCreateOrConnectWithoutTransportInput[]
    createMany?: TransportScheduleCreateManyTransportInputEnvelope
    connect?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
  }

  export type AgencyCreateNestedOneWithoutTransportsInput = {
    create?: XOR<AgencyCreateWithoutTransportsInput, AgencyUncheckedCreateWithoutTransportsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutTransportsInput
    connect?: AgencyWhereUniqueInput
  }

  export type EnvoiUncheckedCreateNestedManyWithoutTransportInput = {
    create?: XOR<EnvoiCreateWithoutTransportInput, EnvoiUncheckedCreateWithoutTransportInput> | EnvoiCreateWithoutTransportInput[] | EnvoiUncheckedCreateWithoutTransportInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutTransportInput | EnvoiCreateOrConnectWithoutTransportInput[]
    createMany?: EnvoiCreateManyTransportInputEnvelope
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
  }

  export type TransportScheduleUncheckedCreateNestedManyWithoutTransportInput = {
    create?: XOR<TransportScheduleCreateWithoutTransportInput, TransportScheduleUncheckedCreateWithoutTransportInput> | TransportScheduleCreateWithoutTransportInput[] | TransportScheduleUncheckedCreateWithoutTransportInput[]
    connectOrCreate?: TransportScheduleCreateOrConnectWithoutTransportInput | TransportScheduleCreateOrConnectWithoutTransportInput[]
    createMany?: TransportScheduleCreateManyTransportInputEnvelope
    connect?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
  }

  export type EnvoiUpdateManyWithoutTransportNestedInput = {
    create?: XOR<EnvoiCreateWithoutTransportInput, EnvoiUncheckedCreateWithoutTransportInput> | EnvoiCreateWithoutTransportInput[] | EnvoiUncheckedCreateWithoutTransportInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutTransportInput | EnvoiCreateOrConnectWithoutTransportInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutTransportInput | EnvoiUpsertWithWhereUniqueWithoutTransportInput[]
    createMany?: EnvoiCreateManyTransportInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutTransportInput | EnvoiUpdateWithWhereUniqueWithoutTransportInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutTransportInput | EnvoiUpdateManyWithWhereWithoutTransportInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type TransportScheduleUpdateManyWithoutTransportNestedInput = {
    create?: XOR<TransportScheduleCreateWithoutTransportInput, TransportScheduleUncheckedCreateWithoutTransportInput> | TransportScheduleCreateWithoutTransportInput[] | TransportScheduleUncheckedCreateWithoutTransportInput[]
    connectOrCreate?: TransportScheduleCreateOrConnectWithoutTransportInput | TransportScheduleCreateOrConnectWithoutTransportInput[]
    upsert?: TransportScheduleUpsertWithWhereUniqueWithoutTransportInput | TransportScheduleUpsertWithWhereUniqueWithoutTransportInput[]
    createMany?: TransportScheduleCreateManyTransportInputEnvelope
    set?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
    disconnect?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
    delete?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
    connect?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
    update?: TransportScheduleUpdateWithWhereUniqueWithoutTransportInput | TransportScheduleUpdateWithWhereUniqueWithoutTransportInput[]
    updateMany?: TransportScheduleUpdateManyWithWhereWithoutTransportInput | TransportScheduleUpdateManyWithWhereWithoutTransportInput[]
    deleteMany?: TransportScheduleScalarWhereInput | TransportScheduleScalarWhereInput[]
  }

  export type AgencyUpdateOneWithoutTransportsNestedInput = {
    create?: XOR<AgencyCreateWithoutTransportsInput, AgencyUncheckedCreateWithoutTransportsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutTransportsInput
    upsert?: AgencyUpsertWithoutTransportsInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutTransportsInput, AgencyUpdateWithoutTransportsInput>, AgencyUncheckedUpdateWithoutTransportsInput>
  }

  export type EnvoiUncheckedUpdateManyWithoutTransportNestedInput = {
    create?: XOR<EnvoiCreateWithoutTransportInput, EnvoiUncheckedCreateWithoutTransportInput> | EnvoiCreateWithoutTransportInput[] | EnvoiUncheckedCreateWithoutTransportInput[]
    connectOrCreate?: EnvoiCreateOrConnectWithoutTransportInput | EnvoiCreateOrConnectWithoutTransportInput[]
    upsert?: EnvoiUpsertWithWhereUniqueWithoutTransportInput | EnvoiUpsertWithWhereUniqueWithoutTransportInput[]
    createMany?: EnvoiCreateManyTransportInputEnvelope
    set?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    disconnect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    delete?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    connect?: EnvoiWhereUniqueInput | EnvoiWhereUniqueInput[]
    update?: EnvoiUpdateWithWhereUniqueWithoutTransportInput | EnvoiUpdateWithWhereUniqueWithoutTransportInput[]
    updateMany?: EnvoiUpdateManyWithWhereWithoutTransportInput | EnvoiUpdateManyWithWhereWithoutTransportInput[]
    deleteMany?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
  }

  export type TransportScheduleUncheckedUpdateManyWithoutTransportNestedInput = {
    create?: XOR<TransportScheduleCreateWithoutTransportInput, TransportScheduleUncheckedCreateWithoutTransportInput> | TransportScheduleCreateWithoutTransportInput[] | TransportScheduleUncheckedCreateWithoutTransportInput[]
    connectOrCreate?: TransportScheduleCreateOrConnectWithoutTransportInput | TransportScheduleCreateOrConnectWithoutTransportInput[]
    upsert?: TransportScheduleUpsertWithWhereUniqueWithoutTransportInput | TransportScheduleUpsertWithWhereUniqueWithoutTransportInput[]
    createMany?: TransportScheduleCreateManyTransportInputEnvelope
    set?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
    disconnect?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
    delete?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
    connect?: TransportScheduleWhereUniqueInput | TransportScheduleWhereUniqueInput[]
    update?: TransportScheduleUpdateWithWhereUniqueWithoutTransportInput | TransportScheduleUpdateWithWhereUniqueWithoutTransportInput[]
    updateMany?: TransportScheduleUpdateManyWithWhereWithoutTransportInput | TransportScheduleUpdateManyWithWhereWithoutTransportInput[]
    deleteMany?: TransportScheduleScalarWhereInput | TransportScheduleScalarWhereInput[]
  }

  export type AgencyCreateNestedOneWithoutArrivalEnvoiInput = {
    create?: XOR<AgencyCreateWithoutArrivalEnvoiInput, AgencyUncheckedCreateWithoutArrivalEnvoiInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutArrivalEnvoiInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutDepartureEnvoiInput = {
    create?: XOR<AgencyCreateWithoutDepartureEnvoiInput, AgencyUncheckedCreateWithoutDepartureEnvoiInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutDepartureEnvoiInput
    connect?: AgencyWhereUniqueInput
  }

  export type TransportCreateNestedOneWithoutEnvoisInput = {
    create?: XOR<TransportCreateWithoutEnvoisInput, TransportUncheckedCreateWithoutEnvoisInput>
    connectOrCreate?: TransportCreateOrConnectWithoutEnvoisInput
    connect?: TransportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedEnvoisInput = {
    create?: XOR<UserCreateWithoutReceivedEnvoisInput, UserUncheckedCreateWithoutReceivedEnvoisInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedEnvoisInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentEnvoisInput = {
    create?: XOR<UserCreateWithoutSentEnvoisInput, UserUncheckedCreateWithoutSentEnvoisInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentEnvoisInput
    connect?: UserWhereUniqueInput
  }

  export type EnvoiCouponCreateNestedManyWithoutEnvoiInput = {
    create?: XOR<EnvoiCouponCreateWithoutEnvoiInput, EnvoiCouponUncheckedCreateWithoutEnvoiInput> | EnvoiCouponCreateWithoutEnvoiInput[] | EnvoiCouponUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: EnvoiCouponCreateOrConnectWithoutEnvoiInput | EnvoiCouponCreateOrConnectWithoutEnvoiInput[]
    createMany?: EnvoiCouponCreateManyEnvoiInputEnvelope
    connect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
  }

  export type ParcelCreateNestedManyWithoutEnvoiInput = {
    create?: XOR<ParcelCreateWithoutEnvoiInput, ParcelUncheckedCreateWithoutEnvoiInput> | ParcelCreateWithoutEnvoiInput[] | ParcelUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutEnvoiInput | ParcelCreateOrConnectWithoutEnvoiInput[]
    createMany?: ParcelCreateManyEnvoiInputEnvelope
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
  }

  export type AppointmentCreateNestedOneWithoutEnvoiInput = {
    create?: XOR<AppointmentCreateWithoutEnvoiInput, AppointmentUncheckedCreateWithoutEnvoiInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEnvoiInput
    connect?: AppointmentWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutEnvoiInput = {
    create?: XOR<NotificationCreateWithoutEnvoiInput, NotificationUncheckedCreateWithoutEnvoiInput> | NotificationCreateWithoutEnvoiInput[] | NotificationUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEnvoiInput | NotificationCreateOrConnectWithoutEnvoiInput[]
    createMany?: NotificationCreateManyEnvoiInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentCreateNestedOneWithoutEnvoiInput = {
    create?: XOR<PaymentCreateWithoutEnvoiInput, PaymentUncheckedCreateWithoutEnvoiInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutEnvoiInput
    connect?: PaymentWhereUniqueInput
  }

  export type TrackingEventCreateNestedManyWithoutEnvoiInput = {
    create?: XOR<TrackingEventCreateWithoutEnvoiInput, TrackingEventUncheckedCreateWithoutEnvoiInput> | TrackingEventCreateWithoutEnvoiInput[] | TrackingEventUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: TrackingEventCreateOrConnectWithoutEnvoiInput | TrackingEventCreateOrConnectWithoutEnvoiInput[]
    createMany?: TrackingEventCreateManyEnvoiInputEnvelope
    connect?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
  }

  export type EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput = {
    create?: XOR<EnvoiCouponCreateWithoutEnvoiInput, EnvoiCouponUncheckedCreateWithoutEnvoiInput> | EnvoiCouponCreateWithoutEnvoiInput[] | EnvoiCouponUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: EnvoiCouponCreateOrConnectWithoutEnvoiInput | EnvoiCouponCreateOrConnectWithoutEnvoiInput[]
    createMany?: EnvoiCouponCreateManyEnvoiInputEnvelope
    connect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
  }

  export type ParcelUncheckedCreateNestedManyWithoutEnvoiInput = {
    create?: XOR<ParcelCreateWithoutEnvoiInput, ParcelUncheckedCreateWithoutEnvoiInput> | ParcelCreateWithoutEnvoiInput[] | ParcelUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutEnvoiInput | ParcelCreateOrConnectWithoutEnvoiInput[]
    createMany?: ParcelCreateManyEnvoiInputEnvelope
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedOneWithoutEnvoiInput = {
    create?: XOR<AppointmentCreateWithoutEnvoiInput, AppointmentUncheckedCreateWithoutEnvoiInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEnvoiInput
    connect?: AppointmentWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutEnvoiInput = {
    create?: XOR<NotificationCreateWithoutEnvoiInput, NotificationUncheckedCreateWithoutEnvoiInput> | NotificationCreateWithoutEnvoiInput[] | NotificationUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEnvoiInput | NotificationCreateOrConnectWithoutEnvoiInput[]
    createMany?: NotificationCreateManyEnvoiInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutEnvoiInput = {
    create?: XOR<PaymentCreateWithoutEnvoiInput, PaymentUncheckedCreateWithoutEnvoiInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutEnvoiInput
    connect?: PaymentWhereUniqueInput
  }

  export type TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput = {
    create?: XOR<TrackingEventCreateWithoutEnvoiInput, TrackingEventUncheckedCreateWithoutEnvoiInput> | TrackingEventCreateWithoutEnvoiInput[] | TrackingEventUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: TrackingEventCreateOrConnectWithoutEnvoiInput | TrackingEventCreateOrConnectWithoutEnvoiInput[]
    createMany?: TrackingEventCreateManyEnvoiInputEnvelope
    connect?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
  }

  export type EnumSimulationStatusFieldUpdateOperationsInput = {
    set?: $Enums.SimulationStatus
  }

  export type EnumEnvoiStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnvoiStatus
  }

  export type AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput = {
    create?: XOR<AgencyCreateWithoutArrivalEnvoiInput, AgencyUncheckedCreateWithoutArrivalEnvoiInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutArrivalEnvoiInput
    upsert?: AgencyUpsertWithoutArrivalEnvoiInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutArrivalEnvoiInput, AgencyUpdateWithoutArrivalEnvoiInput>, AgencyUncheckedUpdateWithoutArrivalEnvoiInput>
  }

  export type AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput = {
    create?: XOR<AgencyCreateWithoutDepartureEnvoiInput, AgencyUncheckedCreateWithoutDepartureEnvoiInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutDepartureEnvoiInput
    upsert?: AgencyUpsertWithoutDepartureEnvoiInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutDepartureEnvoiInput, AgencyUpdateWithoutDepartureEnvoiInput>, AgencyUncheckedUpdateWithoutDepartureEnvoiInput>
  }

  export type TransportUpdateOneWithoutEnvoisNestedInput = {
    create?: XOR<TransportCreateWithoutEnvoisInput, TransportUncheckedCreateWithoutEnvoisInput>
    connectOrCreate?: TransportCreateOrConnectWithoutEnvoisInput
    upsert?: TransportUpsertWithoutEnvoisInput
    disconnect?: TransportWhereInput | boolean
    delete?: TransportWhereInput | boolean
    connect?: TransportWhereUniqueInput
    update?: XOR<XOR<TransportUpdateToOneWithWhereWithoutEnvoisInput, TransportUpdateWithoutEnvoisInput>, TransportUncheckedUpdateWithoutEnvoisInput>
  }

  export type UserUpdateOneWithoutReceivedEnvoisNestedInput = {
    create?: XOR<UserCreateWithoutReceivedEnvoisInput, UserUncheckedCreateWithoutReceivedEnvoisInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedEnvoisInput
    upsert?: UserUpsertWithoutReceivedEnvoisInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedEnvoisInput, UserUpdateWithoutReceivedEnvoisInput>, UserUncheckedUpdateWithoutReceivedEnvoisInput>
  }

  export type UserUpdateOneWithoutSentEnvoisNestedInput = {
    create?: XOR<UserCreateWithoutSentEnvoisInput, UserUncheckedCreateWithoutSentEnvoisInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentEnvoisInput
    upsert?: UserUpsertWithoutSentEnvoisInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentEnvoisInput, UserUpdateWithoutSentEnvoisInput>, UserUncheckedUpdateWithoutSentEnvoisInput>
  }

  export type EnvoiCouponUpdateManyWithoutEnvoiNestedInput = {
    create?: XOR<EnvoiCouponCreateWithoutEnvoiInput, EnvoiCouponUncheckedCreateWithoutEnvoiInput> | EnvoiCouponCreateWithoutEnvoiInput[] | EnvoiCouponUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: EnvoiCouponCreateOrConnectWithoutEnvoiInput | EnvoiCouponCreateOrConnectWithoutEnvoiInput[]
    upsert?: EnvoiCouponUpsertWithWhereUniqueWithoutEnvoiInput | EnvoiCouponUpsertWithWhereUniqueWithoutEnvoiInput[]
    createMany?: EnvoiCouponCreateManyEnvoiInputEnvelope
    set?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    disconnect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    delete?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    connect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    update?: EnvoiCouponUpdateWithWhereUniqueWithoutEnvoiInput | EnvoiCouponUpdateWithWhereUniqueWithoutEnvoiInput[]
    updateMany?: EnvoiCouponUpdateManyWithWhereWithoutEnvoiInput | EnvoiCouponUpdateManyWithWhereWithoutEnvoiInput[]
    deleteMany?: EnvoiCouponScalarWhereInput | EnvoiCouponScalarWhereInput[]
  }

  export type ParcelUpdateManyWithoutEnvoiNestedInput = {
    create?: XOR<ParcelCreateWithoutEnvoiInput, ParcelUncheckedCreateWithoutEnvoiInput> | ParcelCreateWithoutEnvoiInput[] | ParcelUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutEnvoiInput | ParcelCreateOrConnectWithoutEnvoiInput[]
    upsert?: ParcelUpsertWithWhereUniqueWithoutEnvoiInput | ParcelUpsertWithWhereUniqueWithoutEnvoiInput[]
    createMany?: ParcelCreateManyEnvoiInputEnvelope
    set?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    disconnect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    delete?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    update?: ParcelUpdateWithWhereUniqueWithoutEnvoiInput | ParcelUpdateWithWhereUniqueWithoutEnvoiInput[]
    updateMany?: ParcelUpdateManyWithWhereWithoutEnvoiInput | ParcelUpdateManyWithWhereWithoutEnvoiInput[]
    deleteMany?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
  }

  export type AppointmentUpdateOneWithoutEnvoiNestedInput = {
    create?: XOR<AppointmentCreateWithoutEnvoiInput, AppointmentUncheckedCreateWithoutEnvoiInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEnvoiInput
    upsert?: AppointmentUpsertWithoutEnvoiInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutEnvoiInput, AppointmentUpdateWithoutEnvoiInput>, AppointmentUncheckedUpdateWithoutEnvoiInput>
  }

  export type NotificationUpdateManyWithoutEnvoiNestedInput = {
    create?: XOR<NotificationCreateWithoutEnvoiInput, NotificationUncheckedCreateWithoutEnvoiInput> | NotificationCreateWithoutEnvoiInput[] | NotificationUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEnvoiInput | NotificationCreateOrConnectWithoutEnvoiInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEnvoiInput | NotificationUpsertWithWhereUniqueWithoutEnvoiInput[]
    createMany?: NotificationCreateManyEnvoiInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEnvoiInput | NotificationUpdateWithWhereUniqueWithoutEnvoiInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEnvoiInput | NotificationUpdateManyWithWhereWithoutEnvoiInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUpdateOneWithoutEnvoiNestedInput = {
    create?: XOR<PaymentCreateWithoutEnvoiInput, PaymentUncheckedCreateWithoutEnvoiInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutEnvoiInput
    upsert?: PaymentUpsertWithoutEnvoiInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutEnvoiInput, PaymentUpdateWithoutEnvoiInput>, PaymentUncheckedUpdateWithoutEnvoiInput>
  }

  export type TrackingEventUpdateManyWithoutEnvoiNestedInput = {
    create?: XOR<TrackingEventCreateWithoutEnvoiInput, TrackingEventUncheckedCreateWithoutEnvoiInput> | TrackingEventCreateWithoutEnvoiInput[] | TrackingEventUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: TrackingEventCreateOrConnectWithoutEnvoiInput | TrackingEventCreateOrConnectWithoutEnvoiInput[]
    upsert?: TrackingEventUpsertWithWhereUniqueWithoutEnvoiInput | TrackingEventUpsertWithWhereUniqueWithoutEnvoiInput[]
    createMany?: TrackingEventCreateManyEnvoiInputEnvelope
    set?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
    disconnect?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
    delete?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
    connect?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
    update?: TrackingEventUpdateWithWhereUniqueWithoutEnvoiInput | TrackingEventUpdateWithWhereUniqueWithoutEnvoiInput[]
    updateMany?: TrackingEventUpdateManyWithWhereWithoutEnvoiInput | TrackingEventUpdateManyWithWhereWithoutEnvoiInput[]
    deleteMany?: TrackingEventScalarWhereInput | TrackingEventScalarWhereInput[]
  }

  export type EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput = {
    create?: XOR<EnvoiCouponCreateWithoutEnvoiInput, EnvoiCouponUncheckedCreateWithoutEnvoiInput> | EnvoiCouponCreateWithoutEnvoiInput[] | EnvoiCouponUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: EnvoiCouponCreateOrConnectWithoutEnvoiInput | EnvoiCouponCreateOrConnectWithoutEnvoiInput[]
    upsert?: EnvoiCouponUpsertWithWhereUniqueWithoutEnvoiInput | EnvoiCouponUpsertWithWhereUniqueWithoutEnvoiInput[]
    createMany?: EnvoiCouponCreateManyEnvoiInputEnvelope
    set?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    disconnect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    delete?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    connect?: EnvoiCouponWhereUniqueInput | EnvoiCouponWhereUniqueInput[]
    update?: EnvoiCouponUpdateWithWhereUniqueWithoutEnvoiInput | EnvoiCouponUpdateWithWhereUniqueWithoutEnvoiInput[]
    updateMany?: EnvoiCouponUpdateManyWithWhereWithoutEnvoiInput | EnvoiCouponUpdateManyWithWhereWithoutEnvoiInput[]
    deleteMany?: EnvoiCouponScalarWhereInput | EnvoiCouponScalarWhereInput[]
  }

  export type ParcelUncheckedUpdateManyWithoutEnvoiNestedInput = {
    create?: XOR<ParcelCreateWithoutEnvoiInput, ParcelUncheckedCreateWithoutEnvoiInput> | ParcelCreateWithoutEnvoiInput[] | ParcelUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutEnvoiInput | ParcelCreateOrConnectWithoutEnvoiInput[]
    upsert?: ParcelUpsertWithWhereUniqueWithoutEnvoiInput | ParcelUpsertWithWhereUniqueWithoutEnvoiInput[]
    createMany?: ParcelCreateManyEnvoiInputEnvelope
    set?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    disconnect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    delete?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    update?: ParcelUpdateWithWhereUniqueWithoutEnvoiInput | ParcelUpdateWithWhereUniqueWithoutEnvoiInput[]
    updateMany?: ParcelUpdateManyWithWhereWithoutEnvoiInput | ParcelUpdateManyWithWhereWithoutEnvoiInput[]
    deleteMany?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput = {
    create?: XOR<AppointmentCreateWithoutEnvoiInput, AppointmentUncheckedCreateWithoutEnvoiInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEnvoiInput
    upsert?: AppointmentUpsertWithoutEnvoiInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutEnvoiInput, AppointmentUpdateWithoutEnvoiInput>, AppointmentUncheckedUpdateWithoutEnvoiInput>
  }

  export type NotificationUncheckedUpdateManyWithoutEnvoiNestedInput = {
    create?: XOR<NotificationCreateWithoutEnvoiInput, NotificationUncheckedCreateWithoutEnvoiInput> | NotificationCreateWithoutEnvoiInput[] | NotificationUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEnvoiInput | NotificationCreateOrConnectWithoutEnvoiInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEnvoiInput | NotificationUpsertWithWhereUniqueWithoutEnvoiInput[]
    createMany?: NotificationCreateManyEnvoiInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEnvoiInput | NotificationUpdateWithWhereUniqueWithoutEnvoiInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEnvoiInput | NotificationUpdateManyWithWhereWithoutEnvoiInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutEnvoiNestedInput = {
    create?: XOR<PaymentCreateWithoutEnvoiInput, PaymentUncheckedCreateWithoutEnvoiInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutEnvoiInput
    upsert?: PaymentUpsertWithoutEnvoiInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutEnvoiInput, PaymentUpdateWithoutEnvoiInput>, PaymentUncheckedUpdateWithoutEnvoiInput>
  }

  export type TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput = {
    create?: XOR<TrackingEventCreateWithoutEnvoiInput, TrackingEventUncheckedCreateWithoutEnvoiInput> | TrackingEventCreateWithoutEnvoiInput[] | TrackingEventUncheckedCreateWithoutEnvoiInput[]
    connectOrCreate?: TrackingEventCreateOrConnectWithoutEnvoiInput | TrackingEventCreateOrConnectWithoutEnvoiInput[]
    upsert?: TrackingEventUpsertWithWhereUniqueWithoutEnvoiInput | TrackingEventUpsertWithWhereUniqueWithoutEnvoiInput[]
    createMany?: TrackingEventCreateManyEnvoiInputEnvelope
    set?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
    disconnect?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
    delete?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
    connect?: TrackingEventWhereUniqueInput | TrackingEventWhereUniqueInput[]
    update?: TrackingEventUpdateWithWhereUniqueWithoutEnvoiInput | TrackingEventUpdateWithWhereUniqueWithoutEnvoiInput[]
    updateMany?: TrackingEventUpdateManyWithWhereWithoutEnvoiInput | TrackingEventUpdateManyWithWhereWithoutEnvoiInput[]
    deleteMany?: TrackingEventScalarWhereInput | TrackingEventScalarWhereInput[]
  }

  export type EnvoiCreateNestedOneWithoutTrackingEventsInput = {
    create?: XOR<EnvoiCreateWithoutTrackingEventsInput, EnvoiUncheckedCreateWithoutTrackingEventsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutTrackingEventsInput
    connect?: EnvoiWhereUniqueInput
  }

  export type EnumTrackingEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrackingEventStatus
  }

  export type EnvoiUpdateOneRequiredWithoutTrackingEventsNestedInput = {
    create?: XOR<EnvoiCreateWithoutTrackingEventsInput, EnvoiUncheckedCreateWithoutTrackingEventsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutTrackingEventsInput
    upsert?: EnvoiUpsertWithoutTrackingEventsInput
    connect?: EnvoiWhereUniqueInput
    update?: XOR<XOR<EnvoiUpdateToOneWithWhereWithoutTrackingEventsInput, EnvoiUpdateWithoutTrackingEventsInput>, EnvoiUncheckedUpdateWithoutTrackingEventsInput>
  }

  export type EnvoiCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<EnvoiCreateWithoutAppointmentsInput, EnvoiUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutAppointmentsInput
    connect?: EnvoiWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<AgencyCreateWithoutAppointmentsInput, AgencyUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAppointmentsInput
    connect?: AgencyWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type EnvoiUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<EnvoiCreateWithoutAppointmentsInput, EnvoiUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutAppointmentsInput
    upsert?: EnvoiUpsertWithoutAppointmentsInput
    connect?: EnvoiWhereUniqueInput
    update?: XOR<XOR<EnvoiUpdateToOneWithWhereWithoutAppointmentsInput, EnvoiUpdateWithoutAppointmentsInput>, EnvoiUncheckedUpdateWithoutAppointmentsInput>
  }

  export type AgencyUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<AgencyCreateWithoutAppointmentsInput, AgencyUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAppointmentsInput
    upsert?: AgencyUpsertWithoutAppointmentsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAppointmentsInput, AgencyUpdateWithoutAppointmentsInput>, AgencyUncheckedUpdateWithoutAppointmentsInput>
  }

  export type EnvoiCreateNestedOneWithoutEnvoiCouponsInput = {
    create?: XOR<EnvoiCreateWithoutEnvoiCouponsInput, EnvoiUncheckedCreateWithoutEnvoiCouponsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutEnvoiCouponsInput
    connect?: EnvoiWhereUniqueInput
  }

  export type CouponCreateNestedOneWithoutEnvoiCouponInput = {
    create?: XOR<CouponCreateWithoutEnvoiCouponInput, CouponUncheckedCreateWithoutEnvoiCouponInput>
    connectOrCreate?: CouponCreateOrConnectWithoutEnvoiCouponInput
    connect?: CouponWhereUniqueInput
  }

  export type EnvoiUpdateOneRequiredWithoutEnvoiCouponsNestedInput = {
    create?: XOR<EnvoiCreateWithoutEnvoiCouponsInput, EnvoiUncheckedCreateWithoutEnvoiCouponsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutEnvoiCouponsInput
    upsert?: EnvoiUpsertWithoutEnvoiCouponsInput
    connect?: EnvoiWhereUniqueInput
    update?: XOR<XOR<EnvoiUpdateToOneWithWhereWithoutEnvoiCouponsInput, EnvoiUpdateWithoutEnvoiCouponsInput>, EnvoiUncheckedUpdateWithoutEnvoiCouponsInput>
  }

  export type CouponUpdateOneRequiredWithoutEnvoiCouponNestedInput = {
    create?: XOR<CouponCreateWithoutEnvoiCouponInput, CouponUncheckedCreateWithoutEnvoiCouponInput>
    connectOrCreate?: CouponCreateOrConnectWithoutEnvoiCouponInput
    upsert?: CouponUpsertWithoutEnvoiCouponInput
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutEnvoiCouponInput, CouponUpdateWithoutEnvoiCouponInput>, CouponUncheckedUpdateWithoutEnvoiCouponInput>
  }

  export type EnvoiCreateNestedOneWithoutParcelsInput = {
    create?: XOR<EnvoiCreateWithoutParcelsInput, EnvoiUncheckedCreateWithoutParcelsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutParcelsInput
    connect?: EnvoiWhereUniqueInput
  }

  export type EnvoiUpdateOneRequiredWithoutParcelsNestedInput = {
    create?: XOR<EnvoiCreateWithoutParcelsInput, EnvoiUncheckedCreateWithoutParcelsInput>
    connectOrCreate?: EnvoiCreateOrConnectWithoutParcelsInput
    upsert?: EnvoiUpsertWithoutParcelsInput
    connect?: EnvoiWhereUniqueInput
    update?: XOR<XOR<EnvoiUpdateToOneWithWhereWithoutParcelsInput, EnvoiUpdateWithoutParcelsInput>, EnvoiUncheckedUpdateWithoutParcelsInput>
  }

  export type AgencyCreateNestedOneWithoutTarifsInput = {
    create?: XOR<AgencyCreateWithoutTarifsInput, AgencyUncheckedCreateWithoutTarifsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutTarifsInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyUpdateOneWithoutTarifsNestedInput = {
    create?: XOR<AgencyCreateWithoutTarifsInput, AgencyUncheckedCreateWithoutTarifsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutTarifsInput
    upsert?: AgencyUpsertWithoutTarifsInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutTarifsInput, AgencyUpdateWithoutTarifsInput>, AgencyUncheckedUpdateWithoutTarifsInput>
  }

  export type TransportCreateNestedOneWithoutTransportSchedulesInput = {
    create?: XOR<TransportCreateWithoutTransportSchedulesInput, TransportUncheckedCreateWithoutTransportSchedulesInput>
    connectOrCreate?: TransportCreateOrConnectWithoutTransportSchedulesInput
    connect?: TransportWhereUniqueInput
  }

  export type TransportUpdateOneRequiredWithoutTransportSchedulesNestedInput = {
    create?: XOR<TransportCreateWithoutTransportSchedulesInput, TransportUncheckedCreateWithoutTransportSchedulesInput>
    connectOrCreate?: TransportCreateOrConnectWithoutTransportSchedulesInput
    upsert?: TransportUpsertWithoutTransportSchedulesInput
    connect?: TransportWhereUniqueInput
    update?: XOR<XOR<TransportUpdateToOneWithWhereWithoutTransportSchedulesInput, TransportUpdateWithoutTransportSchedulesInput>, TransportUncheckedUpdateWithoutTransportSchedulesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumVatTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VatType | EnumVatTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VatType[] | ListEnumVatTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VatType[] | ListEnumVatTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVatTypeNullableFilter<$PrismaModel> | $Enums.VatType | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumVatTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VatType | EnumVatTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VatType[] | ListEnumVatTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VatType[] | ListEnumVatTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVatTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VatType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVatTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVatTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type NestedEnumSimulationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusFilter<$PrismaModel> | $Enums.SimulationStatus
  }

  export type NestedEnumEnvoiStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnvoiStatus | EnumEnvoiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnvoiStatus[] | ListEnumEnvoiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnvoiStatus[] | ListEnumEnvoiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnvoiStatusFilter<$PrismaModel> | $Enums.EnvoiStatus
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedEnumSimulationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimulationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimulationStatusFilter<$PrismaModel>
    _max?: NestedEnumSimulationStatusFilter<$PrismaModel>
  }

  export type NestedEnumEnvoiStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnvoiStatus | EnumEnvoiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnvoiStatus[] | ListEnumEnvoiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnvoiStatus[] | ListEnumEnvoiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnvoiStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnvoiStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnvoiStatusFilter<$PrismaModel>
    _max?: NestedEnumEnvoiStatusFilter<$PrismaModel>
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumTrackingEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingEventStatus | EnumTrackingEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingEventStatus[] | ListEnumTrackingEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingEventStatus[] | ListEnumTrackingEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingEventStatusFilter<$PrismaModel> | $Enums.TrackingEventStatus
  }

  export type NestedEnumTrackingEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingEventStatus | EnumTrackingEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingEventStatus[] | ListEnumTrackingEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingEventStatus[] | ListEnumTrackingEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrackingEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackingEventStatusFilter<$PrismaModel>
    _max?: NestedEnumTrackingEventStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type EnvoiCreateWithoutPaymentInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutPaymentInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutPaymentInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutPaymentInput, EnvoiUncheckedCreateWithoutPaymentInput>
  }

  export type EnvoiUpsertWithoutPaymentInput = {
    update: XOR<EnvoiUpdateWithoutPaymentInput, EnvoiUncheckedUpdateWithoutPaymentInput>
    create: XOR<EnvoiCreateWithoutPaymentInput, EnvoiUncheckedCreateWithoutPaymentInput>
    where?: EnvoiWhereInput
  }

  export type EnvoiUpdateToOneWithWhereWithoutPaymentInput = {
    where?: EnvoiWhereInput
    data: XOR<EnvoiUpdateWithoutPaymentInput, EnvoiUncheckedUpdateWithoutPaymentInput>
  }

  export type EnvoiUpdateWithoutPaymentInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuthenticatorCreateWithoutUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUncheckedCreateWithoutUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorCreateOrConnectWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    create: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput>
  }

  export type AuthenticatorCreateManyUserInputEnvelope = {
    data: AuthenticatorCreateManyUserInput | AuthenticatorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EnvoiCreateWithoutClientInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutClientInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutClientInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutClientInput, EnvoiUncheckedCreateWithoutClientInput>
  }

  export type EnvoiCreateManyClientInputEnvelope = {
    data: EnvoiCreateManyClientInput | EnvoiCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type EnvoiCreateWithoutDestinataireInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutDestinataireInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutDestinataireInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutDestinataireInput, EnvoiUncheckedCreateWithoutDestinataireInput>
  }

  export type EnvoiCreateManyDestinataireInputEnvelope = {
    data: EnvoiCreateManyDestinataireInput | EnvoiCreateManyDestinataireInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutDestinataireNotificationInput = {
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutNotificationsInput
    envoi: EnvoiCreateNestedOneWithoutNotificationsInput
    clientNotification?: UserCreateNestedOneWithoutNotificationAsClientInput
  }

  export type NotificationUncheckedCreateWithoutDestinataireNotificationInput = {
    id?: number
    message: string
    agencyId: number
    clientId?: number | null
    envoiId: number
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutDestinataireNotificationInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutDestinataireNotificationInput, NotificationUncheckedCreateWithoutDestinataireNotificationInput>
  }

  export type NotificationCreateManyDestinataireNotificationInputEnvelope = {
    data: NotificationCreateManyDestinataireNotificationInput | NotificationCreateManyDestinataireNotificationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutClientNotificationInput = {
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutNotificationsInput
    envoi: EnvoiCreateNestedOneWithoutNotificationsInput
    destinataireNotification?: UserCreateNestedOneWithoutNotificationsAsDestinataireInput
  }

  export type NotificationUncheckedCreateWithoutClientNotificationInput = {
    id?: number
    message: string
    agencyId: number
    destinataireId?: number | null
    envoiId: number
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutClientNotificationInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutClientNotificationInput, NotificationUncheckedCreateWithoutClientNotificationInput>
  }

  export type NotificationCreateManyClientNotificationInputEnvelope = {
    data: NotificationCreateManyClientNotificationInput | NotificationCreateManyClientNotificationInput[]
    skipDuplicates?: boolean
  }

  export type UserCouponCreateWithoutUserInput = {
    coupon: CouponCreateNestedOneWithoutUserCouponInput
  }

  export type UserCouponUncheckedCreateWithoutUserInput = {
    couponId: number
  }

  export type UserCouponCreateOrConnectWithoutUserInput = {
    where: UserCouponWhereUniqueInput
    create: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput>
  }

  export type UserCouponCreateManyUserInputEnvelope = {
    data: UserCouponCreateManyUserInput | UserCouponCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientDestinataireCreateWithoutClientInput = {
    createdAt?: Date | string
    destinataire: UserCreateNestedOneWithoutDestinataireLinksInput
  }

  export type ClientDestinataireUncheckedCreateWithoutClientInput = {
    id?: number
    destinataireId: number
    createdAt?: Date | string
  }

  export type ClientDestinataireCreateOrConnectWithoutClientInput = {
    where: ClientDestinataireWhereUniqueInput
    create: XOR<ClientDestinataireCreateWithoutClientInput, ClientDestinataireUncheckedCreateWithoutClientInput>
  }

  export type ClientDestinataireCreateManyClientInputEnvelope = {
    data: ClientDestinataireCreateManyClientInput | ClientDestinataireCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientDestinataireCreateWithoutDestinataireInput = {
    createdAt?: Date | string
    client: UserCreateNestedOneWithoutClientLinksInput
  }

  export type ClientDestinataireUncheckedCreateWithoutDestinataireInput = {
    id?: number
    clientId: number
    createdAt?: Date | string
  }

  export type ClientDestinataireCreateOrConnectWithoutDestinataireInput = {
    where: ClientDestinataireWhereUniqueInput
    create: XOR<ClientDestinataireCreateWithoutDestinataireInput, ClientDestinataireUncheckedCreateWithoutDestinataireInput>
  }

  export type ClientDestinataireCreateManyDestinataireInputEnvelope = {
    data: ClientDestinataireCreateManyDestinataireInput | ClientDestinataireCreateManyDestinataireInput[]
    skipDuplicates?: boolean
  }

  export type AgencyClientsCreateWithoutClientInput = {
    agency: AgencyCreateNestedOneWithoutAgencyClientsInput
  }

  export type AgencyClientsUncheckedCreateWithoutClientInput = {
    agencyId: number
  }

  export type AgencyClientsCreateOrConnectWithoutClientInput = {
    where: AgencyClientsWhereUniqueInput
    create: XOR<AgencyClientsCreateWithoutClientInput, AgencyClientsUncheckedCreateWithoutClientInput>
  }

  export type AgencyClientsCreateManyClientInputEnvelope = {
    data: AgencyClientsCreateManyClientInput | AgencyClientsCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AgencyStaffCreateWithoutStaffInput = {
    staffRole: $Enums.Role
    agency: AgencyCreateNestedOneWithoutAgencyStaffInput
  }

  export type AgencyStaffUncheckedCreateWithoutStaffInput = {
    id?: number
    agencyId: number
    staffRole: $Enums.Role
  }

  export type AgencyStaffCreateOrConnectWithoutStaffInput = {
    where: AgencyStaffWhereUniqueInput
    create: XOR<AgencyStaffCreateWithoutStaffInput, AgencyStaffUncheckedCreateWithoutStaffInput>
  }

  export type AgencyStaffCreateManyStaffInputEnvelope = {
    data: AgencyStaffCreateManyStaffInput | AgencyStaffCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type UserAddressCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    addressType: $Enums.AddressType
    address: AddressCreateNestedOneWithoutUserAddressesInput
  }

  export type UserAddressUncheckedCreateWithoutUserInput = {
    id?: number
    addressId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addressType: $Enums.AddressType
  }

  export type UserAddressCreateOrConnectWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressCreateManyUserInputEnvelope = {
    data: UserAddressCreateManyUserInput | UserAddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgencyCreateWithoutCreatedByInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutCreatedByInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutCreatedByInput, AgencyUncheckedCreateWithoutCreatedByInput>
  }

  export type AgencyCreateManyCreatedByInputEnvelope = {
    data: AgencyCreateManyCreatedByInput | AgencyCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutStaffInput = {
    activityType: $Enums.ActivityType
    details?: string | null
    staffRole: $Enums.Role
    createdAt?: Date | string
    agency?: AgencyCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutStaffInput = {
    id?: number
    activityType: $Enums.ActivityType
    agencyId?: number | null
    details?: string | null
    staffRole: $Enums.Role
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutStaffInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutStaffInput, ActivityLogUncheckedCreateWithoutStaffInput>
  }

  export type ActivityLogCreateManyStaffInputEnvelope = {
    data: ActivityLogCreateManyStaffInput | ActivityLogCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    userId?: IntFilter<"Account"> | number
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    sessionToken?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AuthenticatorUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    update: XOR<AuthenticatorUpdateWithoutUserInput, AuthenticatorUncheckedUpdateWithoutUserInput>
    create: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput>
  }

  export type AuthenticatorUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    data: XOR<AuthenticatorUpdateWithoutUserInput, AuthenticatorUncheckedUpdateWithoutUserInput>
  }

  export type AuthenticatorUpdateManyWithWhereWithoutUserInput = {
    where: AuthenticatorScalarWhereInput
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthenticatorScalarWhereInput = {
    AND?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
    OR?: AuthenticatorScalarWhereInput[]
    NOT?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
    credentialID?: StringFilter<"Authenticator"> | string
    userId?: IntFilter<"Authenticator"> | number
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
  }

  export type EnvoiUpsertWithWhereUniqueWithoutClientInput = {
    where: EnvoiWhereUniqueInput
    update: XOR<EnvoiUpdateWithoutClientInput, EnvoiUncheckedUpdateWithoutClientInput>
    create: XOR<EnvoiCreateWithoutClientInput, EnvoiUncheckedCreateWithoutClientInput>
  }

  export type EnvoiUpdateWithWhereUniqueWithoutClientInput = {
    where: EnvoiWhereUniqueInput
    data: XOR<EnvoiUpdateWithoutClientInput, EnvoiUncheckedUpdateWithoutClientInput>
  }

  export type EnvoiUpdateManyWithWhereWithoutClientInput = {
    where: EnvoiScalarWhereInput
    data: XOR<EnvoiUpdateManyMutationInput, EnvoiUncheckedUpdateManyWithoutClientInput>
  }

  export type EnvoiScalarWhereInput = {
    AND?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
    OR?: EnvoiScalarWhereInput[]
    NOT?: EnvoiScalarWhereInput | EnvoiScalarWhereInput[]
    id?: IntFilter<"Envoi"> | number
    trackingNumber?: StringNullableFilter<"Envoi"> | string | null
    qrCodeUrl?: StringNullableFilter<"Envoi"> | string | null
    userId?: IntNullableFilter<"Envoi"> | number | null
    destinataireId?: IntNullableFilter<"Envoi"> | number | null
    transportId?: IntNullableFilter<"Envoi"> | number | null
    departureAgencyId?: IntFilter<"Envoi"> | number
    arrivalAgencyId?: IntFilter<"Envoi"> | number
    simulationStatus?: EnumSimulationStatusFilter<"Envoi"> | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFilter<"Envoi"> | $Enums.EnvoiStatus
    totalWeight?: FloatFilter<"Envoi"> | number
    totalVolume?: FloatFilter<"Envoi"> | number
    totalPrice?: FloatFilter<"Envoi"> | number
    paid?: BoolFilter<"Envoi"> | boolean
    departureDate?: DateTimeFilter<"Envoi"> | Date | string
    arrivalDate?: DateTimeFilter<"Envoi"> | Date | string
    verificationToken?: UuidFilter<"Envoi"> | string
    comment?: StringNullableFilter<"Envoi"> | string | null
    createdAt?: DateTimeFilter<"Envoi"> | Date | string
    updatedAt?: DateTimeFilter<"Envoi"> | Date | string
  }

  export type EnvoiUpsertWithWhereUniqueWithoutDestinataireInput = {
    where: EnvoiWhereUniqueInput
    update: XOR<EnvoiUpdateWithoutDestinataireInput, EnvoiUncheckedUpdateWithoutDestinataireInput>
    create: XOR<EnvoiCreateWithoutDestinataireInput, EnvoiUncheckedCreateWithoutDestinataireInput>
  }

  export type EnvoiUpdateWithWhereUniqueWithoutDestinataireInput = {
    where: EnvoiWhereUniqueInput
    data: XOR<EnvoiUpdateWithoutDestinataireInput, EnvoiUncheckedUpdateWithoutDestinataireInput>
  }

  export type EnvoiUpdateManyWithWhereWithoutDestinataireInput = {
    where: EnvoiScalarWhereInput
    data: XOR<EnvoiUpdateManyMutationInput, EnvoiUncheckedUpdateManyWithoutDestinataireInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutDestinataireNotificationInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutDestinataireNotificationInput, NotificationUncheckedUpdateWithoutDestinataireNotificationInput>
    create: XOR<NotificationCreateWithoutDestinataireNotificationInput, NotificationUncheckedCreateWithoutDestinataireNotificationInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutDestinataireNotificationInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutDestinataireNotificationInput, NotificationUncheckedUpdateWithoutDestinataireNotificationInput>
  }

  export type NotificationUpdateManyWithWhereWithoutDestinataireNotificationInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutDestinataireNotificationInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    message?: StringFilter<"Notification"> | string
    agencyId?: IntFilter<"Notification"> | number
    destinataireId?: IntNullableFilter<"Notification"> | number | null
    clientId?: IntNullableFilter<"Notification"> | number | null
    envoiId?: IntFilter<"Notification"> | number
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutClientNotificationInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutClientNotificationInput, NotificationUncheckedUpdateWithoutClientNotificationInput>
    create: XOR<NotificationCreateWithoutClientNotificationInput, NotificationUncheckedCreateWithoutClientNotificationInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutClientNotificationInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutClientNotificationInput, NotificationUncheckedUpdateWithoutClientNotificationInput>
  }

  export type NotificationUpdateManyWithWhereWithoutClientNotificationInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutClientNotificationInput>
  }

  export type UserCouponUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCouponWhereUniqueInput
    update: XOR<UserCouponUpdateWithoutUserInput, UserCouponUncheckedUpdateWithoutUserInput>
    create: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput>
  }

  export type UserCouponUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCouponWhereUniqueInput
    data: XOR<UserCouponUpdateWithoutUserInput, UserCouponUncheckedUpdateWithoutUserInput>
  }

  export type UserCouponUpdateManyWithWhereWithoutUserInput = {
    where: UserCouponScalarWhereInput
    data: XOR<UserCouponUpdateManyMutationInput, UserCouponUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCouponScalarWhereInput = {
    AND?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
    OR?: UserCouponScalarWhereInput[]
    NOT?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
    userId?: IntFilter<"UserCoupon"> | number
    couponId?: IntFilter<"UserCoupon"> | number
  }

  export type ClientDestinataireUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientDestinataireWhereUniqueInput
    update: XOR<ClientDestinataireUpdateWithoutClientInput, ClientDestinataireUncheckedUpdateWithoutClientInput>
    create: XOR<ClientDestinataireCreateWithoutClientInput, ClientDestinataireUncheckedCreateWithoutClientInput>
  }

  export type ClientDestinataireUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientDestinataireWhereUniqueInput
    data: XOR<ClientDestinataireUpdateWithoutClientInput, ClientDestinataireUncheckedUpdateWithoutClientInput>
  }

  export type ClientDestinataireUpdateManyWithWhereWithoutClientInput = {
    where: ClientDestinataireScalarWhereInput
    data: XOR<ClientDestinataireUpdateManyMutationInput, ClientDestinataireUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientDestinataireScalarWhereInput = {
    AND?: ClientDestinataireScalarWhereInput | ClientDestinataireScalarWhereInput[]
    OR?: ClientDestinataireScalarWhereInput[]
    NOT?: ClientDestinataireScalarWhereInput | ClientDestinataireScalarWhereInput[]
    id?: IntFilter<"ClientDestinataire"> | number
    clientId?: IntFilter<"ClientDestinataire"> | number
    destinataireId?: IntFilter<"ClientDestinataire"> | number
    createdAt?: DateTimeFilter<"ClientDestinataire"> | Date | string
  }

  export type ClientDestinataireUpsertWithWhereUniqueWithoutDestinataireInput = {
    where: ClientDestinataireWhereUniqueInput
    update: XOR<ClientDestinataireUpdateWithoutDestinataireInput, ClientDestinataireUncheckedUpdateWithoutDestinataireInput>
    create: XOR<ClientDestinataireCreateWithoutDestinataireInput, ClientDestinataireUncheckedCreateWithoutDestinataireInput>
  }

  export type ClientDestinataireUpdateWithWhereUniqueWithoutDestinataireInput = {
    where: ClientDestinataireWhereUniqueInput
    data: XOR<ClientDestinataireUpdateWithoutDestinataireInput, ClientDestinataireUncheckedUpdateWithoutDestinataireInput>
  }

  export type ClientDestinataireUpdateManyWithWhereWithoutDestinataireInput = {
    where: ClientDestinataireScalarWhereInput
    data: XOR<ClientDestinataireUpdateManyMutationInput, ClientDestinataireUncheckedUpdateManyWithoutDestinataireInput>
  }

  export type AgencyClientsUpsertWithWhereUniqueWithoutClientInput = {
    where: AgencyClientsWhereUniqueInput
    update: XOR<AgencyClientsUpdateWithoutClientInput, AgencyClientsUncheckedUpdateWithoutClientInput>
    create: XOR<AgencyClientsCreateWithoutClientInput, AgencyClientsUncheckedCreateWithoutClientInput>
  }

  export type AgencyClientsUpdateWithWhereUniqueWithoutClientInput = {
    where: AgencyClientsWhereUniqueInput
    data: XOR<AgencyClientsUpdateWithoutClientInput, AgencyClientsUncheckedUpdateWithoutClientInput>
  }

  export type AgencyClientsUpdateManyWithWhereWithoutClientInput = {
    where: AgencyClientsScalarWhereInput
    data: XOR<AgencyClientsUpdateManyMutationInput, AgencyClientsUncheckedUpdateManyWithoutClientInput>
  }

  export type AgencyClientsScalarWhereInput = {
    AND?: AgencyClientsScalarWhereInput | AgencyClientsScalarWhereInput[]
    OR?: AgencyClientsScalarWhereInput[]
    NOT?: AgencyClientsScalarWhereInput | AgencyClientsScalarWhereInput[]
    clientId?: IntFilter<"AgencyClients"> | number
    agencyId?: IntFilter<"AgencyClients"> | number
  }

  export type AgencyStaffUpsertWithWhereUniqueWithoutStaffInput = {
    where: AgencyStaffWhereUniqueInput
    update: XOR<AgencyStaffUpdateWithoutStaffInput, AgencyStaffUncheckedUpdateWithoutStaffInput>
    create: XOR<AgencyStaffCreateWithoutStaffInput, AgencyStaffUncheckedCreateWithoutStaffInput>
  }

  export type AgencyStaffUpdateWithWhereUniqueWithoutStaffInput = {
    where: AgencyStaffWhereUniqueInput
    data: XOR<AgencyStaffUpdateWithoutStaffInput, AgencyStaffUncheckedUpdateWithoutStaffInput>
  }

  export type AgencyStaffUpdateManyWithWhereWithoutStaffInput = {
    where: AgencyStaffScalarWhereInput
    data: XOR<AgencyStaffUpdateManyMutationInput, AgencyStaffUncheckedUpdateManyWithoutStaffInput>
  }

  export type AgencyStaffScalarWhereInput = {
    AND?: AgencyStaffScalarWhereInput | AgencyStaffScalarWhereInput[]
    OR?: AgencyStaffScalarWhereInput[]
    NOT?: AgencyStaffScalarWhereInput | AgencyStaffScalarWhereInput[]
    id?: IntFilter<"AgencyStaff"> | number
    staffId?: IntFilter<"AgencyStaff"> | number
    agencyId?: IntFilter<"AgencyStaff"> | number
    staffRole?: EnumRoleFilter<"AgencyStaff"> | $Enums.Role
  }

  export type UserAddressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    update: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    data: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserAddressUpdateManyWithWhereWithoutUserInput = {
    where: UserAddressScalarWhereInput
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAddressScalarWhereInput = {
    AND?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
    OR?: UserAddressScalarWhereInput[]
    NOT?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
    id?: IntFilter<"UserAddress"> | number
    userId?: IntFilter<"UserAddress"> | number
    addressId?: IntFilter<"UserAddress"> | number
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    addressType?: EnumAddressTypeFilter<"UserAddress"> | $Enums.AddressType
  }

  export type AgencyUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AgencyWhereUniqueInput
    update: XOR<AgencyUpdateWithoutCreatedByInput, AgencyUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AgencyCreateWithoutCreatedByInput, AgencyUncheckedCreateWithoutCreatedByInput>
  }

  export type AgencyUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AgencyWhereUniqueInput
    data: XOR<AgencyUpdateWithoutCreatedByInput, AgencyUncheckedUpdateWithoutCreatedByInput>
  }

  export type AgencyUpdateManyWithWhereWithoutCreatedByInput = {
    where: AgencyScalarWhereInput
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AgencyScalarWhereInput = {
    AND?: AgencyScalarWhereInput | AgencyScalarWhereInput[]
    OR?: AgencyScalarWhereInput[]
    NOT?: AgencyScalarWhereInput | AgencyScalarWhereInput[]
    id?: IntFilter<"Agency"> | number
    name?: StringFilter<"Agency"> | string
    location?: StringNullableFilter<"Agency"> | string | null
    phoneNumber?: StringNullableFilter<"Agency"> | string | null
    email?: StringNullableFilter<"Agency"> | string | null
    vatNumber?: StringNullableFilter<"Agency"> | string | null
    addressId?: IntFilter<"Agency"> | number
    capacity?: IntNullableFilter<"Agency"> | number | null
    availableSlots?: IntNullableFilter<"Agency"> | number | null
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    createdById?: IntNullableFilter<"Agency"> | number | null
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutStaffInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutStaffInput, ActivityLogUncheckedUpdateWithoutStaffInput>
    create: XOR<ActivityLogCreateWithoutStaffInput, ActivityLogUncheckedCreateWithoutStaffInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutStaffInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutStaffInput, ActivityLogUncheckedUpdateWithoutStaffInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutStaffInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutStaffInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    activityType?: EnumActivityTypeFilter<"ActivityLog"> | $Enums.ActivityType
    staffId?: IntNullableFilter<"ActivityLog"> | number | null
    agencyId?: IntNullableFilter<"ActivityLog"> | number | null
    details?: StringNullableFilter<"ActivityLog"> | string | null
    staffRole?: EnumRoleFilter<"ActivityLog"> | $Enums.Role
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    userId?: IntFilter<"PasswordResetToken"> | number
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutClientAgenciesInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientAgenciesInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientAgenciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientAgenciesInput, UserUncheckedCreateWithoutClientAgenciesInput>
  }

  export type AgencyCreateWithoutAgencyClientsInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencyClientsInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencyClientsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencyClientsInput, AgencyUncheckedCreateWithoutAgencyClientsInput>
  }

  export type UserUpsertWithoutClientAgenciesInput = {
    update: XOR<UserUpdateWithoutClientAgenciesInput, UserUncheckedUpdateWithoutClientAgenciesInput>
    create: XOR<UserCreateWithoutClientAgenciesInput, UserUncheckedCreateWithoutClientAgenciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientAgenciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientAgenciesInput, UserUncheckedUpdateWithoutClientAgenciesInput>
  }

  export type UserUpdateWithoutClientAgenciesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientAgenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgencyUpsertWithoutAgencyClientsInput = {
    update: XOR<AgencyUpdateWithoutAgencyClientsInput, AgencyUncheckedUpdateWithoutAgencyClientsInput>
    create: XOR<AgencyCreateWithoutAgencyClientsInput, AgencyUncheckedCreateWithoutAgencyClientsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencyClientsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencyClientsInput, AgencyUncheckedUpdateWithoutAgencyClientsInput>
  }

  export type AgencyUpdateWithoutAgencyClientsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencyClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type UserCreateWithoutAgencyStaffsInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgencyStaffsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgencyStaffsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyStaffsInput, UserUncheckedCreateWithoutAgencyStaffsInput>
  }

  export type AgencyCreateWithoutAgencyStaffInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencyStaffInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencyStaffInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencyStaffInput, AgencyUncheckedCreateWithoutAgencyStaffInput>
  }

  export type UserUpsertWithoutAgencyStaffsInput = {
    update: XOR<UserUpdateWithoutAgencyStaffsInput, UserUncheckedUpdateWithoutAgencyStaffsInput>
    create: XOR<UserCreateWithoutAgencyStaffsInput, UserUncheckedCreateWithoutAgencyStaffsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgencyStaffsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgencyStaffsInput, UserUncheckedUpdateWithoutAgencyStaffsInput>
  }

  export type UserUpdateWithoutAgencyStaffsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyStaffsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgencyUpsertWithoutAgencyStaffInput = {
    update: XOR<AgencyUpdateWithoutAgencyStaffInput, AgencyUncheckedUpdateWithoutAgencyStaffInput>
    create: XOR<AgencyCreateWithoutAgencyStaffInput, AgencyUncheckedCreateWithoutAgencyStaffInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencyStaffInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencyStaffInput, AgencyUncheckedUpdateWithoutAgencyStaffInput>
  }

  export type AgencyUpdateWithoutAgencyStaffInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencyStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type UserCreateWithoutStaffsActivityLogsInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStaffsActivityLogsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStaffsActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffsActivityLogsInput, UserUncheckedCreateWithoutStaffsActivityLogsInput>
  }

  export type AgencyCreateWithoutActivityLogsInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutActivityLogsInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutActivityLogsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutActivityLogsInput, AgencyUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutStaffsActivityLogsInput = {
    update: XOR<UserUpdateWithoutStaffsActivityLogsInput, UserUncheckedUpdateWithoutStaffsActivityLogsInput>
    create: XOR<UserCreateWithoutStaffsActivityLogsInput, UserUncheckedCreateWithoutStaffsActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffsActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffsActivityLogsInput, UserUncheckedUpdateWithoutStaffsActivityLogsInput>
  }

  export type UserUpdateWithoutStaffsActivityLogsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffsActivityLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgencyUpsertWithoutActivityLogsInput = {
    update: XOR<AgencyUpdateWithoutActivityLogsInput, AgencyUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<AgencyCreateWithoutActivityLogsInput, AgencyUncheckedCreateWithoutActivityLogsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutActivityLogsInput, AgencyUncheckedUpdateWithoutActivityLogsInput>
  }

  export type AgencyUpdateWithoutActivityLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutActivityLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type UserCreateWithoutAuthenticatorInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthenticatorInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthenticatorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
  }

  export type UserUpsertWithoutAuthenticatorInput = {
    update: XOR<UserUpdateWithoutAuthenticatorInput, UserUncheckedUpdateWithoutAuthenticatorInput>
    create: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthenticatorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthenticatorInput, UserUncheckedUpdateWithoutAuthenticatorInput>
  }

  export type UserUpdateWithoutAuthenticatorInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthenticatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgencyCreateWithoutNotificationsInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutNotificationsInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutNotificationsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutNotificationsInput, AgencyUncheckedCreateWithoutNotificationsInput>
  }

  export type EnvoiCreateWithoutNotificationsInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutNotificationsInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutNotificationsInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutNotificationsInput, EnvoiUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsAsDestinataireInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsAsDestinataireInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsAsDestinataireInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsAsDestinataireInput, UserUncheckedCreateWithoutNotificationsAsDestinataireInput>
  }

  export type UserCreateWithoutNotificationAsClientInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationAsClientInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationAsClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationAsClientInput, UserUncheckedCreateWithoutNotificationAsClientInput>
  }

  export type AgencyUpsertWithoutNotificationsInput = {
    update: XOR<AgencyUpdateWithoutNotificationsInput, AgencyUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AgencyCreateWithoutNotificationsInput, AgencyUncheckedCreateWithoutNotificationsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutNotificationsInput, AgencyUncheckedUpdateWithoutNotificationsInput>
  }

  export type AgencyUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type EnvoiUpsertWithoutNotificationsInput = {
    update: XOR<EnvoiUpdateWithoutNotificationsInput, EnvoiUncheckedUpdateWithoutNotificationsInput>
    create: XOR<EnvoiCreateWithoutNotificationsInput, EnvoiUncheckedCreateWithoutNotificationsInput>
    where?: EnvoiWhereInput
  }

  export type EnvoiUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: EnvoiWhereInput
    data: XOR<EnvoiUpdateWithoutNotificationsInput, EnvoiUncheckedUpdateWithoutNotificationsInput>
  }

  export type EnvoiUpdateWithoutNotificationsInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type UserUpsertWithoutNotificationsAsDestinataireInput = {
    update: XOR<UserUpdateWithoutNotificationsAsDestinataireInput, UserUncheckedUpdateWithoutNotificationsAsDestinataireInput>
    create: XOR<UserCreateWithoutNotificationsAsDestinataireInput, UserUncheckedCreateWithoutNotificationsAsDestinataireInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsAsDestinataireInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsAsDestinataireInput, UserUncheckedUpdateWithoutNotificationsAsDestinataireInput>
  }

  export type UserUpdateWithoutNotificationsAsDestinataireInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsAsDestinataireInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutNotificationAsClientInput = {
    update: XOR<UserUpdateWithoutNotificationAsClientInput, UserUncheckedUpdateWithoutNotificationAsClientInput>
    create: XOR<UserCreateWithoutNotificationAsClientInput, UserUncheckedCreateWithoutNotificationAsClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationAsClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationAsClientInput, UserUncheckedUpdateWithoutNotificationAsClientInput>
  }

  export type UserUpdateWithoutNotificationAsClientInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationAsClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CountryCreateWithoutVatRatesInput = {
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital?: string | null
    currency?: string | null
    latitude?: string | null
    longitude?: string | null
    emoji?: string | null
    cities?: CityCreateNestedManyWithoutCountryInput
    timezones?: TimezoneCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutVatRatesInput = {
    id?: number
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital?: string | null
    currency?: string | null
    latitude?: string | null
    longitude?: string | null
    emoji?: string | null
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    timezones?: TimezoneUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutVatRatesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutVatRatesInput, CountryUncheckedCreateWithoutVatRatesInput>
  }

  export type CountryUpsertWithoutVatRatesInput = {
    update: XOR<CountryUpdateWithoutVatRatesInput, CountryUncheckedUpdateWithoutVatRatesInput>
    create: XOR<CountryCreateWithoutVatRatesInput, CountryUncheckedCreateWithoutVatRatesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutVatRatesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutVatRatesInput, CountryUncheckedUpdateWithoutVatRatesInput>
  }

  export type CountryUpdateWithoutVatRatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: CityUpdateManyWithoutCountryNestedInput
    timezones?: TimezoneUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutVatRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    timezones?: TimezoneUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateWithoutCitiesInput = {
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital?: string | null
    currency?: string | null
    latitude?: string | null
    longitude?: string | null
    emoji?: string | null
    timezones?: TimezoneCreateNestedManyWithoutCountryInput
    vatRates?: VatRateCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutCitiesInput = {
    id?: number
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital?: string | null
    currency?: string | null
    latitude?: string | null
    longitude?: string | null
    emoji?: string | null
    timezones?: TimezoneUncheckedCreateNestedManyWithoutCountryInput
    vatRates?: VatRateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutCitiesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type AddressCreateWithoutCityInput = {
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userAddresses?: UserAddressCreateNestedManyWithoutAddressInput
    agency?: AgencyCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCityInput = {
    id?: number
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutAddressInput
    agency?: AgencyUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCityInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressCreateManyCityInputEnvelope = {
    data: AddressCreateManyCityInput | AddressCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutCitiesInput = {
    update: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCitiesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type CountryUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    timezones?: TimezoneUpdateManyWithoutCountryNestedInput
    vatRates?: VatRateUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    timezones?: TimezoneUncheckedUpdateManyWithoutCountryNestedInput
    vatRates?: VatRateUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type AddressUpsertWithWhereUniqueWithoutCityInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCityInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
  }

  export type AddressUpdateManyWithWhereWithoutCityInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutCityInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: IntFilter<"Address"> | number
    street?: StringFilter<"Address"> | string
    complement?: StringNullableFilter<"Address"> | string | null
    streetNumber?: StringNullableFilter<"Address"> | string | null
    boxNumber?: StringNullableFilter<"Address"> | string | null
    cityId?: IntFilter<"Address"> | number
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type CityCreateWithoutCountryInput = {
    name: string
    latitude?: string | null
    longitude?: string | null
    addresses?: AddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    latitude?: string | null
    longitude?: string | null
    addresses?: AddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountryInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityCreateManyCountryInputEnvelope = {
    data: CityCreateManyCountryInput | CityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type TimezoneCreateWithoutCountryInput = {
    zoneName: string
    gmtOffset: number
    abbreviation: string
  }

  export type TimezoneUncheckedCreateWithoutCountryInput = {
    id?: number
    zoneName: string
    gmtOffset: number
    abbreviation: string
  }

  export type TimezoneCreateOrConnectWithoutCountryInput = {
    where: TimezoneWhereUniqueInput
    create: XOR<TimezoneCreateWithoutCountryInput, TimezoneUncheckedCreateWithoutCountryInput>
  }

  export type TimezoneCreateManyCountryInputEnvelope = {
    data: TimezoneCreateManyCountryInput | TimezoneCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type VatRateCreateWithoutCountryInput = {
    itemClassId: number
    vatPercent: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vatType?: $Enums.VatType | null
  }

  export type VatRateUncheckedCreateWithoutCountryInput = {
    id?: number
    itemClassId: number
    vatPercent: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vatType?: $Enums.VatType | null
  }

  export type VatRateCreateOrConnectWithoutCountryInput = {
    where: VatRateWhereUniqueInput
    create: XOR<VatRateCreateWithoutCountryInput, VatRateUncheckedCreateWithoutCountryInput>
  }

  export type VatRateCreateManyCountryInputEnvelope = {
    data: VatRateCreateManyCountryInput | VatRateCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
  }

  export type CityUpdateManyWithWhereWithoutCountryInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCountryInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: IntFilter<"City"> | number
    name?: StringFilter<"City"> | string
    latitude?: StringNullableFilter<"City"> | string | null
    longitude?: StringNullableFilter<"City"> | string | null
    countryId?: IntFilter<"City"> | number
  }

  export type TimezoneUpsertWithWhereUniqueWithoutCountryInput = {
    where: TimezoneWhereUniqueInput
    update: XOR<TimezoneUpdateWithoutCountryInput, TimezoneUncheckedUpdateWithoutCountryInput>
    create: XOR<TimezoneCreateWithoutCountryInput, TimezoneUncheckedCreateWithoutCountryInput>
  }

  export type TimezoneUpdateWithWhereUniqueWithoutCountryInput = {
    where: TimezoneWhereUniqueInput
    data: XOR<TimezoneUpdateWithoutCountryInput, TimezoneUncheckedUpdateWithoutCountryInput>
  }

  export type TimezoneUpdateManyWithWhereWithoutCountryInput = {
    where: TimezoneScalarWhereInput
    data: XOR<TimezoneUpdateManyMutationInput, TimezoneUncheckedUpdateManyWithoutCountryInput>
  }

  export type TimezoneScalarWhereInput = {
    AND?: TimezoneScalarWhereInput | TimezoneScalarWhereInput[]
    OR?: TimezoneScalarWhereInput[]
    NOT?: TimezoneScalarWhereInput | TimezoneScalarWhereInput[]
    id?: IntFilter<"Timezone"> | number
    zoneName?: StringFilter<"Timezone"> | string
    gmtOffset?: IntFilter<"Timezone"> | number
    abbreviation?: StringFilter<"Timezone"> | string
    countryId?: IntFilter<"Timezone"> | number
  }

  export type VatRateUpsertWithWhereUniqueWithoutCountryInput = {
    where: VatRateWhereUniqueInput
    update: XOR<VatRateUpdateWithoutCountryInput, VatRateUncheckedUpdateWithoutCountryInput>
    create: XOR<VatRateCreateWithoutCountryInput, VatRateUncheckedCreateWithoutCountryInput>
  }

  export type VatRateUpdateWithWhereUniqueWithoutCountryInput = {
    where: VatRateWhereUniqueInput
    data: XOR<VatRateUpdateWithoutCountryInput, VatRateUncheckedUpdateWithoutCountryInput>
  }

  export type VatRateUpdateManyWithWhereWithoutCountryInput = {
    where: VatRateScalarWhereInput
    data: XOR<VatRateUpdateManyMutationInput, VatRateUncheckedUpdateManyWithoutCountryInput>
  }

  export type VatRateScalarWhereInput = {
    AND?: VatRateScalarWhereInput | VatRateScalarWhereInput[]
    OR?: VatRateScalarWhereInput[]
    NOT?: VatRateScalarWhereInput | VatRateScalarWhereInput[]
    id?: IntFilter<"VatRate"> | number
    countryId?: IntFilter<"VatRate"> | number
    itemClassId?: IntFilter<"VatRate"> | number
    vatPercent?: DecimalFilter<"VatRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VatRate"> | Date | string
    updatedAt?: DateTimeFilter<"VatRate"> | Date | string
    vatType?: EnumVatTypeNullableFilter<"VatRate"> | $Enums.VatType | null
  }

  export type CountryCreateWithoutTimezonesInput = {
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital?: string | null
    currency?: string | null
    latitude?: string | null
    longitude?: string | null
    emoji?: string | null
    cities?: CityCreateNestedManyWithoutCountryInput
    vatRates?: VatRateCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutTimezonesInput = {
    id?: number
    name: string
    iso2: string
    iso3: string
    phonecode: string
    capital?: string | null
    currency?: string | null
    latitude?: string | null
    longitude?: string | null
    emoji?: string | null
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    vatRates?: VatRateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutTimezonesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutTimezonesInput, CountryUncheckedCreateWithoutTimezonesInput>
  }

  export type CountryUpsertWithoutTimezonesInput = {
    update: XOR<CountryUpdateWithoutTimezonesInput, CountryUncheckedUpdateWithoutTimezonesInput>
    create: XOR<CountryCreateWithoutTimezonesInput, CountryUncheckedCreateWithoutTimezonesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutTimezonesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutTimezonesInput, CountryUncheckedUpdateWithoutTimezonesInput>
  }

  export type CountryUpdateWithoutTimezonesInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: CityUpdateManyWithoutCountryNestedInput
    vatRates?: VatRateUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutTimezonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    iso2?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    phonecode?: StringFieldUpdateOperationsInput | string
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    vatRates?: VatRateUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type AddressCreateWithoutUserAddressesInput = {
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAddressesInput
    agency?: AgencyCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutUserAddressesInput = {
    id?: number
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    cityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agency?: AgencyUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutUserAddressesInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserAddressesInput, AddressUncheckedCreateWithoutUserAddressesInput>
  }

  export type UserCreateWithoutUserAddressesInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserAddressesInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAddressesInput, UserUncheckedCreateWithoutUserAddressesInput>
  }

  export type AddressUpsertWithoutUserAddressesInput = {
    update: XOR<AddressUpdateWithoutUserAddressesInput, AddressUncheckedUpdateWithoutUserAddressesInput>
    create: XOR<AddressCreateWithoutUserAddressesInput, AddressUncheckedCreateWithoutUserAddressesInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutUserAddressesInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutUserAddressesInput, AddressUncheckedUpdateWithoutUserAddressesInput>
  }

  export type AddressUpdateWithoutUserAddressesInput = {
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAddressesNestedInput
    agency?: AgencyUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type UserUpsertWithoutUserAddressesInput = {
    update: XOR<UserUpdateWithoutUserAddressesInput, UserUncheckedUpdateWithoutUserAddressesInput>
    create: XOR<UserCreateWithoutUserAddressesInput, UserUncheckedCreateWithoutUserAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserAddressesInput, UserUncheckedUpdateWithoutUserAddressesInput>
  }

  export type UserUpdateWithoutUserAddressesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CityCreateWithoutAddressesInput = {
    name: string
    latitude?: string | null
    longitude?: string | null
    country: CountryCreateNestedOneWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutAddressesInput = {
    id?: number
    name: string
    latitude?: string | null
    longitude?: string | null
    countryId: number
  }

  export type CityCreateOrConnectWithoutAddressesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
  }

  export type UserAddressCreateWithoutAddressInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    addressType: $Enums.AddressType
    user: UserCreateNestedOneWithoutUserAddressesInput
  }

  export type UserAddressUncheckedCreateWithoutAddressInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addressType: $Enums.AddressType
  }

  export type UserAddressCreateOrConnectWithoutAddressInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput>
  }

  export type UserAddressCreateManyAddressInputEnvelope = {
    data: UserAddressCreateManyAddressInput | UserAddressCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type AgencyCreateWithoutAddressInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAddressInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAddressInput, AgencyUncheckedCreateWithoutAddressInput>
  }

  export type CityUpsertWithoutAddressesInput = {
    update: XOR<CityUpdateWithoutAddressesInput, CityUncheckedUpdateWithoutAddressesInput>
    create: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutAddressesInput, CityUncheckedUpdateWithoutAddressesInput>
  }

  export type CityUpdateWithoutAddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type UserAddressUpsertWithWhereUniqueWithoutAddressInput = {
    where: UserAddressWhereUniqueInput
    update: XOR<UserAddressUpdateWithoutAddressInput, UserAddressUncheckedUpdateWithoutAddressInput>
    create: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput>
  }

  export type UserAddressUpdateWithWhereUniqueWithoutAddressInput = {
    where: UserAddressWhereUniqueInput
    data: XOR<UserAddressUpdateWithoutAddressInput, UserAddressUncheckedUpdateWithoutAddressInput>
  }

  export type UserAddressUpdateManyWithWhereWithoutAddressInput = {
    where: UserAddressScalarWhereInput
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyWithoutAddressInput>
  }

  export type AgencyUpsertWithoutAddressInput = {
    update: XOR<AgencyUpdateWithoutAddressInput, AgencyUncheckedUpdateWithoutAddressInput>
    create: XOR<AgencyCreateWithoutAddressInput, AgencyUncheckedCreateWithoutAddressInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAddressInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAddressInput, AgencyUncheckedUpdateWithoutAddressInput>
  }

  export type AgencyUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type UserCreateWithoutCreatedAgenciesInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedAgenciesInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedAgenciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAgenciesInput, UserUncheckedCreateWithoutCreatedAgenciesInput>
  }

  export type EnvoiCreateWithoutArrivalAgencyInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutArrivalAgencyInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutArrivalAgencyInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutArrivalAgencyInput, EnvoiUncheckedCreateWithoutArrivalAgencyInput>
  }

  export type EnvoiCreateManyArrivalAgencyInputEnvelope = {
    data: EnvoiCreateManyArrivalAgencyInput | EnvoiCreateManyArrivalAgencyInput[]
    skipDuplicates?: boolean
  }

  export type EnvoiCreateWithoutDepartureAgencyInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutDepartureAgencyInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutDepartureAgencyInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutDepartureAgencyInput, EnvoiUncheckedCreateWithoutDepartureAgencyInput>
  }

  export type EnvoiCreateManyDepartureAgencyInputEnvelope = {
    data: EnvoiCreateManyDepartureAgencyInput | EnvoiCreateManyDepartureAgencyInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutAgencyInput = {
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    envoi: EnvoiCreateNestedOneWithoutNotificationsInput
    destinataireNotification?: UserCreateNestedOneWithoutNotificationsAsDestinataireInput
    clientNotification?: UserCreateNestedOneWithoutNotificationAsClientInput
  }

  export type NotificationUncheckedCreateWithoutAgencyInput = {
    id?: number
    message: string
    destinataireId?: number | null
    clientId?: number | null
    envoiId: number
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutAgencyInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput>
  }

  export type NotificationCreateManyAgencyInputEnvelope = {
    data: NotificationCreateManyAgencyInput | NotificationCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutAgencyInput = {
    date: Date | string
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    envoi: EnvoiCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutAgencyInput = {
    id?: number
    envoiId: number
    date: Date | string
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutAgencyInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutAgencyInput, AppointmentUncheckedCreateWithoutAgencyInput>
  }

  export type AppointmentCreateManyAgencyInputEnvelope = {
    data: AppointmentCreateManyAgencyInput | AppointmentCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type TransportCreateWithoutAgencyInput = {
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    envois?: EnvoiCreateNestedManyWithoutTransportInput
    transportSchedules?: TransportScheduleCreateNestedManyWithoutTransportInput
  }

  export type TransportUncheckedCreateWithoutAgencyInput = {
    id?: number
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    envois?: EnvoiUncheckedCreateNestedManyWithoutTransportInput
    transportSchedules?: TransportScheduleUncheckedCreateNestedManyWithoutTransportInput
  }

  export type TransportCreateOrConnectWithoutAgencyInput = {
    where: TransportWhereUniqueInput
    create: XOR<TransportCreateWithoutAgencyInput, TransportUncheckedCreateWithoutAgencyInput>
  }

  export type TransportCreateManyAgencyInputEnvelope = {
    data: TransportCreateManyAgencyInput | TransportCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type TarifsCreateWithoutAgencyInput = {
    weightRate: Decimal | DecimalJsLike | number | string
    volumeRate: Decimal | DecimalJsLike | number | string
    baseRate: Decimal | DecimalJsLike | number | string
    fixedRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TarifsUncheckedCreateWithoutAgencyInput = {
    id?: number
    weightRate: Decimal | DecimalJsLike | number | string
    volumeRate: Decimal | DecimalJsLike | number | string
    baseRate: Decimal | DecimalJsLike | number | string
    fixedRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TarifsCreateOrConnectWithoutAgencyInput = {
    where: TarifsWhereUniqueInput
    create: XOR<TarifsCreateWithoutAgencyInput, TarifsUncheckedCreateWithoutAgencyInput>
  }

  export type TarifsCreateManyAgencyInputEnvelope = {
    data: TarifsCreateManyAgencyInput | TarifsCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutAgencyInput = {
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAddressesInput
    userAddresses?: UserAddressCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutAgencyInput = {
    id?: number
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    cityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutAgencyInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutAgencyInput, AddressUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyClientsCreateWithoutAgencyInput = {
    client: UserCreateNestedOneWithoutClientAgenciesInput
  }

  export type AgencyClientsUncheckedCreateWithoutAgencyInput = {
    clientId: number
  }

  export type AgencyClientsCreateOrConnectWithoutAgencyInput = {
    where: AgencyClientsWhereUniqueInput
    create: XOR<AgencyClientsCreateWithoutAgencyInput, AgencyClientsUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyClientsCreateManyAgencyInputEnvelope = {
    data: AgencyClientsCreateManyAgencyInput | AgencyClientsCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyStaffCreateWithoutAgencyInput = {
    staffRole: $Enums.Role
    staff: UserCreateNestedOneWithoutAgencyStaffsInput
  }

  export type AgencyStaffUncheckedCreateWithoutAgencyInput = {
    id?: number
    staffId: number
    staffRole: $Enums.Role
  }

  export type AgencyStaffCreateOrConnectWithoutAgencyInput = {
    where: AgencyStaffWhereUniqueInput
    create: XOR<AgencyStaffCreateWithoutAgencyInput, AgencyStaffUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyStaffCreateManyAgencyInputEnvelope = {
    data: AgencyStaffCreateManyAgencyInput | AgencyStaffCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutAgencyInput = {
    activityType: $Enums.ActivityType
    details?: string | null
    staffRole: $Enums.Role
    createdAt?: Date | string
    staff?: UserCreateNestedOneWithoutStaffsActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutAgencyInput = {
    id?: number
    activityType: $Enums.ActivityType
    staffId?: number | null
    details?: string | null
    staffRole: $Enums.Role
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutAgencyInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutAgencyInput, ActivityLogUncheckedCreateWithoutAgencyInput>
  }

  export type ActivityLogCreateManyAgencyInputEnvelope = {
    data: ActivityLogCreateManyAgencyInput | ActivityLogCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedAgenciesInput = {
    update: XOR<UserUpdateWithoutCreatedAgenciesInput, UserUncheckedUpdateWithoutCreatedAgenciesInput>
    create: XOR<UserCreateWithoutCreatedAgenciesInput, UserUncheckedCreateWithoutCreatedAgenciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAgenciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAgenciesInput, UserUncheckedUpdateWithoutCreatedAgenciesInput>
  }

  export type UserUpdateWithoutCreatedAgenciesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAgenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EnvoiUpsertWithWhereUniqueWithoutArrivalAgencyInput = {
    where: EnvoiWhereUniqueInput
    update: XOR<EnvoiUpdateWithoutArrivalAgencyInput, EnvoiUncheckedUpdateWithoutArrivalAgencyInput>
    create: XOR<EnvoiCreateWithoutArrivalAgencyInput, EnvoiUncheckedCreateWithoutArrivalAgencyInput>
  }

  export type EnvoiUpdateWithWhereUniqueWithoutArrivalAgencyInput = {
    where: EnvoiWhereUniqueInput
    data: XOR<EnvoiUpdateWithoutArrivalAgencyInput, EnvoiUncheckedUpdateWithoutArrivalAgencyInput>
  }

  export type EnvoiUpdateManyWithWhereWithoutArrivalAgencyInput = {
    where: EnvoiScalarWhereInput
    data: XOR<EnvoiUpdateManyMutationInput, EnvoiUncheckedUpdateManyWithoutArrivalAgencyInput>
  }

  export type EnvoiUpsertWithWhereUniqueWithoutDepartureAgencyInput = {
    where: EnvoiWhereUniqueInput
    update: XOR<EnvoiUpdateWithoutDepartureAgencyInput, EnvoiUncheckedUpdateWithoutDepartureAgencyInput>
    create: XOR<EnvoiCreateWithoutDepartureAgencyInput, EnvoiUncheckedCreateWithoutDepartureAgencyInput>
  }

  export type EnvoiUpdateWithWhereUniqueWithoutDepartureAgencyInput = {
    where: EnvoiWhereUniqueInput
    data: XOR<EnvoiUpdateWithoutDepartureAgencyInput, EnvoiUncheckedUpdateWithoutDepartureAgencyInput>
  }

  export type EnvoiUpdateManyWithWhereWithoutDepartureAgencyInput = {
    where: EnvoiScalarWhereInput
    data: XOR<EnvoiUpdateManyMutationInput, EnvoiUncheckedUpdateManyWithoutDepartureAgencyInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutAgencyInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutAgencyInput, NotificationUncheckedUpdateWithoutAgencyInput>
    create: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutAgencyInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutAgencyInput, NotificationUncheckedUpdateWithoutAgencyInput>
  }

  export type NotificationUpdateManyWithWhereWithoutAgencyInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutAgencyInput, AppointmentUncheckedUpdateWithoutAgencyInput>
    create: XOR<AppointmentCreateWithoutAgencyInput, AppointmentUncheckedCreateWithoutAgencyInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutAgencyInput, AppointmentUncheckedUpdateWithoutAgencyInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutAgencyInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: IntFilter<"Appointment"> | number
    envoiId?: IntFilter<"Appointment"> | number
    agencyId?: IntFilter<"Appointment"> | number
    date?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type TransportUpsertWithWhereUniqueWithoutAgencyInput = {
    where: TransportWhereUniqueInput
    update: XOR<TransportUpdateWithoutAgencyInput, TransportUncheckedUpdateWithoutAgencyInput>
    create: XOR<TransportCreateWithoutAgencyInput, TransportUncheckedCreateWithoutAgencyInput>
  }

  export type TransportUpdateWithWhereUniqueWithoutAgencyInput = {
    where: TransportWhereUniqueInput
    data: XOR<TransportUpdateWithoutAgencyInput, TransportUncheckedUpdateWithoutAgencyInput>
  }

  export type TransportUpdateManyWithWhereWithoutAgencyInput = {
    where: TransportScalarWhereInput
    data: XOR<TransportUpdateManyMutationInput, TransportUncheckedUpdateManyWithoutAgencyInput>
  }

  export type TransportScalarWhereInput = {
    AND?: TransportScalarWhereInput | TransportScalarWhereInput[]
    OR?: TransportScalarWhereInput[]
    NOT?: TransportScalarWhereInput | TransportScalarWhereInput[]
    id?: IntFilter<"Transport"> | number
    number?: StringFilter<"Transport"> | string
    baseVolume?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFilter<"Transport"> | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFilter<"Transport"> | boolean
    agencyId?: IntNullableFilter<"Transport"> | number | null
    createdAt?: DateTimeFilter<"Transport"> | Date | string
    updatedAt?: DateTimeFilter<"Transport"> | Date | string
  }

  export type TarifsUpsertWithWhereUniqueWithoutAgencyInput = {
    where: TarifsWhereUniqueInput
    update: XOR<TarifsUpdateWithoutAgencyInput, TarifsUncheckedUpdateWithoutAgencyInput>
    create: XOR<TarifsCreateWithoutAgencyInput, TarifsUncheckedCreateWithoutAgencyInput>
  }

  export type TarifsUpdateWithWhereUniqueWithoutAgencyInput = {
    where: TarifsWhereUniqueInput
    data: XOR<TarifsUpdateWithoutAgencyInput, TarifsUncheckedUpdateWithoutAgencyInput>
  }

  export type TarifsUpdateManyWithWhereWithoutAgencyInput = {
    where: TarifsScalarWhereInput
    data: XOR<TarifsUpdateManyMutationInput, TarifsUncheckedUpdateManyWithoutAgencyInput>
  }

  export type TarifsScalarWhereInput = {
    AND?: TarifsScalarWhereInput | TarifsScalarWhereInput[]
    OR?: TarifsScalarWhereInput[]
    NOT?: TarifsScalarWhereInput | TarifsScalarWhereInput[]
    id?: IntFilter<"Tarifs"> | number
    agencyId?: IntNullableFilter<"Tarifs"> | number | null
    weightRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFilter<"Tarifs"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Tarifs"> | Date | string
    updatedAt?: DateTimeFilter<"Tarifs"> | Date | string
  }

  export type AddressUpsertWithoutAgencyInput = {
    update: XOR<AddressUpdateWithoutAgencyInput, AddressUncheckedUpdateWithoutAgencyInput>
    create: XOR<AddressCreateWithoutAgencyInput, AddressUncheckedCreateWithoutAgencyInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutAgencyInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutAgencyInput, AddressUncheckedUpdateWithoutAgencyInput>
  }

  export type AddressUpdateWithoutAgencyInput = {
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAddressesNestedInput
    userAddresses?: UserAddressUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAddresses?: UserAddressUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AgencyClientsUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyClientsWhereUniqueInput
    update: XOR<AgencyClientsUpdateWithoutAgencyInput, AgencyClientsUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyClientsCreateWithoutAgencyInput, AgencyClientsUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyClientsUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyClientsWhereUniqueInput
    data: XOR<AgencyClientsUpdateWithoutAgencyInput, AgencyClientsUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyClientsUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyClientsScalarWhereInput
    data: XOR<AgencyClientsUpdateManyMutationInput, AgencyClientsUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyStaffUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyStaffWhereUniqueInput
    update: XOR<AgencyStaffUpdateWithoutAgencyInput, AgencyStaffUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyStaffCreateWithoutAgencyInput, AgencyStaffUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyStaffUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyStaffWhereUniqueInput
    data: XOR<AgencyStaffUpdateWithoutAgencyInput, AgencyStaffUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyStaffUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyStaffScalarWhereInput
    data: XOR<AgencyStaffUpdateManyMutationInput, AgencyStaffUncheckedUpdateManyWithoutAgencyInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutAgencyInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutAgencyInput, ActivityLogUncheckedUpdateWithoutAgencyInput>
    create: XOR<ActivityLogCreateWithoutAgencyInput, ActivityLogUncheckedCreateWithoutAgencyInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutAgencyInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutAgencyInput, ActivityLogUncheckedUpdateWithoutAgencyInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutAgencyInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutAgencyInput>
  }

  export type UserCreateWithoutClientLinksInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientLinksInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientLinksInput, UserUncheckedCreateWithoutClientLinksInput>
  }

  export type UserCreateWithoutDestinataireLinksInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDestinataireLinksInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDestinataireLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDestinataireLinksInput, UserUncheckedCreateWithoutDestinataireLinksInput>
  }

  export type UserUpsertWithoutClientLinksInput = {
    update: XOR<UserUpdateWithoutClientLinksInput, UserUncheckedUpdateWithoutClientLinksInput>
    create: XOR<UserCreateWithoutClientLinksInput, UserUncheckedCreateWithoutClientLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientLinksInput, UserUncheckedUpdateWithoutClientLinksInput>
  }

  export type UserUpdateWithoutClientLinksInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutDestinataireLinksInput = {
    update: XOR<UserUpdateWithoutDestinataireLinksInput, UserUncheckedUpdateWithoutDestinataireLinksInput>
    create: XOR<UserCreateWithoutDestinataireLinksInput, UserUncheckedCreateWithoutDestinataireLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDestinataireLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDestinataireLinksInput, UserUncheckedUpdateWithoutDestinataireLinksInput>
  }

  export type UserUpdateWithoutDestinataireLinksInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDestinataireLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCouponCreateWithoutCouponInput = {
    user: UserCreateNestedOneWithoutUserCouponsInput
  }

  export type UserCouponUncheckedCreateWithoutCouponInput = {
    userId: number
  }

  export type UserCouponCreateOrConnectWithoutCouponInput = {
    where: UserCouponWhereUniqueInput
    create: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput>
  }

  export type UserCouponCreateManyCouponInputEnvelope = {
    data: UserCouponCreateManyCouponInput | UserCouponCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type EnvoiCouponCreateWithoutCouponInput = {
    envoi: EnvoiCreateNestedOneWithoutEnvoiCouponsInput
  }

  export type EnvoiCouponUncheckedCreateWithoutCouponInput = {
    envoiId: number
  }

  export type EnvoiCouponCreateOrConnectWithoutCouponInput = {
    where: EnvoiCouponWhereUniqueInput
    create: XOR<EnvoiCouponCreateWithoutCouponInput, EnvoiCouponUncheckedCreateWithoutCouponInput>
  }

  export type EnvoiCouponCreateManyCouponInputEnvelope = {
    data: EnvoiCouponCreateManyCouponInput | EnvoiCouponCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type UserCouponUpsertWithWhereUniqueWithoutCouponInput = {
    where: UserCouponWhereUniqueInput
    update: XOR<UserCouponUpdateWithoutCouponInput, UserCouponUncheckedUpdateWithoutCouponInput>
    create: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput>
  }

  export type UserCouponUpdateWithWhereUniqueWithoutCouponInput = {
    where: UserCouponWhereUniqueInput
    data: XOR<UserCouponUpdateWithoutCouponInput, UserCouponUncheckedUpdateWithoutCouponInput>
  }

  export type UserCouponUpdateManyWithWhereWithoutCouponInput = {
    where: UserCouponScalarWhereInput
    data: XOR<UserCouponUpdateManyMutationInput, UserCouponUncheckedUpdateManyWithoutCouponInput>
  }

  export type EnvoiCouponUpsertWithWhereUniqueWithoutCouponInput = {
    where: EnvoiCouponWhereUniqueInput
    update: XOR<EnvoiCouponUpdateWithoutCouponInput, EnvoiCouponUncheckedUpdateWithoutCouponInput>
    create: XOR<EnvoiCouponCreateWithoutCouponInput, EnvoiCouponUncheckedCreateWithoutCouponInput>
  }

  export type EnvoiCouponUpdateWithWhereUniqueWithoutCouponInput = {
    where: EnvoiCouponWhereUniqueInput
    data: XOR<EnvoiCouponUpdateWithoutCouponInput, EnvoiCouponUncheckedUpdateWithoutCouponInput>
  }

  export type EnvoiCouponUpdateManyWithWhereWithoutCouponInput = {
    where: EnvoiCouponScalarWhereInput
    data: XOR<EnvoiCouponUpdateManyMutationInput, EnvoiCouponUncheckedUpdateManyWithoutCouponInput>
  }

  export type EnvoiCouponScalarWhereInput = {
    AND?: EnvoiCouponScalarWhereInput | EnvoiCouponScalarWhereInput[]
    OR?: EnvoiCouponScalarWhereInput[]
    NOT?: EnvoiCouponScalarWhereInput | EnvoiCouponScalarWhereInput[]
    envoiId?: IntFilter<"EnvoiCoupon"> | number
    couponId?: IntFilter<"EnvoiCoupon"> | number
  }

  export type UserCreateWithoutUserCouponsInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserCouponsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserCouponsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCouponsInput, UserUncheckedCreateWithoutUserCouponsInput>
  }

  export type CouponCreateWithoutUserCouponInput = {
    couponCode: string
    discountAmount: Decimal | DecimalJsLike | number | string
    discountPercentage: Decimal | DecimalJsLike | number | string
    numberOfUses: number
    startDate: Date | string
    expirationDate?: Date | string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupon?: EnvoiCouponCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutUserCouponInput = {
    id?: number
    couponCode: string
    discountAmount: Decimal | DecimalJsLike | number | string
    discountPercentage: Decimal | DecimalJsLike | number | string
    numberOfUses: number
    startDate: Date | string
    expirationDate?: Date | string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupon?: EnvoiCouponUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutUserCouponInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutUserCouponInput, CouponUncheckedCreateWithoutUserCouponInput>
  }

  export type UserUpsertWithoutUserCouponsInput = {
    update: XOR<UserUpdateWithoutUserCouponsInput, UserUncheckedUpdateWithoutUserCouponsInput>
    create: XOR<UserCreateWithoutUserCouponsInput, UserUncheckedCreateWithoutUserCouponsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserCouponsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserCouponsInput, UserUncheckedUpdateWithoutUserCouponsInput>
  }

  export type UserUpdateWithoutUserCouponsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CouponUpsertWithoutUserCouponInput = {
    update: XOR<CouponUpdateWithoutUserCouponInput, CouponUncheckedUpdateWithoutUserCouponInput>
    create: XOR<CouponCreateWithoutUserCouponInput, CouponUncheckedCreateWithoutUserCouponInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutUserCouponInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutUserCouponInput, CouponUncheckedUpdateWithoutUserCouponInput>
  }

  export type CouponUpdateWithoutUserCouponInput = {
    couponCode?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupon?: EnvoiCouponUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutUserCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    couponCode?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupon?: EnvoiCouponUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type EnvoiCreateWithoutTransportInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutTransportInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutTransportInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutTransportInput, EnvoiUncheckedCreateWithoutTransportInput>
  }

  export type EnvoiCreateManyTransportInputEnvelope = {
    data: EnvoiCreateManyTransportInput | EnvoiCreateManyTransportInput[]
    skipDuplicates?: boolean
  }

  export type TransportScheduleCreateWithoutTransportInput = {
    departureDate: Date | string
    arrivalDate: Date | string
    isHoliday?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportScheduleUncheckedCreateWithoutTransportInput = {
    id?: number
    departureDate: Date | string
    arrivalDate: Date | string
    isHoliday?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportScheduleCreateOrConnectWithoutTransportInput = {
    where: TransportScheduleWhereUniqueInput
    create: XOR<TransportScheduleCreateWithoutTransportInput, TransportScheduleUncheckedCreateWithoutTransportInput>
  }

  export type TransportScheduleCreateManyTransportInputEnvelope = {
    data: TransportScheduleCreateManyTransportInput | TransportScheduleCreateManyTransportInput[]
    skipDuplicates?: boolean
  }

  export type AgencyCreateWithoutTransportsInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutTransportsInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutTransportsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutTransportsInput, AgencyUncheckedCreateWithoutTransportsInput>
  }

  export type EnvoiUpsertWithWhereUniqueWithoutTransportInput = {
    where: EnvoiWhereUniqueInput
    update: XOR<EnvoiUpdateWithoutTransportInput, EnvoiUncheckedUpdateWithoutTransportInput>
    create: XOR<EnvoiCreateWithoutTransportInput, EnvoiUncheckedCreateWithoutTransportInput>
  }

  export type EnvoiUpdateWithWhereUniqueWithoutTransportInput = {
    where: EnvoiWhereUniqueInput
    data: XOR<EnvoiUpdateWithoutTransportInput, EnvoiUncheckedUpdateWithoutTransportInput>
  }

  export type EnvoiUpdateManyWithWhereWithoutTransportInput = {
    where: EnvoiScalarWhereInput
    data: XOR<EnvoiUpdateManyMutationInput, EnvoiUncheckedUpdateManyWithoutTransportInput>
  }

  export type TransportScheduleUpsertWithWhereUniqueWithoutTransportInput = {
    where: TransportScheduleWhereUniqueInput
    update: XOR<TransportScheduleUpdateWithoutTransportInput, TransportScheduleUncheckedUpdateWithoutTransportInput>
    create: XOR<TransportScheduleCreateWithoutTransportInput, TransportScheduleUncheckedCreateWithoutTransportInput>
  }

  export type TransportScheduleUpdateWithWhereUniqueWithoutTransportInput = {
    where: TransportScheduleWhereUniqueInput
    data: XOR<TransportScheduleUpdateWithoutTransportInput, TransportScheduleUncheckedUpdateWithoutTransportInput>
  }

  export type TransportScheduleUpdateManyWithWhereWithoutTransportInput = {
    where: TransportScheduleScalarWhereInput
    data: XOR<TransportScheduleUpdateManyMutationInput, TransportScheduleUncheckedUpdateManyWithoutTransportInput>
  }

  export type TransportScheduleScalarWhereInput = {
    AND?: TransportScheduleScalarWhereInput | TransportScheduleScalarWhereInput[]
    OR?: TransportScheduleScalarWhereInput[]
    NOT?: TransportScheduleScalarWhereInput | TransportScheduleScalarWhereInput[]
    id?: IntFilter<"TransportSchedule"> | number
    transportId?: IntFilter<"TransportSchedule"> | number
    departureDate?: DateTimeFilter<"TransportSchedule"> | Date | string
    arrivalDate?: DateTimeFilter<"TransportSchedule"> | Date | string
    isHoliday?: BoolFilter<"TransportSchedule"> | boolean
    createdAt?: DateTimeFilter<"TransportSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"TransportSchedule"> | Date | string
  }

  export type AgencyUpsertWithoutTransportsInput = {
    update: XOR<AgencyUpdateWithoutTransportsInput, AgencyUncheckedUpdateWithoutTransportsInput>
    create: XOR<AgencyCreateWithoutTransportsInput, AgencyUncheckedCreateWithoutTransportsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutTransportsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutTransportsInput, AgencyUncheckedUpdateWithoutTransportsInput>
  }

  export type AgencyUpdateWithoutTransportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutTransportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateWithoutArrivalEnvoiInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutArrivalEnvoiInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutArrivalEnvoiInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutArrivalEnvoiInput, AgencyUncheckedCreateWithoutArrivalEnvoiInput>
  }

  export type AgencyCreateWithoutDepartureEnvoiInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutDepartureEnvoiInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutDepartureEnvoiInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutDepartureEnvoiInput, AgencyUncheckedCreateWithoutDepartureEnvoiInput>
  }

  export type TransportCreateWithoutEnvoisInput = {
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transportSchedules?: TransportScheduleCreateNestedManyWithoutTransportInput
    agency?: AgencyCreateNestedOneWithoutTransportsInput
  }

  export type TransportUncheckedCreateWithoutEnvoisInput = {
    id?: number
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    agencyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transportSchedules?: TransportScheduleUncheckedCreateNestedManyWithoutTransportInput
  }

  export type TransportCreateOrConnectWithoutEnvoisInput = {
    where: TransportWhereUniqueInput
    create: XOR<TransportCreateWithoutEnvoisInput, TransportUncheckedCreateWithoutEnvoisInput>
  }

  export type UserCreateWithoutReceivedEnvoisInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiCreateNestedManyWithoutClientInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedEnvoisInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    sentEnvois?: EnvoiUncheckedCreateNestedManyWithoutClientInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedEnvoisInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedEnvoisInput, UserUncheckedCreateWithoutReceivedEnvoisInput>
  }

  export type UserCreateWithoutSentEnvoisInput = {
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    receivedEnvois?: EnvoiCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentEnvoisInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    birthDate?: Date | string | null
    email: string
    phoneNumber?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    isVerified?: boolean | null
    emailVerified?: Date | string | null
    verificationToken?: string | null
    verificationTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isEnterprise?: boolean
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    receivedEnvois?: EnvoiUncheckedCreateNestedManyWithoutDestinataireInput
    notificationsAsDestinataire?: NotificationUncheckedCreateNestedManyWithoutDestinataireNotificationInput
    notificationAsClient?: NotificationUncheckedCreateNestedManyWithoutClientNotificationInput
    userCoupons?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    clientLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutClientInput
    destinataireLinks?: ClientDestinataireUncheckedCreateNestedManyWithoutDestinataireInput
    clientAgencies?: AgencyClientsUncheckedCreateNestedManyWithoutClientInput
    agencyStaffs?: AgencyStaffUncheckedCreateNestedManyWithoutStaffInput
    userAddresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    createdAgencies?: AgencyUncheckedCreateNestedManyWithoutCreatedByInput
    staffsActivityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentEnvoisInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentEnvoisInput, UserUncheckedCreateWithoutSentEnvoisInput>
  }

  export type EnvoiCouponCreateWithoutEnvoiInput = {
    coupon: CouponCreateNestedOneWithoutEnvoiCouponInput
  }

  export type EnvoiCouponUncheckedCreateWithoutEnvoiInput = {
    couponId: number
  }

  export type EnvoiCouponCreateOrConnectWithoutEnvoiInput = {
    where: EnvoiCouponWhereUniqueInput
    create: XOR<EnvoiCouponCreateWithoutEnvoiInput, EnvoiCouponUncheckedCreateWithoutEnvoiInput>
  }

  export type EnvoiCouponCreateManyEnvoiInputEnvelope = {
    data: EnvoiCouponCreateManyEnvoiInput | EnvoiCouponCreateManyEnvoiInput[]
    skipDuplicates?: boolean
  }

  export type ParcelCreateWithoutEnvoiInput = {
    height: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    length: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParcelUncheckedCreateWithoutEnvoiInput = {
    id?: number
    height: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    length: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParcelCreateOrConnectWithoutEnvoiInput = {
    where: ParcelWhereUniqueInput
    create: XOR<ParcelCreateWithoutEnvoiInput, ParcelUncheckedCreateWithoutEnvoiInput>
  }

  export type ParcelCreateManyEnvoiInputEnvelope = {
    data: ParcelCreateManyEnvoiInput | ParcelCreateManyEnvoiInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutEnvoiInput = {
    date: Date | string
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutEnvoiInput = {
    id?: number
    agencyId: number
    date: Date | string
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutEnvoiInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutEnvoiInput, AppointmentUncheckedCreateWithoutEnvoiInput>
  }

  export type NotificationCreateWithoutEnvoiInput = {
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutNotificationsInput
    destinataireNotification?: UserCreateNestedOneWithoutNotificationsAsDestinataireInput
    clientNotification?: UserCreateNestedOneWithoutNotificationAsClientInput
  }

  export type NotificationUncheckedCreateWithoutEnvoiInput = {
    id?: number
    message: string
    agencyId: number
    destinataireId?: number | null
    clientId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutEnvoiInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutEnvoiInput, NotificationUncheckedCreateWithoutEnvoiInput>
  }

  export type NotificationCreateManyEnvoiInputEnvelope = {
    data: NotificationCreateManyEnvoiInput | NotificationCreateManyEnvoiInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutEnvoiInput = {
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutEnvoiInput = {
    id?: number
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutEnvoiInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutEnvoiInput, PaymentUncheckedCreateWithoutEnvoiInput>
  }

  export type TrackingEventCreateWithoutEnvoiInput = {
    eventStatus: $Enums.TrackingEventStatus
    location?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type TrackingEventUncheckedCreateWithoutEnvoiInput = {
    id?: number
    eventStatus: $Enums.TrackingEventStatus
    location?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type TrackingEventCreateOrConnectWithoutEnvoiInput = {
    where: TrackingEventWhereUniqueInput
    create: XOR<TrackingEventCreateWithoutEnvoiInput, TrackingEventUncheckedCreateWithoutEnvoiInput>
  }

  export type TrackingEventCreateManyEnvoiInputEnvelope = {
    data: TrackingEventCreateManyEnvoiInput | TrackingEventCreateManyEnvoiInput[]
    skipDuplicates?: boolean
  }

  export type AgencyUpsertWithoutArrivalEnvoiInput = {
    update: XOR<AgencyUpdateWithoutArrivalEnvoiInput, AgencyUncheckedUpdateWithoutArrivalEnvoiInput>
    create: XOR<AgencyCreateWithoutArrivalEnvoiInput, AgencyUncheckedCreateWithoutArrivalEnvoiInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutArrivalEnvoiInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutArrivalEnvoiInput, AgencyUncheckedUpdateWithoutArrivalEnvoiInput>
  }

  export type AgencyUpdateWithoutArrivalEnvoiInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutArrivalEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUpsertWithoutDepartureEnvoiInput = {
    update: XOR<AgencyUpdateWithoutDepartureEnvoiInput, AgencyUncheckedUpdateWithoutDepartureEnvoiInput>
    create: XOR<AgencyCreateWithoutDepartureEnvoiInput, AgencyUncheckedCreateWithoutDepartureEnvoiInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutDepartureEnvoiInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutDepartureEnvoiInput, AgencyUncheckedUpdateWithoutDepartureEnvoiInput>
  }

  export type AgencyUpdateWithoutDepartureEnvoiInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutDepartureEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type TransportUpsertWithoutEnvoisInput = {
    update: XOR<TransportUpdateWithoutEnvoisInput, TransportUncheckedUpdateWithoutEnvoisInput>
    create: XOR<TransportCreateWithoutEnvoisInput, TransportUncheckedCreateWithoutEnvoisInput>
    where?: TransportWhereInput
  }

  export type TransportUpdateToOneWithWhereWithoutEnvoisInput = {
    where?: TransportWhereInput
    data: XOR<TransportUpdateWithoutEnvoisInput, TransportUncheckedUpdateWithoutEnvoisInput>
  }

  export type TransportUpdateWithoutEnvoisInput = {
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transportSchedules?: TransportScheduleUpdateManyWithoutTransportNestedInput
    agency?: AgencyUpdateOneWithoutTransportsNestedInput
  }

  export type TransportUncheckedUpdateWithoutEnvoisInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transportSchedules?: TransportScheduleUncheckedUpdateManyWithoutTransportNestedInput
  }

  export type UserUpsertWithoutReceivedEnvoisInput = {
    update: XOR<UserUpdateWithoutReceivedEnvoisInput, UserUncheckedUpdateWithoutReceivedEnvoisInput>
    create: XOR<UserCreateWithoutReceivedEnvoisInput, UserUncheckedCreateWithoutReceivedEnvoisInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedEnvoisInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedEnvoisInput, UserUncheckedUpdateWithoutReceivedEnvoisInput>
  }

  export type UserUpdateWithoutReceivedEnvoisInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUpdateManyWithoutClientNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedEnvoisInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    sentEnvois?: EnvoiUncheckedUpdateManyWithoutClientNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutSentEnvoisInput = {
    update: XOR<UserUpdateWithoutSentEnvoisInput, UserUncheckedUpdateWithoutSentEnvoisInput>
    create: XOR<UserCreateWithoutSentEnvoisInput, UserUncheckedCreateWithoutSentEnvoisInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentEnvoisInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentEnvoisInput, UserUncheckedUpdateWithoutSentEnvoisInput>
  }

  export type UserUpdateWithoutSentEnvoisInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    receivedEnvois?: EnvoiUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentEnvoisInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    receivedEnvois?: EnvoiUncheckedUpdateManyWithoutDestinataireNestedInput
    notificationsAsDestinataire?: NotificationUncheckedUpdateManyWithoutDestinataireNotificationNestedInput
    notificationAsClient?: NotificationUncheckedUpdateManyWithoutClientNotificationNestedInput
    userCoupons?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    clientLinks?: ClientDestinataireUncheckedUpdateManyWithoutClientNestedInput
    destinataireLinks?: ClientDestinataireUncheckedUpdateManyWithoutDestinataireNestedInput
    clientAgencies?: AgencyClientsUncheckedUpdateManyWithoutClientNestedInput
    agencyStaffs?: AgencyStaffUncheckedUpdateManyWithoutStaffNestedInput
    userAddresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    createdAgencies?: AgencyUncheckedUpdateManyWithoutCreatedByNestedInput
    staffsActivityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EnvoiCouponUpsertWithWhereUniqueWithoutEnvoiInput = {
    where: EnvoiCouponWhereUniqueInput
    update: XOR<EnvoiCouponUpdateWithoutEnvoiInput, EnvoiCouponUncheckedUpdateWithoutEnvoiInput>
    create: XOR<EnvoiCouponCreateWithoutEnvoiInput, EnvoiCouponUncheckedCreateWithoutEnvoiInput>
  }

  export type EnvoiCouponUpdateWithWhereUniqueWithoutEnvoiInput = {
    where: EnvoiCouponWhereUniqueInput
    data: XOR<EnvoiCouponUpdateWithoutEnvoiInput, EnvoiCouponUncheckedUpdateWithoutEnvoiInput>
  }

  export type EnvoiCouponUpdateManyWithWhereWithoutEnvoiInput = {
    where: EnvoiCouponScalarWhereInput
    data: XOR<EnvoiCouponUpdateManyMutationInput, EnvoiCouponUncheckedUpdateManyWithoutEnvoiInput>
  }

  export type ParcelUpsertWithWhereUniqueWithoutEnvoiInput = {
    where: ParcelWhereUniqueInput
    update: XOR<ParcelUpdateWithoutEnvoiInput, ParcelUncheckedUpdateWithoutEnvoiInput>
    create: XOR<ParcelCreateWithoutEnvoiInput, ParcelUncheckedCreateWithoutEnvoiInput>
  }

  export type ParcelUpdateWithWhereUniqueWithoutEnvoiInput = {
    where: ParcelWhereUniqueInput
    data: XOR<ParcelUpdateWithoutEnvoiInput, ParcelUncheckedUpdateWithoutEnvoiInput>
  }

  export type ParcelUpdateManyWithWhereWithoutEnvoiInput = {
    where: ParcelScalarWhereInput
    data: XOR<ParcelUpdateManyMutationInput, ParcelUncheckedUpdateManyWithoutEnvoiInput>
  }

  export type ParcelScalarWhereInput = {
    AND?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
    OR?: ParcelScalarWhereInput[]
    NOT?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
    id?: IntFilter<"Parcel"> | number
    envoiId?: IntFilter<"Parcel"> | number
    height?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    weight?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    width?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    length?: DecimalFilter<"Parcel"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Parcel"> | Date | string
    updatedAt?: DateTimeFilter<"Parcel"> | Date | string
  }

  export type AppointmentUpsertWithoutEnvoiInput = {
    update: XOR<AppointmentUpdateWithoutEnvoiInput, AppointmentUncheckedUpdateWithoutEnvoiInput>
    create: XOR<AppointmentCreateWithoutEnvoiInput, AppointmentUncheckedCreateWithoutEnvoiInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutEnvoiInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutEnvoiInput, AppointmentUncheckedUpdateWithoutEnvoiInput>
  }

  export type AppointmentUpdateWithoutEnvoiInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutEnvoiInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutEnvoiInput, NotificationUncheckedUpdateWithoutEnvoiInput>
    create: XOR<NotificationCreateWithoutEnvoiInput, NotificationUncheckedCreateWithoutEnvoiInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutEnvoiInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutEnvoiInput, NotificationUncheckedUpdateWithoutEnvoiInput>
  }

  export type NotificationUpdateManyWithWhereWithoutEnvoiInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutEnvoiInput>
  }

  export type PaymentUpsertWithoutEnvoiInput = {
    update: XOR<PaymentUpdateWithoutEnvoiInput, PaymentUncheckedUpdateWithoutEnvoiInput>
    create: XOR<PaymentCreateWithoutEnvoiInput, PaymentUncheckedCreateWithoutEnvoiInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutEnvoiInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutEnvoiInput, PaymentUncheckedUpdateWithoutEnvoiInput>
  }

  export type PaymentUpdateWithoutEnvoiInput = {
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingEventUpsertWithWhereUniqueWithoutEnvoiInput = {
    where: TrackingEventWhereUniqueInput
    update: XOR<TrackingEventUpdateWithoutEnvoiInput, TrackingEventUncheckedUpdateWithoutEnvoiInput>
    create: XOR<TrackingEventCreateWithoutEnvoiInput, TrackingEventUncheckedCreateWithoutEnvoiInput>
  }

  export type TrackingEventUpdateWithWhereUniqueWithoutEnvoiInput = {
    where: TrackingEventWhereUniqueInput
    data: XOR<TrackingEventUpdateWithoutEnvoiInput, TrackingEventUncheckedUpdateWithoutEnvoiInput>
  }

  export type TrackingEventUpdateManyWithWhereWithoutEnvoiInput = {
    where: TrackingEventScalarWhereInput
    data: XOR<TrackingEventUpdateManyMutationInput, TrackingEventUncheckedUpdateManyWithoutEnvoiInput>
  }

  export type TrackingEventScalarWhereInput = {
    AND?: TrackingEventScalarWhereInput | TrackingEventScalarWhereInput[]
    OR?: TrackingEventScalarWhereInput[]
    NOT?: TrackingEventScalarWhereInput | TrackingEventScalarWhereInput[]
    id?: IntFilter<"TrackingEvent"> | number
    envoiId?: IntFilter<"TrackingEvent"> | number
    eventStatus?: EnumTrackingEventStatusFilter<"TrackingEvent"> | $Enums.TrackingEventStatus
    location?: StringNullableFilter<"TrackingEvent"> | string | null
    description?: StringNullableFilter<"TrackingEvent"> | string | null
    createdAt?: DateTimeFilter<"TrackingEvent"> | Date | string
  }

  export type EnvoiCreateWithoutTrackingEventsInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutTrackingEventsInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutTrackingEventsInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutTrackingEventsInput, EnvoiUncheckedCreateWithoutTrackingEventsInput>
  }

  export type EnvoiUpsertWithoutTrackingEventsInput = {
    update: XOR<EnvoiUpdateWithoutTrackingEventsInput, EnvoiUncheckedUpdateWithoutTrackingEventsInput>
    create: XOR<EnvoiCreateWithoutTrackingEventsInput, EnvoiUncheckedCreateWithoutTrackingEventsInput>
    where?: EnvoiWhereInput
  }

  export type EnvoiUpdateToOneWithWhereWithoutTrackingEventsInput = {
    where?: EnvoiWhereInput
    data: XOR<EnvoiUpdateWithoutTrackingEventsInput, EnvoiUncheckedUpdateWithoutTrackingEventsInput>
  }

  export type EnvoiUpdateWithoutTrackingEventsInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutTrackingEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
  }

  export type EnvoiCreateWithoutAppointmentsInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutAppointmentsInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutAppointmentsInput, EnvoiUncheckedCreateWithoutAppointmentsInput>
  }

  export type AgencyCreateWithoutAppointmentsInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    tarifs?: TarifsUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAppointmentsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAppointmentsInput, AgencyUncheckedCreateWithoutAppointmentsInput>
  }

  export type EnvoiUpsertWithoutAppointmentsInput = {
    update: XOR<EnvoiUpdateWithoutAppointmentsInput, EnvoiUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<EnvoiCreateWithoutAppointmentsInput, EnvoiUncheckedCreateWithoutAppointmentsInput>
    where?: EnvoiWhereInput
  }

  export type EnvoiUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: EnvoiWhereInput
    data: XOR<EnvoiUpdateWithoutAppointmentsInput, EnvoiUncheckedUpdateWithoutAppointmentsInput>
  }

  export type EnvoiUpdateWithoutAppointmentsInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type AgencyUpsertWithoutAppointmentsInput = {
    update: XOR<AgencyUpdateWithoutAppointmentsInput, AgencyUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<AgencyCreateWithoutAppointmentsInput, AgencyUncheckedCreateWithoutAppointmentsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAppointmentsInput, AgencyUncheckedUpdateWithoutAppointmentsInput>
  }

  export type AgencyUpdateWithoutAppointmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type EnvoiCreateWithoutEnvoiCouponsInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    parcels?: ParcelCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutEnvoiCouponsInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parcels?: ParcelUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutEnvoiCouponsInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutEnvoiCouponsInput, EnvoiUncheckedCreateWithoutEnvoiCouponsInput>
  }

  export type CouponCreateWithoutEnvoiCouponInput = {
    couponCode: string
    discountAmount: Decimal | DecimalJsLike | number | string
    discountPercentage: Decimal | DecimalJsLike | number | string
    numberOfUses: number
    startDate: Date | string
    expirationDate?: Date | string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCoupon?: UserCouponCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutEnvoiCouponInput = {
    id?: number
    couponCode: string
    discountAmount: Decimal | DecimalJsLike | number | string
    discountPercentage: Decimal | DecimalJsLike | number | string
    numberOfUses: number
    startDate: Date | string
    expirationDate?: Date | string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCoupon?: UserCouponUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutEnvoiCouponInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutEnvoiCouponInput, CouponUncheckedCreateWithoutEnvoiCouponInput>
  }

  export type EnvoiUpsertWithoutEnvoiCouponsInput = {
    update: XOR<EnvoiUpdateWithoutEnvoiCouponsInput, EnvoiUncheckedUpdateWithoutEnvoiCouponsInput>
    create: XOR<EnvoiCreateWithoutEnvoiCouponsInput, EnvoiUncheckedCreateWithoutEnvoiCouponsInput>
    where?: EnvoiWhereInput
  }

  export type EnvoiUpdateToOneWithWhereWithoutEnvoiCouponsInput = {
    where?: EnvoiWhereInput
    data: XOR<EnvoiUpdateWithoutEnvoiCouponsInput, EnvoiUncheckedUpdateWithoutEnvoiCouponsInput>
  }

  export type EnvoiUpdateWithoutEnvoiCouponsInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutEnvoiCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type CouponUpsertWithoutEnvoiCouponInput = {
    update: XOR<CouponUpdateWithoutEnvoiCouponInput, CouponUncheckedUpdateWithoutEnvoiCouponInput>
    create: XOR<CouponCreateWithoutEnvoiCouponInput, CouponUncheckedCreateWithoutEnvoiCouponInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutEnvoiCouponInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutEnvoiCouponInput, CouponUncheckedUpdateWithoutEnvoiCouponInput>
  }

  export type CouponUpdateWithoutEnvoiCouponInput = {
    couponCode?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCoupon?: UserCouponUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutEnvoiCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    couponCode?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfUses?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCoupon?: UserCouponUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type EnvoiCreateWithoutParcelsInput = {
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalAgency: AgencyCreateNestedOneWithoutArrivalEnvoiInput
    departureAgency: AgencyCreateNestedOneWithoutDepartureEnvoiInput
    transport?: TransportCreateNestedOneWithoutEnvoisInput
    destinataire?: UserCreateNestedOneWithoutReceivedEnvoisInput
    client?: UserCreateNestedOneWithoutSentEnvoisInput
    envoiCoupons?: EnvoiCouponCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationCreateNestedManyWithoutEnvoiInput
    payment?: PaymentCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiUncheckedCreateWithoutParcelsInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envoiCoupons?: EnvoiCouponUncheckedCreateNestedManyWithoutEnvoiInput
    appointments?: AppointmentUncheckedCreateNestedOneWithoutEnvoiInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEnvoiInput
    payment?: PaymentUncheckedCreateNestedOneWithoutEnvoiInput
    trackingEvents?: TrackingEventUncheckedCreateNestedManyWithoutEnvoiInput
  }

  export type EnvoiCreateOrConnectWithoutParcelsInput = {
    where: EnvoiWhereUniqueInput
    create: XOR<EnvoiCreateWithoutParcelsInput, EnvoiUncheckedCreateWithoutParcelsInput>
  }

  export type EnvoiUpsertWithoutParcelsInput = {
    update: XOR<EnvoiUpdateWithoutParcelsInput, EnvoiUncheckedUpdateWithoutParcelsInput>
    create: XOR<EnvoiCreateWithoutParcelsInput, EnvoiUncheckedCreateWithoutParcelsInput>
    where?: EnvoiWhereInput
  }

  export type EnvoiUpdateToOneWithWhereWithoutParcelsInput = {
    where?: EnvoiWhereInput
    data: XOR<EnvoiUpdateWithoutParcelsInput, EnvoiUncheckedUpdateWithoutParcelsInput>
  }

  export type EnvoiUpdateWithoutParcelsInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutParcelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type AgencyCreateWithoutTarifsInput = {
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedAgenciesInput
    arrivalEnvoi?: EnvoiCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentCreateNestedManyWithoutAgencyInput
    transports?: TransportCreateNestedManyWithoutAgencyInput
    address: AddressCreateNestedOneWithoutAgencyInput
    agencyClients?: AgencyClientsCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutTarifsInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    createdById?: number | null
    arrivalEnvoi?: EnvoiUncheckedCreateNestedManyWithoutArrivalAgencyInput
    departureEnvoi?: EnvoiUncheckedCreateNestedManyWithoutDepartureAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAgencyInput
    transports?: TransportUncheckedCreateNestedManyWithoutAgencyInput
    agencyClients?: AgencyClientsUncheckedCreateNestedManyWithoutAgencyInput
    agencyStaff?: AgencyStaffUncheckedCreateNestedManyWithoutAgencyInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutTarifsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutTarifsInput, AgencyUncheckedCreateWithoutTarifsInput>
  }

  export type AgencyUpsertWithoutTarifsInput = {
    update: XOR<AgencyUpdateWithoutTarifsInput, AgencyUncheckedUpdateWithoutTarifsInput>
    create: XOR<AgencyCreateWithoutTarifsInput, AgencyUncheckedCreateWithoutTarifsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutTarifsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutTarifsInput, AgencyUncheckedUpdateWithoutTarifsInput>
  }

  export type AgencyUpdateWithoutTarifsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedAgenciesNestedInput
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutTarifsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type TransportCreateWithoutTransportSchedulesInput = {
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    envois?: EnvoiCreateNestedManyWithoutTransportInput
    agency?: AgencyCreateNestedOneWithoutTransportsInput
  }

  export type TransportUncheckedCreateWithoutTransportSchedulesInput = {
    id?: number
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    agencyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    envois?: EnvoiUncheckedCreateNestedManyWithoutTransportInput
  }

  export type TransportCreateOrConnectWithoutTransportSchedulesInput = {
    where: TransportWhereUniqueInput
    create: XOR<TransportCreateWithoutTransportSchedulesInput, TransportUncheckedCreateWithoutTransportSchedulesInput>
  }

  export type TransportUpsertWithoutTransportSchedulesInput = {
    update: XOR<TransportUpdateWithoutTransportSchedulesInput, TransportUncheckedUpdateWithoutTransportSchedulesInput>
    create: XOR<TransportCreateWithoutTransportSchedulesInput, TransportUncheckedCreateWithoutTransportSchedulesInput>
    where?: TransportWhereInput
  }

  export type TransportUpdateToOneWithWhereWithoutTransportSchedulesInput = {
    where?: TransportWhereInput
    data: XOR<TransportUpdateWithoutTransportSchedulesInput, TransportUncheckedUpdateWithoutTransportSchedulesInput>
  }

  export type TransportUpdateWithoutTransportSchedulesInput = {
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envois?: EnvoiUpdateManyWithoutTransportNestedInput
    agency?: AgencyUpdateOneWithoutTransportsNestedInput
  }

  export type TransportUncheckedUpdateWithoutTransportSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envois?: EnvoiUncheckedUpdateManyWithoutTransportNestedInput
  }

  export type AccountCreateManyUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthenticatorCreateManyUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type EnvoiCreateManyClientInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnvoiCreateManyDestinataireInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    transportId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyDestinataireNotificationInput = {
    id?: number
    message: string
    agencyId: number
    clientId?: number | null
    envoiId: number
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyClientNotificationInput = {
    id?: number
    message: string
    agencyId: number
    destinataireId?: number | null
    envoiId: number
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCouponCreateManyUserInput = {
    couponId: number
  }

  export type ClientDestinataireCreateManyClientInput = {
    id?: number
    destinataireId: number
    createdAt?: Date | string
  }

  export type ClientDestinataireCreateManyDestinataireInput = {
    id?: number
    clientId: number
    createdAt?: Date | string
  }

  export type AgencyClientsCreateManyClientInput = {
    agencyId: number
  }

  export type AgencyStaffCreateManyStaffInput = {
    id?: number
    agencyId: number
    staffRole: $Enums.Role
  }

  export type UserAddressCreateManyUserInput = {
    id?: number
    addressId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addressType: $Enums.AddressType
  }

  export type AgencyCreateManyCreatedByInput = {
    id?: number
    name: string
    location?: string | null
    phoneNumber?: string | null
    email?: string | null
    vatNumber?: string | null
    addressId: number
    capacity?: number | null
    availableSlots?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ActivityLogCreateManyStaffInput = {
    id?: number
    activityType: $Enums.ActivityType
    agencyId?: number | null
    details?: string | null
    staffRole: $Enums.Role
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthenticatorUpdateWithoutUserInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateWithoutUserInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateManyWithoutUserInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnvoiUpdateWithoutClientInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvoiUpdateWithoutDestinataireInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutDestinataireInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateManyWithoutDestinataireInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutDestinataireNotificationInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutNotificationsNestedInput
    envoi?: EnvoiUpdateOneRequiredWithoutNotificationsNestedInput
    clientNotification?: UserUpdateOneWithoutNotificationAsClientNestedInput
  }

  export type NotificationUncheckedUpdateWithoutDestinataireNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    agencyId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    envoiId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutDestinataireNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    agencyId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    envoiId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutClientNotificationInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutNotificationsNestedInput
    envoi?: EnvoiUpdateOneRequiredWithoutNotificationsNestedInput
    destinataireNotification?: UserUpdateOneWithoutNotificationsAsDestinataireNestedInput
  }

  export type NotificationUncheckedUpdateWithoutClientNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    agencyId?: IntFieldUpdateOperationsInput | number
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    envoiId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutClientNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    agencyId?: IntFieldUpdateOperationsInput | number
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    envoiId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponUpdateWithoutUserInput = {
    coupon?: CouponUpdateOneRequiredWithoutUserCouponNestedInput
  }

  export type UserCouponUncheckedUpdateWithoutUserInput = {
    couponId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCouponUncheckedUpdateManyWithoutUserInput = {
    couponId?: IntFieldUpdateOperationsInput | number
  }

  export type ClientDestinataireUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinataire?: UserUpdateOneRequiredWithoutDestinataireLinksNestedInput
  }

  export type ClientDestinataireUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    destinataireId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDestinataireUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    destinataireId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDestinataireUpdateWithoutDestinataireInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutClientLinksNestedInput
  }

  export type ClientDestinataireUncheckedUpdateWithoutDestinataireInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDestinataireUncheckedUpdateManyWithoutDestinataireInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientsUpdateWithoutClientInput = {
    agency?: AgencyUpdateOneRequiredWithoutAgencyClientsNestedInput
  }

  export type AgencyClientsUncheckedUpdateWithoutClientInput = {
    agencyId?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyClientsUncheckedUpdateManyWithoutClientInput = {
    agencyId?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyStaffUpdateWithoutStaffInput = {
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agency?: AgencyUpdateOneRequiredWithoutAgencyStaffNestedInput
  }

  export type AgencyStaffUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AgencyStaffUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserAddressUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    address?: AddressUpdateOneRequiredWithoutUserAddressesNestedInput
  }

  export type UserAddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
  }

  export type UserAddressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
  }

  export type AgencyUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalEnvoi?: EnvoiUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUpdateManyWithoutAgencyNestedInput
    transports?: TransportUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUpdateManyWithoutAgencyNestedInput
    address?: AddressUpdateOneRequiredWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalEnvoi?: EnvoiUncheckedUpdateManyWithoutArrivalAgencyNestedInput
    departureEnvoi?: EnvoiUncheckedUpdateManyWithoutDepartureAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAgencyNestedInput
    transports?: TransportUncheckedUpdateManyWithoutAgencyNestedInput
    tarifs?: TarifsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClients?: AgencyClientsUncheckedUpdateManyWithoutAgencyNestedInput
    agencyStaff?: AgencyStaffUncheckedUpdateManyWithoutAgencyNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    availableSlots?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutStaffInput = {
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    agencyId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyCityInput = {
    id?: number
    street: string
    complement?: string | null
    streetNumber?: string | null
    boxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateWithoutCityInput = {
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAddresses?: UserAddressUpdateManyWithoutAddressNestedInput
    agency?: AgencyUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAddresses?: UserAddressUncheckedUpdateManyWithoutAddressNestedInput
    agency?: AgencyUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    boxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateManyCountryInput = {
    id?: number
    name: string
    latitude?: string | null
    longitude?: string | null
  }

  export type TimezoneCreateManyCountryInput = {
    id?: number
    zoneName: string
    gmtOffset: number
    abbreviation: string
  }

  export type VatRateCreateManyCountryInput = {
    id?: number
    itemClassId: number
    vatPercent: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vatType?: $Enums.VatType | null
  }

  export type CityUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: AddressUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: AddressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimezoneUpdateWithoutCountryInput = {
    zoneName?: StringFieldUpdateOperationsInput | string
    gmtOffset?: IntFieldUpdateOperationsInput | number
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type TimezoneUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneName?: StringFieldUpdateOperationsInput | string
    gmtOffset?: IntFieldUpdateOperationsInput | number
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type TimezoneUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneName?: StringFieldUpdateOperationsInput | string
    gmtOffset?: IntFieldUpdateOperationsInput | number
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type VatRateUpdateWithoutCountryInput = {
    itemClassId?: IntFieldUpdateOperationsInput | number
    vatPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vatType?: NullableEnumVatTypeFieldUpdateOperationsInput | $Enums.VatType | null
  }

  export type VatRateUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemClassId?: IntFieldUpdateOperationsInput | number
    vatPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vatType?: NullableEnumVatTypeFieldUpdateOperationsInput | $Enums.VatType | null
  }

  export type VatRateUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemClassId?: IntFieldUpdateOperationsInput | number
    vatPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vatType?: NullableEnumVatTypeFieldUpdateOperationsInput | $Enums.VatType | null
  }

  export type UserAddressCreateManyAddressInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addressType: $Enums.AddressType
  }

  export type UserAddressUpdateWithoutAddressInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    user?: UserUpdateOneRequiredWithoutUserAddressesNestedInput
  }

  export type UserAddressUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
  }

  export type UserAddressUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressType?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
  }

  export type EnvoiCreateManyArrivalAgencyInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    departureAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnvoiCreateManyDepartureAgencyInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    transportId?: number | null
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyAgencyInput = {
    id?: number
    message: string
    destinataireId?: number | null
    clientId?: number | null
    envoiId: number
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyAgencyInput = {
    id?: number
    envoiId: number
    date: Date | string
    status?: $Enums.AppointmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportCreateManyAgencyInput = {
    id?: number
    number: string
    baseVolume: Decimal | DecimalJsLike | number | string
    baseWeight: Decimal | DecimalJsLike | number | string
    currentVolume: Decimal | DecimalJsLike | number | string
    currentWeight: Decimal | DecimalJsLike | number | string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TarifsCreateManyAgencyInput = {
    id?: number
    weightRate: Decimal | DecimalJsLike | number | string
    volumeRate: Decimal | DecimalJsLike | number | string
    baseRate: Decimal | DecimalJsLike | number | string
    fixedRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientsCreateManyAgencyInput = {
    clientId: number
  }

  export type AgencyStaffCreateManyAgencyInput = {
    id?: number
    staffId: number
    staffRole: $Enums.Role
  }

  export type ActivityLogCreateManyAgencyInput = {
    id?: number
    activityType: $Enums.ActivityType
    staffId?: number | null
    details?: string | null
    staffRole: $Enums.Role
    createdAt?: Date | string
  }

  export type EnvoiUpdateWithoutArrivalAgencyInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutArrivalAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateManyWithoutArrivalAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvoiUpdateWithoutDepartureAgencyInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    transport?: TransportUpdateOneWithoutEnvoisNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutDepartureAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateManyWithoutDepartureAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    transportId?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutAgencyInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoi?: EnvoiUpdateOneRequiredWithoutNotificationsNestedInput
    destinataireNotification?: UserUpdateOneWithoutNotificationsAsDestinataireNestedInput
    clientNotification?: UserUpdateOneWithoutNotificationAsClientNestedInput
  }

  export type NotificationUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    envoiId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    envoiId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutAgencyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoi?: EnvoiUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    envoiId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportUpdateWithoutAgencyInput = {
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envois?: EnvoiUpdateManyWithoutTransportNestedInput
    transportSchedules?: TransportScheduleUpdateManyWithoutTransportNestedInput
  }

  export type TransportUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envois?: EnvoiUncheckedUpdateManyWithoutTransportNestedInput
    transportSchedules?: TransportScheduleUncheckedUpdateManyWithoutTransportNestedInput
  }

  export type TransportUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    baseVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TarifsUpdateWithoutAgencyInput = {
    weightRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TarifsUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    weightRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TarifsUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    weightRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volumeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    baseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientsUpdateWithoutAgencyInput = {
    client?: UserUpdateOneRequiredWithoutClientAgenciesNestedInput
  }

  export type AgencyClientsUncheckedUpdateWithoutAgencyInput = {
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyClientsUncheckedUpdateManyWithoutAgencyInput = {
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyStaffUpdateWithoutAgencyInput = {
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    staff?: UserUpdateOneRequiredWithoutAgencyStaffsNestedInput
  }

  export type AgencyStaffUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AgencyStaffUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type ActivityLogUpdateWithoutAgencyInput = {
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: UserUpdateOneWithoutStaffsActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    staffRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponCreateManyCouponInput = {
    userId: number
  }

  export type EnvoiCouponCreateManyCouponInput = {
    envoiId: number
  }

  export type UserCouponUpdateWithoutCouponInput = {
    user?: UserUpdateOneRequiredWithoutUserCouponsNestedInput
  }

  export type UserCouponUncheckedUpdateWithoutCouponInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCouponUncheckedUpdateManyWithoutCouponInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type EnvoiCouponUpdateWithoutCouponInput = {
    envoi?: EnvoiUpdateOneRequiredWithoutEnvoiCouponsNestedInput
  }

  export type EnvoiCouponUncheckedUpdateWithoutCouponInput = {
    envoiId?: IntFieldUpdateOperationsInput | number
  }

  export type EnvoiCouponUncheckedUpdateManyWithoutCouponInput = {
    envoiId?: IntFieldUpdateOperationsInput | number
  }

  export type EnvoiCreateManyTransportInput = {
    id?: number
    trackingNumber?: string | null
    qrCodeUrl?: string | null
    userId?: number | null
    destinataireId?: number | null
    departureAgencyId: number
    arrivalAgencyId: number
    simulationStatus?: $Enums.SimulationStatus
    envoiStatus?: $Enums.EnvoiStatus
    totalWeight: number
    totalVolume: number
    totalPrice: number
    paid?: boolean
    departureDate: Date | string
    arrivalDate: Date | string
    verificationToken?: string
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportScheduleCreateManyTransportInput = {
    id?: number
    departureDate: Date | string
    arrivalDate: Date | string
    isHoliday?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnvoiUpdateWithoutTransportInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalAgency?: AgencyUpdateOneRequiredWithoutArrivalEnvoiNestedInput
    departureAgency?: AgencyUpdateOneRequiredWithoutDepartureEnvoiNestedInput
    destinataire?: UserUpdateOneWithoutReceivedEnvoisNestedInput
    client?: UserUpdateOneWithoutSentEnvoisNestedInput
    envoiCoupons?: EnvoiCouponUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateWithoutTransportInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    envoiCoupons?: EnvoiCouponUncheckedUpdateManyWithoutEnvoiNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutEnvoiNestedInput
    appointments?: AppointmentUncheckedUpdateOneWithoutEnvoiNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEnvoiNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutEnvoiNestedInput
    trackingEvents?: TrackingEventUncheckedUpdateManyWithoutEnvoiNestedInput
  }

  export type EnvoiUncheckedUpdateManyWithoutTransportInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    departureAgencyId?: IntFieldUpdateOperationsInput | number
    arrivalAgencyId?: IntFieldUpdateOperationsInput | number
    simulationStatus?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    envoiStatus?: EnumEnvoiStatusFieldUpdateOperationsInput | $Enums.EnvoiStatus
    totalWeight?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportScheduleUpdateWithoutTransportInput = {
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportScheduleUncheckedUpdateWithoutTransportInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportScheduleUncheckedUpdateManyWithoutTransportInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvoiCouponCreateManyEnvoiInput = {
    couponId: number
  }

  export type ParcelCreateManyEnvoiInput = {
    id?: number
    height: Decimal | DecimalJsLike | number | string
    weight: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    length: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyEnvoiInput = {
    id?: number
    message: string
    agencyId: number
    destinataireId?: number | null
    clientId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrackingEventCreateManyEnvoiInput = {
    id?: number
    eventStatus: $Enums.TrackingEventStatus
    location?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type EnvoiCouponUpdateWithoutEnvoiInput = {
    coupon?: CouponUpdateOneRequiredWithoutEnvoiCouponNestedInput
  }

  export type EnvoiCouponUncheckedUpdateWithoutEnvoiInput = {
    couponId?: IntFieldUpdateOperationsInput | number
  }

  export type EnvoiCouponUncheckedUpdateManyWithoutEnvoiInput = {
    couponId?: IntFieldUpdateOperationsInput | number
  }

  export type ParcelUpdateWithoutEnvoiInput = {
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    length?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelUncheckedUpdateWithoutEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    length?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelUncheckedUpdateManyWithoutEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    length?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutEnvoiInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutNotificationsNestedInput
    destinataireNotification?: UserUpdateOneWithoutNotificationsAsDestinataireNestedInput
    clientNotification?: UserUpdateOneWithoutNotificationAsClientNestedInput
  }

  export type NotificationUncheckedUpdateWithoutEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    agencyId?: IntFieldUpdateOperationsInput | number
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    agencyId?: IntFieldUpdateOperationsInput | number
    destinataireId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingEventUpdateWithoutEnvoiInput = {
    eventStatus?: EnumTrackingEventStatusFieldUpdateOperationsInput | $Enums.TrackingEventStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingEventUncheckedUpdateWithoutEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventStatus?: EnumTrackingEventStatusFieldUpdateOperationsInput | $Enums.TrackingEventStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingEventUncheckedUpdateManyWithoutEnvoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventStatus?: EnumTrackingEventStatusFieldUpdateOperationsInput | $Enums.TrackingEventStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}